/* SPDX-License-Identifier: Apache-2.0 */
/* Copyright Contributors to the ODPi Egeria project. */

// This is a generated file - do not edit - changes should be made to the templates amd/or generator to generate this file with changes.

package org.odpi.openmetadata.fvt.opentypes.server;

import java.util.*;
import java.util.stream.Collectors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
//omrs
import org.odpi.openmetadata.fvt.opentypes.common.*;
import org.odpi.openmetadata.repositoryservices.ffdc.exception.*;
import org.odpi.openmetadata.repositoryservices.rest.properties.*;
import org.odpi.openmetadata.repositoryservices.archivemanager.opentypes.OpenMetadataTypesArchive;
import org.odpi.openmetadata.repositoryservices.archivemanager.OMRSArchiveAccessor;
import org.odpi.openmetadata.repositoryservices.connectors.stores.metadatacollectionstore.properties.typedefs.PrimitiveDefCategory;
import org.odpi.openmetadata.repositoryservices.connectors.stores.metadatacollectionstore.properties.typedefs.EntityDef;
import org.odpi.openmetadata.repositoryservices.connectors.stores.metadatacollectionstore.properties.typedefs.RelationshipDef;
import org.odpi.openmetadata.repositoryservices.connectors.stores.metadatacollectionstore.properties.instances.EntityDetail;
import org.odpi.openmetadata.repositoryservices.connectors.stores.metadatacollectionstore.properties.instances.InstanceProperties;
import org.odpi.openmetadata.repositoryservices.connectors.stores.metadatacollectionstore.properties.instances.Relationship;
import org.odpi.openmetadata.repositoryservices.connectors.stores.metadatacollectionstore.properties.SequencingOrder;

// omrs bean entity specific imports
import org.odpi.openmetadata.fvt.opentypes.entities.CertificationType.CertificationType;
import org.odpi.openmetadata.fvt.opentypes.entities.CertificationType.CertificationTypeReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.CertificationType.CertificationTypeMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.APISchemaType.APISchemaType;
import org.odpi.openmetadata.fvt.opentypes.entities.APISchemaType.APISchemaTypeReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.APISchemaType.APISchemaTypeMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.DataSet.DataSet;
import org.odpi.openmetadata.fvt.opentypes.entities.DataSet.DataSetReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.DataSet.DataSetMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.MapDocumentType.MapDocumentType;
import org.odpi.openmetadata.fvt.opentypes.entities.MapDocumentType.MapDocumentTypeReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.MapDocumentType.MapDocumentTypeMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernancePolicy.GovernancePolicy;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernancePolicy.GovernancePolicyReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernancePolicy.GovernancePolicyMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.MapSchemaType.MapSchemaType;
import org.odpi.openmetadata.fvt.opentypes.entities.MapSchemaType.MapSchemaTypeReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.MapSchemaType.MapSchemaTypeMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.DataProfileAnnotation.DataProfileAnnotation;
import org.odpi.openmetadata.fvt.opentypes.entities.DataProfileAnnotation.DataProfileAnnotationReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.DataProfileAnnotation.DataProfileAnnotationMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.Document.Document;
import org.odpi.openmetadata.fvt.opentypes.entities.Document.DocumentReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.Document.DocumentMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.DeployedSoftwareComponent.DeployedSoftwareComponent;
import org.odpi.openmetadata.fvt.opentypes.entities.DeployedSoftwareComponent.DeployedSoftwareComponentReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.DeployedSoftwareComponent.DeployedSoftwareComponentMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.DataFile.DataFile;
import org.odpi.openmetadata.fvt.opentypes.entities.DataFile.DataFileReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.DataFile.DataFileMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.DocumentStore.DocumentStore;
import org.odpi.openmetadata.fvt.opentypes.entities.DocumentStore.DocumentStoreReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.DocumentStore.DocumentStoreMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.Referenceable.Referenceable;
import org.odpi.openmetadata.fvt.opentypes.entities.Referenceable.ReferenceableReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.Referenceable.ReferenceableMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.ExternalReference.ExternalReference;
import org.odpi.openmetadata.fvt.opentypes.entities.ExternalReference.ExternalReferenceReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.ExternalReference.ExternalReferenceMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.Endpoint.Endpoint;
import org.odpi.openmetadata.fvt.opentypes.entities.Endpoint.EndpointReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.Endpoint.EndpointMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.ContactDetails.ContactDetails;
import org.odpi.openmetadata.fvt.opentypes.entities.ContactDetails.ContactDetailsReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.ContactDetails.ContactDetailsMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceDefinition.GovernanceDefinition;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceDefinition.GovernanceDefinitionReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceDefinition.GovernanceDefinitionMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.Network.Network;
import org.odpi.openmetadata.fvt.opentypes.entities.Network.NetworkReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.Network.NetworkMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.DataStore.DataStore;
import org.odpi.openmetadata.fvt.opentypes.entities.DataStore.DataStoreReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.DataStore.DataStoreMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.Database.Database;
import org.odpi.openmetadata.fvt.opentypes.entities.Database.DatabaseReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.Database.DatabaseMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.Asset.Asset;
import org.odpi.openmetadata.fvt.opentypes.entities.Asset.AssetReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.Asset.AssetMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.SetSchemaType.SetSchemaType;
import org.odpi.openmetadata.fvt.opentypes.entities.SetSchemaType.SetSchemaTypeReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.SetSchemaType.SetSchemaTypeMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.ObjectAttribute.ObjectAttribute;
import org.odpi.openmetadata.fvt.opentypes.entities.ObjectAttribute.ObjectAttributeReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.ObjectAttribute.ObjectAttributeMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceProcedure.GovernanceProcedure;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceProcedure.GovernanceProcedureReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceProcedure.GovernanceProcedureMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.SemanticAnnotation.SemanticAnnotation;
import org.odpi.openmetadata.fvt.opentypes.entities.SemanticAnnotation.SemanticAnnotationReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.SemanticAnnotation.SemanticAnnotationMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.AssetOwner.AssetOwner;
import org.odpi.openmetadata.fvt.opentypes.entities.AssetOwner.AssetOwnerReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.AssetOwner.AssetOwnerMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.NetworkGateway.NetworkGateway;
import org.odpi.openmetadata.fvt.opentypes.entities.NetworkGateway.NetworkGatewayReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.NetworkGateway.NetworkGatewayMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.ImplementationSnippet.ImplementationSnippet;
import org.odpi.openmetadata.fvt.opentypes.entities.ImplementationSnippet.ImplementationSnippetReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.ImplementationSnippet.ImplementationSnippetMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.RelationalTable.RelationalTable;
import org.odpi.openmetadata.fvt.opentypes.entities.RelationalTable.RelationalTableReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.RelationalTable.RelationalTableMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.UserIdentity.UserIdentity;
import org.odpi.openmetadata.fvt.opentypes.entities.UserIdentity.UserIdentityReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.UserIdentity.UserIdentityMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.ContributionRecord.ContributionRecord;
import org.odpi.openmetadata.fvt.opentypes.entities.ContributionRecord.ContributionRecordReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.ContributionRecord.ContributionRecordMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.StructDocumentType.StructDocumentType;
import org.odpi.openmetadata.fvt.opentypes.entities.StructDocumentType.StructDocumentTypeReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.StructDocumentType.StructDocumentTypeMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.RequestForAction.RequestForAction;
import org.odpi.openmetadata.fvt.opentypes.entities.RequestForAction.RequestForActionReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.RequestForAction.RequestForActionMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.Project.Project;
import org.odpi.openmetadata.fvt.opentypes.entities.Project.ProjectReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.Project.ProjectMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.DataField.DataField;
import org.odpi.openmetadata.fvt.opentypes.entities.DataField.DataFieldReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.DataField.DataFieldMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.HostCluster.HostCluster;
import org.odpi.openmetadata.fvt.opentypes.entities.HostCluster.HostClusterReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.HostCluster.HostClusterMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.GlossaryCategory.GlossaryCategory;
import org.odpi.openmetadata.fvt.opentypes.entities.GlossaryCategory.GlossaryCategoryReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.GlossaryCategory.GlossaryCategoryMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.NamingStandardRuleSet.NamingStandardRuleSet;
import org.odpi.openmetadata.fvt.opentypes.entities.NamingStandardRuleSet.NamingStandardRuleSetReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.NamingStandardRuleSet.NamingStandardRuleSetMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.TeamLeader.TeamLeader;
import org.odpi.openmetadata.fvt.opentypes.entities.TeamLeader.TeamLeaderReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.TeamLeader.TeamLeaderMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.RelationshipAdviceAnnotation.RelationshipAdviceAnnotation;
import org.odpi.openmetadata.fvt.opentypes.entities.RelationshipAdviceAnnotation.RelationshipAdviceAnnotationReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.RelationshipAdviceAnnotation.RelationshipAdviceAnnotationMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.InformalTag.InformalTag;
import org.odpi.openmetadata.fvt.opentypes.entities.InformalTag.InformalTagReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.InformalTag.InformalTagMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.CrowdSourcingContributor.CrowdSourcingContributor;
import org.odpi.openmetadata.fvt.opentypes.entities.CrowdSourcingContributor.CrowdSourcingContributorReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.CrowdSourcingContributor.CrowdSourcingContributorMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.Application.Application;
import org.odpi.openmetadata.fvt.opentypes.entities.Application.ApplicationReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.Application.ApplicationMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.Person.Person;
import org.odpi.openmetadata.fvt.opentypes.entities.Person.PersonReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.Person.PersonMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.VirtualContainer.VirtualContainer;
import org.odpi.openmetadata.fvt.opentypes.entities.VirtualContainer.VirtualContainerReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.VirtualContainer.VirtualContainerMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceObligation.GovernanceObligation;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceObligation.GovernanceObligationReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceObligation.GovernanceObligationMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceDriver.GovernanceDriver;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceDriver.GovernanceDriverReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceDriver.GovernanceDriverMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.Organization.Organization;
import org.odpi.openmetadata.fvt.opentypes.entities.Organization.OrganizationReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.Organization.OrganizationMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.Meeting.Meeting;
import org.odpi.openmetadata.fvt.opentypes.entities.Meeting.MeetingReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.Meeting.MeetingMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.SoftwareServerPlatform.SoftwareServerPlatform;
import org.odpi.openmetadata.fvt.opentypes.entities.SoftwareServerPlatform.SoftwareServerPlatformReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.SoftwareServerPlatform.SoftwareServerPlatformMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.OpenDiscoveryEngine.OpenDiscoveryEngine;
import org.odpi.openmetadata.fvt.opentypes.entities.OpenDiscoveryEngine.OpenDiscoveryEngineReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.OpenDiscoveryEngine.OpenDiscoveryEngineMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.DataFieldAnnotation.DataFieldAnnotation;
import org.odpi.openmetadata.fvt.opentypes.entities.DataFieldAnnotation.DataFieldAnnotationReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.DataFieldAnnotation.DataFieldAnnotationMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.DataProfileLogAnnotation.DataProfileLogAnnotation;
import org.odpi.openmetadata.fvt.opentypes.entities.DataProfileLogAnnotation.DataProfileLogAnnotationReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.DataProfileLogAnnotation.DataProfileLogAnnotationMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.NoteLogAuthor.NoteLogAuthor;
import org.odpi.openmetadata.fvt.opentypes.entities.NoteLogAuthor.NoteLogAuthorReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.NoteLogAuthor.NoteLogAuthorMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.LogFile.LogFile;
import org.odpi.openmetadata.fvt.opentypes.entities.LogFile.LogFileReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.LogFile.LogFileMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.MetadataRepository.MetadataRepository;
import org.odpi.openmetadata.fvt.opentypes.entities.MetadataRepository.MetadataRepositoryReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.MetadataRepository.MetadataRepositoryMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.KeystoreFile.KeystoreFile;
import org.odpi.openmetadata.fvt.opentypes.entities.KeystoreFile.KeystoreFileReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.KeystoreFile.KeystoreFileMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.DocumentSchemaType.DocumentSchemaType;
import org.odpi.openmetadata.fvt.opentypes.entities.DocumentSchemaType.DocumentSchemaTypeReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.DocumentSchemaType.DocumentSchemaTypeMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.Infrastructure.Infrastructure;
import org.odpi.openmetadata.fvt.opentypes.entities.Infrastructure.InfrastructureReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.Infrastructure.InfrastructureMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.Team.Team;
import org.odpi.openmetadata.fvt.opentypes.entities.Team.TeamReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.Team.TeamMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.SchemaElement.SchemaElement;
import org.odpi.openmetadata.fvt.opentypes.entities.SchemaElement.SchemaElementReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.SchemaElement.SchemaElementMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.DocumentSchemaAttribute.DocumentSchemaAttribute;
import org.odpi.openmetadata.fvt.opentypes.entities.DocumentSchemaAttribute.DocumentSchemaAttributeReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.DocumentSchemaAttribute.DocumentSchemaAttributeMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.RelationalColumn.RelationalColumn;
import org.odpi.openmetadata.fvt.opentypes.entities.RelationalColumn.RelationalColumnReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.RelationalColumn.RelationalColumnMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.SoftwareServer.SoftwareServer;
import org.odpi.openmetadata.fvt.opentypes.entities.SoftwareServer.SoftwareServerReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.SoftwareServer.SoftwareServerMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.MediaFile.MediaFile;
import org.odpi.openmetadata.fvt.opentypes.entities.MediaFile.MediaFileReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.MediaFile.MediaFileMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.RelatedMedia.RelatedMedia;
import org.odpi.openmetadata.fvt.opentypes.entities.RelatedMedia.RelatedMediaReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.RelatedMedia.RelatedMediaMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.ConnectorType.ConnectorType;
import org.odpi.openmetadata.fvt.opentypes.entities.ConnectorType.ConnectorTypeReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.ConnectorType.ConnectorTypeMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.EnterpriseAccessLayer.EnterpriseAccessLayer;
import org.odpi.openmetadata.fvt.opentypes.entities.EnterpriseAccessLayer.EnterpriseAccessLayerReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.EnterpriseAccessLayer.EnterpriseAccessLayerMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceMetric.GovernanceMetric;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceMetric.GovernanceMetricReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceMetric.GovernanceMetricMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.Connection.Connection;
import org.odpi.openmetadata.fvt.opentypes.entities.Connection.ConnectionReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.Connection.ConnectionMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.Annotation.Annotation;
import org.odpi.openmetadata.fvt.opentypes.entities.Annotation.AnnotationReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.Annotation.AnnotationMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceRule.GovernanceRule;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceRule.GovernanceRuleReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceRule.GovernanceRuleMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.GraphStore.GraphStore;
import org.odpi.openmetadata.fvt.opentypes.entities.GraphStore.GraphStoreReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.GraphStore.GraphStoreMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.MetadataRepositoryCohort.MetadataRepositoryCohort;
import org.odpi.openmetadata.fvt.opentypes.entities.MetadataRepositoryCohort.MetadataRepositoryCohortReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.MetadataRepositoryCohort.MetadataRepositoryCohortMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.ArrayDocumentType.ArrayDocumentType;
import org.odpi.openmetadata.fvt.opentypes.entities.ArrayDocumentType.ArrayDocumentTypeReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.ArrayDocumentType.ArrayDocumentTypeMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.OpenDiscoveryAnalysisReport.OpenDiscoveryAnalysisReport;
import org.odpi.openmetadata.fvt.opentypes.entities.OpenDiscoveryAnalysisReport.OpenDiscoveryAnalysisReportReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.OpenDiscoveryAnalysisReport.OpenDiscoveryAnalysisReportMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.VirtualConnection.VirtualConnection;
import org.odpi.openmetadata.fvt.opentypes.entities.VirtualConnection.VirtualConnectionReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.VirtualConnection.VirtualConnectionMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.TabularColumn.TabularColumn;
import org.odpi.openmetadata.fvt.opentypes.entities.TabularColumn.TabularColumnReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.TabularColumn.TabularColumnMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.DerivedRelationalColumn.DerivedRelationalColumn;
import org.odpi.openmetadata.fvt.opentypes.entities.DerivedRelationalColumn.DerivedRelationalColumnReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.DerivedRelationalColumn.DerivedRelationalColumnMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.SchemaAttribute.SchemaAttribute;
import org.odpi.openmetadata.fvt.opentypes.entities.SchemaAttribute.SchemaAttributeReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.SchemaAttribute.SchemaAttributeMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.GraphEdge.GraphEdge;
import org.odpi.openmetadata.fvt.opentypes.entities.GraphEdge.GraphEdgeReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.GraphEdge.GraphEdgeMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.BusinessCapability.BusinessCapability;
import org.odpi.openmetadata.fvt.opentypes.entities.BusinessCapability.BusinessCapabilityReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.BusinessCapability.BusinessCapabilityMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.CohortRegistryStore.CohortRegistryStore;
import org.odpi.openmetadata.fvt.opentypes.entities.CohortRegistryStore.CohortRegistryStoreReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.CohortRegistryStore.CohortRegistryStoreMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.EventType.EventType;
import org.odpi.openmetadata.fvt.opentypes.entities.EventType.EventTypeReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.EventType.EventTypeMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.OperatingPlatform.OperatingPlatform;
import org.odpi.openmetadata.fvt.opentypes.entities.OperatingPlatform.OperatingPlatformReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.OperatingPlatform.OperatingPlatformMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.Port.Port;
import org.odpi.openmetadata.fvt.opentypes.entities.Port.PortReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.Port.PortMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.DerivedSchemaAttribute.DerivedSchemaAttribute;
import org.odpi.openmetadata.fvt.opentypes.entities.DerivedSchemaAttribute.DerivedSchemaAttributeReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.DerivedSchemaAttribute.DerivedSchemaAttributeMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.DataClassAnnotation.DataClassAnnotation;
import org.odpi.openmetadata.fvt.opentypes.entities.DataClassAnnotation.DataClassAnnotationReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.DataClassAnnotation.DataClassAnnotationMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.RelationalTableType.RelationalTableType;
import org.odpi.openmetadata.fvt.opentypes.entities.RelationalTableType.RelationalTableTypeReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.RelationalTableType.RelationalTableTypeMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.Process.Process;
import org.odpi.openmetadata.fvt.opentypes.entities.Process.ProcessReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.Process.ProcessMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.SchemaType.SchemaType;
import org.odpi.openmetadata.fvt.opentypes.entities.SchemaType.SchemaTypeReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.SchemaType.SchemaTypeMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.OpenDiscoveryService.OpenDiscoveryService;
import org.odpi.openmetadata.fvt.opentypes.entities.OpenDiscoveryService.OpenDiscoveryServiceReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.OpenDiscoveryService.OpenDiscoveryServiceMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.Like.Like;
import org.odpi.openmetadata.fvt.opentypes.entities.Like.LikeReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.Like.LikeMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.TabularColumnType.TabularColumnType;
import org.odpi.openmetadata.fvt.opentypes.entities.TabularColumnType.TabularColumnTypeReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.TabularColumnType.TabularColumnTypeMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.FileFolder.FileFolder;
import org.odpi.openmetadata.fvt.opentypes.entities.FileFolder.FileFolderReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.FileFolder.FileFolderMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.StructSchemaType.StructSchemaType;
import org.odpi.openmetadata.fvt.opentypes.entities.StructSchemaType.StructSchemaTypeReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.StructSchemaType.StructSchemaTypeMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.BoundedSchemaType.BoundedSchemaType;
import org.odpi.openmetadata.fvt.opentypes.entities.BoundedSchemaType.BoundedSchemaTypeReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.BoundedSchemaType.BoundedSchemaTypeMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.ActorProfile.ActorProfile;
import org.odpi.openmetadata.fvt.opentypes.entities.ActorProfile.ActorProfileReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.ActorProfile.ActorProfileMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.ClassificationAnnotation.ClassificationAnnotation;
import org.odpi.openmetadata.fvt.opentypes.entities.ClassificationAnnotation.ClassificationAnnotationReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.ClassificationAnnotation.ClassificationAnnotationMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.ITInfrastructure.ITInfrastructure;
import org.odpi.openmetadata.fvt.opentypes.entities.ITInfrastructure.ITInfrastructureReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.ITInfrastructure.ITInfrastructureMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.APIOperation.APIOperation;
import org.odpi.openmetadata.fvt.opentypes.entities.APIOperation.APIOperationReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.APIOperation.APIOperationMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.Engine.Engine;
import org.odpi.openmetadata.fvt.opentypes.entities.Engine.EngineReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.Engine.EngineMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.ToDo.ToDo;
import org.odpi.openmetadata.fvt.opentypes.entities.ToDo.ToDoReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.ToDo.ToDoMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.KeyStoreCollection.KeyStoreCollection;
import org.odpi.openmetadata.fvt.opentypes.entities.KeyStoreCollection.KeyStoreCollectionReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.KeyStoreCollection.KeyStoreCollectionMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceResponsibility.GovernanceResponsibility;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceResponsibility.GovernanceResponsibilityReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceResponsibility.GovernanceResponsibilityMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.ReferenceCodeMappingTable.ReferenceCodeMappingTable;
import org.odpi.openmetadata.fvt.opentypes.entities.ReferenceCodeMappingTable.ReferenceCodeMappingTableReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.ReferenceCodeMappingTable.ReferenceCodeMappingTableMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.NoteEntry.NoteEntry;
import org.odpi.openmetadata.fvt.opentypes.entities.NoteEntry.NoteEntryReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.NoteEntry.NoteEntryMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernancePrinciple.GovernancePrinciple;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernancePrinciple.GovernancePrincipleReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernancePrinciple.GovernancePrincipleMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.SetDocumentType.SetDocumentType;
import org.odpi.openmetadata.fvt.opentypes.entities.SetDocumentType.SetDocumentTypeReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.SetDocumentType.SetDocumentTypeMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.ProjectManager.ProjectManager;
import org.odpi.openmetadata.fvt.opentypes.entities.ProjectManager.ProjectManagerReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.ProjectManager.ProjectManagerMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.DataSourceMeasurementAnnotation.DataSourceMeasurementAnnotation;
import org.odpi.openmetadata.fvt.opentypes.entities.DataSourceMeasurementAnnotation.DataSourceMeasurementAnnotationReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.DataSourceMeasurementAnnotation.DataSourceMeasurementAnnotationMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.PropertyFacet.PropertyFacet;
import org.odpi.openmetadata.fvt.opentypes.entities.PropertyFacet.PropertyFacetReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.PropertyFacet.PropertyFacetMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.ReferenceCodeTable.ReferenceCodeTable;
import org.odpi.openmetadata.fvt.opentypes.entities.ReferenceCodeTable.ReferenceCodeTableReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.ReferenceCodeTable.ReferenceCodeTableMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.TechnicalControl.TechnicalControl;
import org.odpi.openmetadata.fvt.opentypes.entities.TechnicalControl.TechnicalControlReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.TechnicalControl.TechnicalControlMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.GraphSchemaType.GraphSchemaType;
import org.odpi.openmetadata.fvt.opentypes.entities.GraphSchemaType.GraphSchemaTypeReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.GraphSchemaType.GraphSchemaTypeMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.Glossary.Glossary;
import org.odpi.openmetadata.fvt.opentypes.entities.Glossary.GlossaryReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.Glossary.GlossaryMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.SimpleDocumentType.SimpleDocumentType;
import org.odpi.openmetadata.fvt.opentypes.entities.SimpleDocumentType.SimpleDocumentTypeReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.SimpleDocumentType.SimpleDocumentTypeMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.AnnotationReview.AnnotationReview;
import org.odpi.openmetadata.fvt.opentypes.entities.AnnotationReview.AnnotationReviewReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.AnnotationReview.AnnotationReviewMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.MediaCollection.MediaCollection;
import org.odpi.openmetadata.fvt.opentypes.entities.MediaCollection.MediaCollectionReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.MediaCollection.MediaCollectionMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.Collection.Collection;
import org.odpi.openmetadata.fvt.opentypes.entities.Collection.CollectionReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.Collection.CollectionMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.TabularSchemaType.TabularSchemaType;
import org.odpi.openmetadata.fvt.opentypes.entities.TabularSchemaType.TabularSchemaTypeReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.TabularSchemaType.TabularSchemaTypeMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceZone.GovernanceZone;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceZone.GovernanceZoneReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceZone.GovernanceZoneMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.RelationalDBSchemaType.RelationalDBSchemaType;
import org.odpi.openmetadata.fvt.opentypes.entities.RelationalDBSchemaType.RelationalDBSchemaTypeReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.RelationalDBSchemaType.RelationalDBSchemaTypeMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceApproach.GovernanceApproach;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceApproach.GovernanceApproachReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceApproach.GovernanceApproachMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.ArraySchemaType.ArraySchemaType;
import org.odpi.openmetadata.fvt.opentypes.entities.ArraySchemaType.ArraySchemaTypeReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.ArraySchemaType.ArraySchemaTypeMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.Form.Form;
import org.odpi.openmetadata.fvt.opentypes.entities.Form.FormReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.Form.FormMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.Rating.Rating;
import org.odpi.openmetadata.fvt.opentypes.entities.Rating.RatingReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.Rating.RatingMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.PrimitiveSchemaType.PrimitiveSchemaType;
import org.odpi.openmetadata.fvt.opentypes.entities.PrimitiveSchemaType.PrimitiveSchemaTypeReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.PrimitiveSchemaType.PrimitiveSchemaTypeMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.ObjectSchemaType.ObjectSchemaType;
import org.odpi.openmetadata.fvt.opentypes.entities.ObjectSchemaType.ObjectSchemaTypeReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.ObjectSchemaType.ObjectSchemaTypeMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceStrategy.GovernanceStrategy;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceStrategy.GovernanceStrategyReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceStrategy.GovernanceStrategyMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.DeployedReport.DeployedReport;
import org.odpi.openmetadata.fvt.opentypes.entities.DeployedReport.DeployedReportReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.DeployedReport.DeployedReportMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.ProjectCharter.ProjectCharter;
import org.odpi.openmetadata.fvt.opentypes.entities.ProjectCharter.ProjectCharterReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.ProjectCharter.ProjectCharterMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceOfficer.GovernanceOfficer;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceOfficer.GovernanceOfficerReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceOfficer.GovernanceOfficerMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.SoftwareServerCapability.SoftwareServerCapability;
import org.odpi.openmetadata.fvt.opentypes.entities.SoftwareServerCapability.SoftwareServerCapabilityReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.SoftwareServerCapability.SoftwareServerCapabilityMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.PersonRole.PersonRole;
import org.odpi.openmetadata.fvt.opentypes.entities.PersonRole.PersonRoleReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.PersonRole.PersonRoleMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.LicenseType.LicenseType;
import org.odpi.openmetadata.fvt.opentypes.entities.LicenseType.LicenseTypeReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.LicenseType.LicenseTypeMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.SchemaAnalysisAnnotation.SchemaAnalysisAnnotation;
import org.odpi.openmetadata.fvt.opentypes.entities.SchemaAnalysisAnnotation.SchemaAnalysisAnnotationReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.SchemaAnalysisAnnotation.SchemaAnalysisAnnotationMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.ITProfile.ITProfile;
import org.odpi.openmetadata.fvt.opentypes.entities.ITProfile.ITProfileReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.ITProfile.ITProfileMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.GraphVertex.GraphVertex;
import org.odpi.openmetadata.fvt.opentypes.entities.GraphVertex.GraphVertexReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.GraphVertex.GraphVertexMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.DataSourcePhysicalStatusAnnotation.DataSourcePhysicalStatusAnnotation;
import org.odpi.openmetadata.fvt.opentypes.entities.DataSourcePhysicalStatusAnnotation.DataSourcePhysicalStatusAnnotationReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.DataSourcePhysicalStatusAnnotation.DataSourcePhysicalStatusAnnotationMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.GlossaryTerm.GlossaryTerm;
import org.odpi.openmetadata.fvt.opentypes.entities.GlossaryTerm.GlossaryTermReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.GlossaryTerm.GlossaryTermMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.MetadataCollection.MetadataCollection;
import org.odpi.openmetadata.fvt.opentypes.entities.MetadataCollection.MetadataCollectionReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.MetadataCollection.MetadataCollectionMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceControl.GovernanceControl;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceControl.GovernanceControlReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceControl.GovernanceControlMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.Topic.Topic;
import org.odpi.openmetadata.fvt.opentypes.entities.Topic.TopicReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.Topic.TopicMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.DeployedDatabaseSchema.DeployedDatabaseSchema;
import org.odpi.openmetadata.fvt.opentypes.entities.DeployedDatabaseSchema.DeployedDatabaseSchemaReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.DeployedDatabaseSchema.DeployedDatabaseSchemaMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.DeployedAPI.DeployedAPI;
import org.odpi.openmetadata.fvt.opentypes.entities.DeployedAPI.DeployedAPIReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.DeployedAPI.DeployedAPIMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.Comment.Comment;
import org.odpi.openmetadata.fvt.opentypes.entities.Comment.CommentReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.Comment.CommentMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.CohortMember.CohortMember;
import org.odpi.openmetadata.fvt.opentypes.entities.CohortMember.CohortMemberReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.CohortMember.CohortMemberMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.ComplexSchemaType.ComplexSchemaType;
import org.odpi.openmetadata.fvt.opentypes.entities.ComplexSchemaType.ComplexSchemaTypeReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.ComplexSchemaType.ComplexSchemaTypeMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.EventSet.EventSet;
import org.odpi.openmetadata.fvt.opentypes.entities.EventSet.EventSetReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.EventSet.EventSetMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.ExternalId.ExternalId;
import org.odpi.openmetadata.fvt.opentypes.entities.ExternalId.ExternalIdReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.ExternalId.ExternalIdMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.NamingStandardRule.NamingStandardRule;
import org.odpi.openmetadata.fvt.opentypes.entities.NamingStandardRule.NamingStandardRuleReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.NamingStandardRule.NamingStandardRuleMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceRole.GovernanceRole;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceRole.GovernanceRoleReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceRole.GovernanceRoleMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.Host.Host;
import org.odpi.openmetadata.fvt.opentypes.entities.Host.HostReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.Host.HostMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.InformationView.InformationView;
import org.odpi.openmetadata.fvt.opentypes.entities.InformationView.InformationViewReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.InformationView.InformationViewMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.OrganizationalControl.OrganizationalControl;
import org.odpi.openmetadata.fvt.opentypes.entities.OrganizationalControl.OrganizationalControlReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.OrganizationalControl.OrganizationalControlMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.SubscriberList.SubscriberList;
import org.odpi.openmetadata.fvt.opentypes.entities.SubscriberList.SubscriberListReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.SubscriberList.SubscriberListMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.TeamMember.TeamMember;
import org.odpi.openmetadata.fvt.opentypes.entities.TeamMember.TeamMemberReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.TeamMember.TeamMemberMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.CommunityMember.CommunityMember;
import org.odpi.openmetadata.fvt.opentypes.entities.CommunityMember.CommunityMemberReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.CommunityMember.CommunityMemberMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.OpenDiscoveryPipeline.OpenDiscoveryPipeline;
import org.odpi.openmetadata.fvt.opentypes.entities.OpenDiscoveryPipeline.OpenDiscoveryPipelineReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.OpenDiscoveryPipeline.OpenDiscoveryPipelineMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.NoteLog.NoteLog;
import org.odpi.openmetadata.fvt.opentypes.entities.NoteLog.NoteLogReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.NoteLog.NoteLogMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.ControlledGlossaryTerm.ControlledGlossaryTerm;
import org.odpi.openmetadata.fvt.opentypes.entities.ControlledGlossaryTerm.ControlledGlossaryTermReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.ControlledGlossaryTerm.ControlledGlossaryTermMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.RelationalColumnType.RelationalColumnType;
import org.odpi.openmetadata.fvt.opentypes.entities.RelationalColumnType.RelationalColumnTypeReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.RelationalColumnType.RelationalColumnTypeMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.ExternalGlossaryLink.ExternalGlossaryLink;
import org.odpi.openmetadata.fvt.opentypes.entities.ExternalGlossaryLink.ExternalGlossaryLinkReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.ExternalGlossaryLink.ExternalGlossaryLinkMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.DataClass.DataClass;
import org.odpi.openmetadata.fvt.opentypes.entities.DataClass.DataClassReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.DataClass.DataClassMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.Regulation.Regulation;
import org.odpi.openmetadata.fvt.opentypes.entities.Regulation.RegulationReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.Regulation.RegulationMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.QualityAnnotation.QualityAnnotation;
import org.odpi.openmetadata.fvt.opentypes.entities.QualityAnnotation.QualityAnnotationReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.QualityAnnotation.QualityAnnotationMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceProcess.GovernanceProcess;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceProcess.GovernanceProcessReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.GovernanceProcess.GovernanceProcessMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.Community.Community;
import org.odpi.openmetadata.fvt.opentypes.entities.Community.CommunityReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.Community.CommunityMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.Location.Location;
import org.odpi.openmetadata.fvt.opentypes.entities.Location.LocationReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.Location.LocationMapper;
import org.odpi.openmetadata.fvt.opentypes.entities.SchemaLinkElement.SchemaLinkElement;
import org.odpi.openmetadata.fvt.opentypes.entities.SchemaLinkElement.SchemaLinkElementReferences;
import org.odpi.openmetadata.fvt.opentypes.entities.SchemaLinkElement.SchemaLinkElementMapper;
// omrs bean relationships specific imports
import org.odpi.openmetadata.fvt.opentypes.relationships.OMRSRelationshipToLines;
import org.odpi.openmetadata.fvt.opentypes.relationships.UsedInContext.UsedInContext;
import org.odpi.openmetadata.fvt.opentypes.relationships.UsedInContext.UsedInContextMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.AttachedComment.AttachedComment;
import org.odpi.openmetadata.fvt.opentypes.relationships.AttachedComment.AttachedCommentMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.ContactThrough.ContactThrough;
import org.odpi.openmetadata.fvt.opentypes.relationships.ContactThrough.ContactThroughMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.License.License;
import org.odpi.openmetadata.fvt.opentypes.relationships.License.LicenseMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.ZoneGovernance.ZoneGovernance;
import org.odpi.openmetadata.fvt.opentypes.relationships.ZoneGovernance.ZoneGovernanceMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.ProcessPort.ProcessPort;
import org.odpi.openmetadata.fvt.opentypes.relationships.ProcessPort.ProcessPortMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.DataFieldAnalysis.DataFieldAnalysis;
import org.odpi.openmetadata.fvt.opentypes.relationships.DataFieldAnalysis.DataFieldAnalysisMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.DiscoveryServiceImplementation.DiscoveryServiceImplementation;
import org.odpi.openmetadata.fvt.opentypes.relationships.DiscoveryServiceImplementation.DiscoveryServiceImplementationMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.SoftwareServerPlatformDeployment.SoftwareServerPlatformDeployment;
import org.odpi.openmetadata.fvt.opentypes.relationships.SoftwareServerPlatformDeployment.SoftwareServerPlatformDeploymentMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.FolderHierarchy.FolderHierarchy;
import org.odpi.openmetadata.fvt.opentypes.relationships.FolderHierarchy.FolderHierarchyMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.HostClusterMember.HostClusterMember;
import org.odpi.openmetadata.fvt.opentypes.relationships.HostClusterMember.HostClusterMemberMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.AnnotationReviewLink.AnnotationReviewLink;
import org.odpi.openmetadata.fvt.opentypes.relationships.AnnotationReviewLink.AnnotationReviewLinkMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.LibraryCategoryReference.LibraryCategoryReference;
import org.odpi.openmetadata.fvt.opentypes.relationships.LibraryCategoryReference.LibraryCategoryReferenceMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.ProjectCharterLink.ProjectCharterLink;
import org.odpi.openmetadata.fvt.opentypes.relationships.ProjectCharterLink.ProjectCharterLinkMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.ProfileIdentity.ProfileIdentity;
import org.odpi.openmetadata.fvt.opentypes.relationships.ProfileIdentity.ProfileIdentityMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.ToDoSource.ToDoSource;
import org.odpi.openmetadata.fvt.opentypes.relationships.ToDoSource.ToDoSourceMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.DataClassComposition.DataClassComposition;
import org.odpi.openmetadata.fvt.opentypes.relationships.DataClassComposition.DataClassCompositionMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.Translation.Translation;
import org.odpi.openmetadata.fvt.opentypes.relationships.Translation.TranslationMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.SchemaLinkToType.SchemaLinkToType;
import org.odpi.openmetadata.fvt.opentypes.relationships.SchemaLinkToType.SchemaLinkToTypeMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.DiscoveredNestedDataField.DiscoveredNestedDataField;
import org.odpi.openmetadata.fvt.opentypes.relationships.DiscoveredNestedDataField.DiscoveredNestedDataFieldMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.TeamMembership.TeamMembership;
import org.odpi.openmetadata.fvt.opentypes.relationships.TeamMembership.TeamMembershipMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.Actions.Actions;
import org.odpi.openmetadata.fvt.opentypes.relationships.Actions.ActionsMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.PersonalContribution.PersonalContribution;
import org.odpi.openmetadata.fvt.opentypes.relationships.PersonalContribution.PersonalContributionMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.DataContentForDataSet.DataContentForDataSet;
import org.odpi.openmetadata.fvt.opentypes.relationships.DataContentForDataSet.DataContentForDataSetMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.TeamLeadership.TeamLeadership;
import org.odpi.openmetadata.fvt.opentypes.relationships.TeamLeadership.TeamLeadershipMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.BusinessCapabilityControls.BusinessCapabilityControls;
import org.odpi.openmetadata.fvt.opentypes.relationships.BusinessCapabilityControls.BusinessCapabilityControlsMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.ServerEndpoint.ServerEndpoint;
import org.odpi.openmetadata.fvt.opentypes.relationships.ServerEndpoint.ServerEndpointMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.DiscoveryInvocationReport.DiscoveryInvocationReport;
import org.odpi.openmetadata.fvt.opentypes.relationships.DiscoveryInvocationReport.DiscoveryInvocationReportMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.ExternalIdLink.ExternalIdLink;
import org.odpi.openmetadata.fvt.opentypes.relationships.ExternalIdLink.ExternalIdLinkMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.ResourceList.ResourceList;
import org.odpi.openmetadata.fvt.opentypes.relationships.ResourceList.ResourceListMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.CategoryHierarchyLink.CategoryHierarchyLink;
import org.odpi.openmetadata.fvt.opentypes.relationships.CategoryHierarchyLink.CategoryHierarchyLinkMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.PreferredTerm.PreferredTerm;
import org.odpi.openmetadata.fvt.opentypes.relationships.PreferredTerm.PreferredTermMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.ProjectHierarchy.ProjectHierarchy;
import org.odpi.openmetadata.fvt.opentypes.relationships.ProjectHierarchy.ProjectHierarchyMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.DeployedVirtualContainer.DeployedVirtualContainer;
import org.odpi.openmetadata.fvt.opentypes.relationships.DeployedVirtualContainer.DeployedVirtualContainerMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.AnnotationExtension.AnnotationExtension;
import org.odpi.openmetadata.fvt.opentypes.relationships.AnnotationExtension.AnnotationExtensionMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.DataClassHierarchy.DataClassHierarchy;
import org.odpi.openmetadata.fvt.opentypes.relationships.DataClassHierarchy.DataClassHierarchyMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.GovernanceResults.GovernanceResults;
import org.odpi.openmetadata.fvt.opentypes.relationships.GovernanceResults.GovernanceResultsMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.APIResponse.APIResponse;
import org.odpi.openmetadata.fvt.opentypes.relationships.APIResponse.APIResponseMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.SchemaAttributeDefinition.SchemaAttributeDefinition;
import org.odpi.openmetadata.fvt.opentypes.relationships.SchemaAttributeDefinition.SchemaAttributeDefinitionMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.HostNetwork.HostNetwork;
import org.odpi.openmetadata.fvt.opentypes.relationships.HostNetwork.HostNetworkMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.AttributeForSchema.AttributeForSchema;
import org.odpi.openmetadata.fvt.opentypes.relationships.AttributeForSchema.AttributeForSchemaMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.AssetLocation.AssetLocation;
import org.odpi.openmetadata.fvt.opentypes.relationships.AssetLocation.AssetLocationMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.ParentPort.ParentPort;
import org.odpi.openmetadata.fvt.opentypes.relationships.ParentPort.ParentPortMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.SoftwareServerSupportedCapability.SoftwareServerSupportedCapability;
import org.odpi.openmetadata.fvt.opentypes.relationships.SoftwareServerSupportedCapability.SoftwareServerSupportedCapabilityMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.DiscoveredAnnotation.DiscoveredAnnotation;
import org.odpi.openmetadata.fvt.opentypes.relationships.DiscoveredAnnotation.DiscoveredAnnotationMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.SchemaAttributeType.SchemaAttributeType;
import org.odpi.openmetadata.fvt.opentypes.relationships.SchemaAttributeType.SchemaAttributeTypeMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.GovernanceImplementation.GovernanceImplementation;
import org.odpi.openmetadata.fvt.opentypes.relationships.GovernanceImplementation.GovernanceImplementationMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.LinkedMedia.LinkedMedia;
import org.odpi.openmetadata.fvt.opentypes.relationships.LinkedMedia.LinkedMediaMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.MapToElementType.MapToElementType;
import org.odpi.openmetadata.fvt.opentypes.relationships.MapToElementType.MapToElementTypeMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.ExternallySourcedGlossary.ExternallySourcedGlossary;
import org.odpi.openmetadata.fvt.opentypes.relationships.ExternallySourcedGlossary.ExternallySourcedGlossaryMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.ExternalReferenceLink.ExternalReferenceLink;
import org.odpi.openmetadata.fvt.opentypes.relationships.ExternalReferenceLink.ExternalReferenceLinkMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.MediaReference.MediaReference;
import org.odpi.openmetadata.fvt.opentypes.relationships.MediaReference.MediaReferenceMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.CommunityMembership.CommunityMembership;
import org.odpi.openmetadata.fvt.opentypes.relationships.CommunityMembership.CommunityMembershipMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.ExternalIdScope.ExternalIdScope;
import org.odpi.openmetadata.fvt.opentypes.relationships.ExternalIdScope.ExternalIdScopeMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.ValidValue.ValidValue;
import org.odpi.openmetadata.fvt.opentypes.relationships.ValidValue.ValidValueMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.AcceptedAnswer.AcceptedAnswer;
import org.odpi.openmetadata.fvt.opentypes.relationships.AcceptedAnswer.AcceptedAnswerMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.GovernanceDefinitionMetric.GovernanceDefinitionMetric;
import org.odpi.openmetadata.fvt.opentypes.relationships.GovernanceDefinitionMetric.GovernanceDefinitionMetricMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.TeamStructure.TeamStructure;
import org.odpi.openmetadata.fvt.opentypes.relationships.TeamStructure.TeamStructureMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.SchemaQueryImplementation.SchemaQueryImplementation;
import org.odpi.openmetadata.fvt.opentypes.relationships.SchemaQueryImplementation.SchemaQueryImplementationMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.AssetSchemaType.AssetSchemaType;
import org.odpi.openmetadata.fvt.opentypes.relationships.AssetSchemaType.AssetSchemaTypeMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.ProjectDependency.ProjectDependency;
import org.odpi.openmetadata.fvt.opentypes.relationships.ProjectDependency.ProjectDependencyMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.TopicSubscribers.TopicSubscribers;
import org.odpi.openmetadata.fvt.opentypes.relationships.TopicSubscribers.TopicSubscribersMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.ReplacementTerm.ReplacementTerm;
import org.odpi.openmetadata.fvt.opentypes.relationships.ReplacementTerm.ReplacementTermMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.OrganizationalCapability.OrganizationalCapability;
import org.odpi.openmetadata.fvt.opentypes.relationships.OrganizationalCapability.OrganizationalCapabilityMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.MetadataCohortPeer.MetadataCohortPeer;
import org.odpi.openmetadata.fvt.opentypes.relationships.MetadataCohortPeer.MetadataCohortPeerMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.CollectionMembership.CollectionMembership;
import org.odpi.openmetadata.fvt.opentypes.relationships.CollectionMembership.CollectionMembershipMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.AttachedNoteLogEntry.AttachedNoteLogEntry;
import org.odpi.openmetadata.fvt.opentypes.relationships.AttachedNoteLogEntry.AttachedNoteLogEntryMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.AssetServerUse.AssetServerUse;
import org.odpi.openmetadata.fvt.opentypes.relationships.AssetServerUse.AssetServerUseMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.RuntimeForProcess.RuntimeForProcess;
import org.odpi.openmetadata.fvt.opentypes.relationships.RuntimeForProcess.RuntimeForProcessMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.SupportedDiscoveryService.SupportedDiscoveryService;
import org.odpi.openmetadata.fvt.opentypes.relationships.SupportedDiscoveryService.SupportedDiscoveryServiceMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.NestedLocation.NestedLocation;
import org.odpi.openmetadata.fvt.opentypes.relationships.NestedLocation.NestedLocationMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.LinkedFile.LinkedFile;
import org.odpi.openmetadata.fvt.opentypes.relationships.LinkedFile.LinkedFileMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.TermCategorization.TermCategorization;
import org.odpi.openmetadata.fvt.opentypes.relationships.TermCategorization.TermCategorizationMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.PortWire.PortWire;
import org.odpi.openmetadata.fvt.opentypes.relationships.PortWire.PortWireMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.APIEndpoint.APIEndpoint;
import org.odpi.openmetadata.fvt.opentypes.relationships.APIEndpoint.APIEndpointMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.ProjectManagement.ProjectManagement;
import org.odpi.openmetadata.fvt.opentypes.relationships.ProjectManagement.ProjectManagementMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.DataClassDefinition.DataClassDefinition;
import org.odpi.openmetadata.fvt.opentypes.relationships.DataClassDefinition.DataClassDefinitionMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.ConnectionEndpoint.ConnectionEndpoint;
import org.odpi.openmetadata.fvt.opentypes.relationships.ConnectionEndpoint.ConnectionEndpointMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.CategoryAnchor.CategoryAnchor;
import org.odpi.openmetadata.fvt.opentypes.relationships.CategoryAnchor.CategoryAnchorMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.ProjectTeam.ProjectTeam;
import org.odpi.openmetadata.fvt.opentypes.relationships.ProjectTeam.ProjectTeamMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.APIOperations.APIOperations;
import org.odpi.openmetadata.fvt.opentypes.relationships.APIOperations.APIOperationsMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.RelationshipAnnotation.RelationshipAnnotation;
import org.odpi.openmetadata.fvt.opentypes.relationships.RelationshipAnnotation.RelationshipAnnotationMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.GovernancePolicyLink.GovernancePolicyLink;
import org.odpi.openmetadata.fvt.opentypes.relationships.GovernancePolicyLink.GovernancePolicyLinkMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.ResponsibilityStaffContact.ResponsibilityStaffContact;
import org.odpi.openmetadata.fvt.opentypes.relationships.ResponsibilityStaffContact.ResponsibilityStaffContactMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.DiscoveredDataField.DiscoveredDataField;
import org.odpi.openmetadata.fvt.opentypes.relationships.DiscoveredDataField.DiscoveredDataFieldMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.PersonRoleAppointment.PersonRoleAppointment;
import org.odpi.openmetadata.fvt.opentypes.relationships.PersonRoleAppointment.PersonRoleAppointmentMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.AssetDiscoveryService.AssetDiscoveryService;
import org.odpi.openmetadata.fvt.opentypes.relationships.AssetDiscoveryService.AssetDiscoveryServiceMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.Peer.Peer;
import org.odpi.openmetadata.fvt.opentypes.relationships.Peer.PeerMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.ActionAssignment.ActionAssignment;
import org.odpi.openmetadata.fvt.opentypes.relationships.ActionAssignment.ActionAssignmentMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.TermTYPEDBYRelationship.TermTYPEDBYRelationship;
import org.odpi.openmetadata.fvt.opentypes.relationships.TermTYPEDBYRelationship.TermTYPEDBYRelationshipMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.MapFromElementType.MapFromElementType;
import org.odpi.openmetadata.fvt.opentypes.relationships.MapFromElementType.MapFromElementTypeMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.SchemaTypeDefinition.SchemaTypeDefinition;
import org.odpi.openmetadata.fvt.opentypes.relationships.SchemaTypeDefinition.SchemaTypeDefinitionMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.AssetWire.AssetWire;
import org.odpi.openmetadata.fvt.opentypes.relationships.AssetWire.AssetWireMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.Certification.Certification;
import org.odpi.openmetadata.fvt.opentypes.relationships.Certification.CertificationMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.GovernancePost.GovernancePost;
import org.odpi.openmetadata.fvt.opentypes.relationships.GovernancePost.GovernancePostMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.NetworkGatewayLink.NetworkGatewayLink;
import org.odpi.openmetadata.fvt.opentypes.relationships.NetworkGatewayLink.NetworkGatewayLinkMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.GovernanceResponsibilityAssignment.GovernanceResponsibilityAssignment;
import org.odpi.openmetadata.fvt.opentypes.relationships.GovernanceResponsibilityAssignment.GovernanceResponsibilityAssignmentMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.ConnectionConnectorType.ConnectionConnectorType;
import org.odpi.openmetadata.fvt.opentypes.relationships.ConnectionConnectorType.ConnectionConnectorTypeMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.Synonym.Synonym;
import org.odpi.openmetadata.fvt.opentypes.relationships.Synonym.SynonymMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.Antonym.Antonym;
import org.odpi.openmetadata.fvt.opentypes.relationships.Antonym.AntonymMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.GraphEdgeLink.GraphEdgeLink;
import org.odpi.openmetadata.fvt.opentypes.relationships.GraphEdgeLink.GraphEdgeLinkMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.ProjectScope.ProjectScope;
import org.odpi.openmetadata.fvt.opentypes.relationships.ProjectScope.ProjectScopeMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.ISARelationship.ISARelationship;
import org.odpi.openmetadata.fvt.opentypes.relationships.ISARelationship.ISARelationshipMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.TermISATypeOFRelationship.TermISATypeOFRelationship;
import org.odpi.openmetadata.fvt.opentypes.relationships.TermISATypeOFRelationship.TermISATypeOFRelationshipMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.Meetings.Meetings;
import org.odpi.openmetadata.fvt.opentypes.relationships.Meetings.MeetingsMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.EmbeddedConnection.EmbeddedConnection;
import org.odpi.openmetadata.fvt.opentypes.relationships.EmbeddedConnection.EmbeddedConnectionMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.GovernanceControlLink.GovernanceControlLink;
import org.odpi.openmetadata.fvt.opentypes.relationships.GovernanceControlLink.GovernanceControlLinkMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.AttachedRating.AttachedRating;
import org.odpi.openmetadata.fvt.opentypes.relationships.AttachedRating.AttachedRatingMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.DataClassAssignment.DataClassAssignment;
import org.odpi.openmetadata.fvt.opentypes.relationships.DataClassAssignment.DataClassAssignmentMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.AttachedNoteLog.AttachedNoteLog;
import org.odpi.openmetadata.fvt.opentypes.relationships.AttachedNoteLog.AttachedNoteLogMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.ConnectionToAsset.ConnectionToAsset;
import org.odpi.openmetadata.fvt.opentypes.relationships.ConnectionToAsset.ConnectionToAssetMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.RegulationCertificationType.RegulationCertificationType;
import org.odpi.openmetadata.fvt.opentypes.relationships.RegulationCertificationType.RegulationCertificationTypeMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.LinkedType.LinkedType;
import org.odpi.openmetadata.fvt.opentypes.relationships.LinkedType.LinkedTypeMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.CrowdSourcingContribution.CrowdSourcingContribution;
import org.odpi.openmetadata.fvt.opentypes.relationships.CrowdSourcingContribution.CrowdSourcingContributionMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.ProcessHierarchy.ProcessHierarchy;
import org.odpi.openmetadata.fvt.opentypes.relationships.ProcessHierarchy.ProcessHierarchyMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.GovernanceRuleImplementation.GovernanceRuleImplementation;
import org.odpi.openmetadata.fvt.opentypes.relationships.GovernanceRuleImplementation.GovernanceRuleImplementationMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.AdjacentLocation.AdjacentLocation;
import org.odpi.openmetadata.fvt.opentypes.relationships.AdjacentLocation.AdjacentLocationMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.SemanticAssignment.SemanticAssignment;
import org.odpi.openmetadata.fvt.opentypes.relationships.SemanticAssignment.SemanticAssignmentMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.HostLocation.HostLocation;
import org.odpi.openmetadata.fvt.opentypes.relationships.HostLocation.HostLocationMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.RelatedTerm.RelatedTerm;
import org.odpi.openmetadata.fvt.opentypes.relationships.RelatedTerm.RelatedTermMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.SchemaTypeImplementation.SchemaTypeImplementation;
import org.odpi.openmetadata.fvt.opentypes.relationships.SchemaTypeImplementation.SchemaTypeImplementationMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.APIHeader.APIHeader;
import org.odpi.openmetadata.fvt.opentypes.relationships.APIHeader.APIHeaderMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.LibraryTermReference.LibraryTermReference;
import org.odpi.openmetadata.fvt.opentypes.relationships.LibraryTermReference.LibraryTermReferenceMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.AttachedTag.AttachedTag;
import org.odpi.openmetadata.fvt.opentypes.relationships.AttachedTag.AttachedTagMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.TermHASARelationship.TermHASARelationship;
import org.odpi.openmetadata.fvt.opentypes.relationships.TermHASARelationship.TermHASARelationshipMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.GovernanceProcessImplementation.GovernanceProcessImplementation;
import org.odpi.openmetadata.fvt.opentypes.relationships.GovernanceProcessImplementation.GovernanceProcessImplementationMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.GroupedMedia.GroupedMedia;
import org.odpi.openmetadata.fvt.opentypes.relationships.GroupedMedia.GroupedMediaMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.GovernanceResponse.GovernanceResponse;
import org.odpi.openmetadata.fvt.opentypes.relationships.GovernanceResponse.GovernanceResponseMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.NestedFile.NestedFile;
import org.odpi.openmetadata.fvt.opentypes.relationships.NestedFile.NestedFileMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.PortInterface.PortInterface;
import org.odpi.openmetadata.fvt.opentypes.relationships.PortInterface.PortInterfaceMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.HostOperatingPlatform.HostOperatingPlatform;
import org.odpi.openmetadata.fvt.opentypes.relationships.HostOperatingPlatform.HostOperatingPlatformMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.TermAnchor.TermAnchor;
import org.odpi.openmetadata.fvt.opentypes.relationships.TermAnchor.TermAnchorMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.ForeignKey.ForeignKey;
import org.odpi.openmetadata.fvt.opentypes.relationships.ForeignKey.ForeignKeyMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.DataProfileLogFile.DataProfileLogFile;
import org.odpi.openmetadata.fvt.opentypes.relationships.DataProfileLogFile.DataProfileLogFileMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.DiscoveryEngineReport.DiscoveryEngineReport;
import org.odpi.openmetadata.fvt.opentypes.relationships.DiscoveryEngineReport.DiscoveryEngineReportMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.APIRequest.APIRequest;
import org.odpi.openmetadata.fvt.opentypes.relationships.APIRequest.APIRequestMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.SoftwareServerDeployment.SoftwareServerDeployment;
import org.odpi.openmetadata.fvt.opentypes.relationships.SoftwareServerDeployment.SoftwareServerDeploymentMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.GovernanceRoleAssignment.GovernanceRoleAssignment;
import org.odpi.openmetadata.fvt.opentypes.relationships.GovernanceRoleAssignment.GovernanceRoleAssignmentMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.CohortMemberMetadataCollection.CohortMemberMetadataCollection;
import org.odpi.openmetadata.fvt.opentypes.relationships.CohortMemberMetadataCollection.CohortMemberMetadataCollectionMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.ReferenceableFacet.ReferenceableFacet;
import org.odpi.openmetadata.fvt.opentypes.relationships.ReferenceableFacet.ReferenceableFacetMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.AssetDiscoveryReport.AssetDiscoveryReport;
import org.odpi.openmetadata.fvt.opentypes.relationships.AssetDiscoveryReport.AssetDiscoveryReportMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.AttachedLike.AttachedLike;
import org.odpi.openmetadata.fvt.opentypes.relationships.AttachedLike.AttachedLikeMapper;
import org.odpi.openmetadata.fvt.opentypes.relationships.NoteLogAuthorship.NoteLogAuthorship;
import org.odpi.openmetadata.fvt.opentypes.relationships.NoteLogAuthorship.NoteLogAuthorshipMapper;

/**
 * The OMRS API exposes concepts like Entities Relationships and ClassificationBeans, all of which have properties.
 * So the Subject Area OMAS can more easily consume this content, a subset of the OMRS content is exposed as java beans.
 * These java beans are accessed using this class.
 */

public class BeansToAccessOMRS  {

    private static final Logger log = LoggerFactory.getLogger(BeansToAccessOMRS.class);
    private static final String className = BeansToAccessOMRS.class.getName();

    // The OMRSAPIHelper allows the junits to mock out the omrs layer.
    private OMRSAPIHelper oMRSAPIHelper =new OMRSAPIHelper();

    public BeansToAccessOMRS() {
    }
    public void setOMRSAPIHelper(OMRSAPIHelper oMRSAPIHelper) {
        this.oMRSAPIHelper=oMRSAPIHelper;
    }

    /**
     * Fetch complete definition of an certificationType given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the certificationTypes relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return CertificationType the CertificationType entity with the requested GUID
     */
    public CertificationType getCertificationType(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getCertificationType";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        CertificationType gotcertificationType = CertificationTypeMapper.mapOmrsEntityDetailToCertificationType(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotcertificationType );
        }
        return gotcertificationType;

    }
    /**
     * Create new certificationType.
     * @param userId user identity
     * @param certificationType the input entity with values.
     * @return CertificationType the created entity.
     */

    public CertificationType createCertificationType(String userId,CertificationType certificationType)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createCertificationType";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = CertificationTypeMapper.mapCertificationTypeToOmrsEntityDetail(certificationType);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        CertificationType createdCertificationType =  CertificationTypeMapper.mapOmrsEntityDetailToCertificationType(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created CertificationType="+ createdCertificationType );
        }
        return createdCertificationType;
    }
    /**
     * Update certificationType
     * @param userId user identity
     * @param certificationType   certificationType to update
     * @return CertificationType the updated certificationType entity
     */
    public CertificationType updateCertificationType(String userId, CertificationType certificationType)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateCertificationType";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = CertificationTypeMapper.mapCertificationTypeToOmrsEntityDetail(certificationType);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            CertificationType updatedCertificationType =  CertificationTypeMapper.mapOmrsEntityDetailToCertificationType(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated CertificationType="+ updatedCertificationType );
            }
            return updatedCertificationType;
        }

    /**
     * Delete an certificationType identified by its GUID. Delete is a soft delete, this means that the certificationType has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the certificationType
     * @return CertificationType the deleted CertificationType entity
     */

    public CertificationType deleteCertificationType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteCertificationType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the CertificationType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("CertificationType");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"CertificationType",entityDef.getGUID(),entityGuid);
         CertificationType deletedCertificationType = CertificationTypeMapper.mapOmrsEntityDetailToCertificationType(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedCertificationType;

    }
    /**
     * Purge an certificationType identified by its GUID. Delete is a hard delete, this means that the certificationType is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the certificationType
     */
    public void purgeCertificationType(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeCertificationType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the CertificationType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("CertificationType");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"CertificationType",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an CertificationType identified by its GUID. Restore resurrects a soft deleted CertificationType. When a CertificationType was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the CertificationType
     * @return  CertificationType the restored CertificationType
     */
    public CertificationType restoreCertificationType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreCertificationType";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        CertificationType restoredCertificationType =  CertificationTypeMapper.mapOmrsEntityDetailToCertificationType(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredCertificationType;
    }    

    /**
     * Add classifications to the supplied certificationType
     * @param userId user identity
     * @param entityGuid the GUID value for certificationType
     * @param classifications the classifications to apply.
     * @return the certificationType entity that has been classified
     */
     public CertificationType addCertificationTypeClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addCertificationTypeClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         CertificationType certificationTypeClassificationBeans = CertificationTypeMapper.mapOmrsEntityDetailToCertificationType(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified CertificationType=" +  certificationTypeClassificationBeans);
         }
         return  certificationTypeClassificationBeans;
    }

    /**
     * Updates classifications to an existing certificationType represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the certificationType
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given certificationType guid
     */
    public CertificationType updateCertificationTypeClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateCertificationTypeClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           CertificationType  certificationTypeClassificationBeans = CertificationTypeMapper.mapOmrsEntityDetailToCertificationType(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  certificationTypeClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing certificationType represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the certificationType
     * @param name name of the classification
     * @return deleted CertificationType  classification
     */
    public CertificationType deleteCertificationTypeClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteCertificationTypeClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       CertificationType declassifiedCertificationType =  CertificationTypeMapper.mapOmrsEntityDetailToCertificationType(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedCertificationType;
    }

    /**
      * Get the relationships associated with entity certificationType represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the certificationType
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getCertificationTypeRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getCertificationTypeRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an aPISchemaType given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the aPISchemaTypes relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return APISchemaType the APISchemaType entity with the requested GUID
     */
    public APISchemaType getAPISchemaType(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getAPISchemaType";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        APISchemaType gotaPISchemaType = APISchemaTypeMapper.mapOmrsEntityDetailToAPISchemaType(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotaPISchemaType );
        }
        return gotaPISchemaType;

    }
    /**
     * Create new aPISchemaType.
     * @param userId user identity
     * @param aPISchemaType the input entity with values.
     * @return APISchemaType the created entity.
     */

    public APISchemaType createAPISchemaType(String userId,APISchemaType aPISchemaType)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createAPISchemaType";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = APISchemaTypeMapper.mapAPISchemaTypeToOmrsEntityDetail(aPISchemaType);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        APISchemaType createdAPISchemaType =  APISchemaTypeMapper.mapOmrsEntityDetailToAPISchemaType(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created APISchemaType="+ createdAPISchemaType );
        }
        return createdAPISchemaType;
    }
    /**
     * Update aPISchemaType
     * @param userId user identity
     * @param aPISchemaType   aPISchemaType to update
     * @return APISchemaType the updated aPISchemaType entity
     */
    public APISchemaType updateAPISchemaType(String userId, APISchemaType aPISchemaType)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateAPISchemaType";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = APISchemaTypeMapper.mapAPISchemaTypeToOmrsEntityDetail(aPISchemaType);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            APISchemaType updatedAPISchemaType =  APISchemaTypeMapper.mapOmrsEntityDetailToAPISchemaType(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated APISchemaType="+ updatedAPISchemaType );
            }
            return updatedAPISchemaType;
        }

    /**
     * Delete an aPISchemaType identified by its GUID. Delete is a soft delete, this means that the aPISchemaType has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the aPISchemaType
     * @return APISchemaType the deleted APISchemaType entity
     */

    public APISchemaType deleteAPISchemaType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteAPISchemaType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the APISchemaType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("APISchemaType");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"APISchemaType",entityDef.getGUID(),entityGuid);
         APISchemaType deletedAPISchemaType = APISchemaTypeMapper.mapOmrsEntityDetailToAPISchemaType(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedAPISchemaType;

    }
    /**
     * Purge an aPISchemaType identified by its GUID. Delete is a hard delete, this means that the aPISchemaType is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the aPISchemaType
     */
    public void purgeAPISchemaType(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeAPISchemaType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the APISchemaType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("APISchemaType");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"APISchemaType",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an APISchemaType identified by its GUID. Restore resurrects a soft deleted APISchemaType. When a APISchemaType was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the APISchemaType
     * @return  APISchemaType the restored APISchemaType
     */
    public APISchemaType restoreAPISchemaType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreAPISchemaType";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        APISchemaType restoredAPISchemaType =  APISchemaTypeMapper.mapOmrsEntityDetailToAPISchemaType(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredAPISchemaType;
    }    

    /**
     * Add classifications to the supplied aPISchemaType
     * @param userId user identity
     * @param entityGuid the GUID value for aPISchemaType
     * @param classifications the classifications to apply.
     * @return the aPISchemaType entity that has been classified
     */
     public APISchemaType addAPISchemaTypeClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addAPISchemaTypeClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         APISchemaType aPISchemaTypeClassificationBeans = APISchemaTypeMapper.mapOmrsEntityDetailToAPISchemaType(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified APISchemaType=" +  aPISchemaTypeClassificationBeans);
         }
         return  aPISchemaTypeClassificationBeans;
    }

    /**
     * Updates classifications to an existing aPISchemaType represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the aPISchemaType
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given aPISchemaType guid
     */
    public APISchemaType updateAPISchemaTypeClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateAPISchemaTypeClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           APISchemaType  aPISchemaTypeClassificationBeans = APISchemaTypeMapper.mapOmrsEntityDetailToAPISchemaType(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  aPISchemaTypeClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing aPISchemaType represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the aPISchemaType
     * @param name name of the classification
     * @return deleted APISchemaType  classification
     */
    public APISchemaType deleteAPISchemaTypeClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteAPISchemaTypeClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       APISchemaType declassifiedAPISchemaType =  APISchemaTypeMapper.mapOmrsEntityDetailToAPISchemaType(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedAPISchemaType;
    }

    /**
      * Get the relationships associated with entity aPISchemaType represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the aPISchemaType
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getAPISchemaTypeRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getAPISchemaTypeRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an dataSet given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the dataSets relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return DataSet the DataSet entity with the requested GUID
     */
    public DataSet getDataSet(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getDataSet";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        DataSet gotdataSet = DataSetMapper.mapOmrsEntityDetailToDataSet(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotdataSet );
        }
        return gotdataSet;

    }
    /**
     * Create new dataSet.
     * @param userId user identity
     * @param dataSet the input entity with values.
     * @return DataSet the created entity.
     */

    public DataSet createDataSet(String userId,DataSet dataSet)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createDataSet";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = DataSetMapper.mapDataSetToOmrsEntityDetail(dataSet);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        DataSet createdDataSet =  DataSetMapper.mapOmrsEntityDetailToDataSet(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created DataSet="+ createdDataSet );
        }
        return createdDataSet;
    }
    /**
     * Update dataSet
     * @param userId user identity
     * @param dataSet   dataSet to update
     * @return DataSet the updated dataSet entity
     */
    public DataSet updateDataSet(String userId, DataSet dataSet)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateDataSet";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = DataSetMapper.mapDataSetToOmrsEntityDetail(dataSet);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            DataSet updatedDataSet =  DataSetMapper.mapOmrsEntityDetailToDataSet(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated DataSet="+ updatedDataSet );
            }
            return updatedDataSet;
        }

    /**
     * Delete an dataSet identified by its GUID. Delete is a soft delete, this means that the dataSet has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the dataSet
     * @return DataSet the deleted DataSet entity
     */

    public DataSet deleteDataSet(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteDataSet";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DataSet type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DataSet");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"DataSet",entityDef.getGUID(),entityGuid);
         DataSet deletedDataSet = DataSetMapper.mapOmrsEntityDetailToDataSet(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedDataSet;

    }
    /**
     * Purge an dataSet identified by its GUID. Delete is a hard delete, this means that the dataSet is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the dataSet
     */
    public void purgeDataSet(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeDataSet";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DataSet type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DataSet");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"DataSet",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an DataSet identified by its GUID. Restore resurrects a soft deleted DataSet. When a DataSet was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the DataSet
     * @return  DataSet the restored DataSet
     */
    public DataSet restoreDataSet(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreDataSet";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        DataSet restoredDataSet =  DataSetMapper.mapOmrsEntityDetailToDataSet(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredDataSet;
    }    

    /**
     * Add classifications to the supplied dataSet
     * @param userId user identity
     * @param entityGuid the GUID value for dataSet
     * @param classifications the classifications to apply.
     * @return the dataSet entity that has been classified
     */
     public DataSet addDataSetClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addDataSetClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         DataSet dataSetClassificationBeans = DataSetMapper.mapOmrsEntityDetailToDataSet(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified DataSet=" +  dataSetClassificationBeans);
         }
         return  dataSetClassificationBeans;
    }

    /**
     * Updates classifications to an existing dataSet represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the dataSet
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given dataSet guid
     */
    public DataSet updateDataSetClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateDataSetClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           DataSet  dataSetClassificationBeans = DataSetMapper.mapOmrsEntityDetailToDataSet(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  dataSetClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing dataSet represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the dataSet
     * @param name name of the classification
     * @return deleted DataSet  classification
     */
    public DataSet deleteDataSetClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteDataSetClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       DataSet declassifiedDataSet =  DataSetMapper.mapOmrsEntityDetailToDataSet(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedDataSet;
    }

    /**
      * Get the relationships associated with entity dataSet represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the dataSet
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getDataSetRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getDataSetRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an mapDocumentType given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the mapDocumentTypes relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return MapDocumentType the MapDocumentType entity with the requested GUID
     */
    public MapDocumentType getMapDocumentType(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getMapDocumentType";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        MapDocumentType gotmapDocumentType = MapDocumentTypeMapper.mapOmrsEntityDetailToMapDocumentType(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotmapDocumentType );
        }
        return gotmapDocumentType;

    }
    /**
     * Create new mapDocumentType.
     * @param userId user identity
     * @param mapDocumentType the input entity with values.
     * @return MapDocumentType the created entity.
     */

    public MapDocumentType createMapDocumentType(String userId,MapDocumentType mapDocumentType)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createMapDocumentType";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = MapDocumentTypeMapper.mapMapDocumentTypeToOmrsEntityDetail(mapDocumentType);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        MapDocumentType createdMapDocumentType =  MapDocumentTypeMapper.mapOmrsEntityDetailToMapDocumentType(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created MapDocumentType="+ createdMapDocumentType );
        }
        return createdMapDocumentType;
    }
    /**
     * Update mapDocumentType
     * @param userId user identity
     * @param mapDocumentType   mapDocumentType to update
     * @return MapDocumentType the updated mapDocumentType entity
     */
    public MapDocumentType updateMapDocumentType(String userId, MapDocumentType mapDocumentType)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateMapDocumentType";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = MapDocumentTypeMapper.mapMapDocumentTypeToOmrsEntityDetail(mapDocumentType);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            MapDocumentType updatedMapDocumentType =  MapDocumentTypeMapper.mapOmrsEntityDetailToMapDocumentType(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated MapDocumentType="+ updatedMapDocumentType );
            }
            return updatedMapDocumentType;
        }

    /**
     * Delete an mapDocumentType identified by its GUID. Delete is a soft delete, this means that the mapDocumentType has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the mapDocumentType
     * @return MapDocumentType the deleted MapDocumentType entity
     */

    public MapDocumentType deleteMapDocumentType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteMapDocumentType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the MapDocumentType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("MapDocumentType");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"MapDocumentType",entityDef.getGUID(),entityGuid);
         MapDocumentType deletedMapDocumentType = MapDocumentTypeMapper.mapOmrsEntityDetailToMapDocumentType(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedMapDocumentType;

    }
    /**
     * Purge an mapDocumentType identified by its GUID. Delete is a hard delete, this means that the mapDocumentType is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the mapDocumentType
     */
    public void purgeMapDocumentType(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeMapDocumentType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the MapDocumentType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("MapDocumentType");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"MapDocumentType",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an MapDocumentType identified by its GUID. Restore resurrects a soft deleted MapDocumentType. When a MapDocumentType was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the MapDocumentType
     * @return  MapDocumentType the restored MapDocumentType
     */
    public MapDocumentType restoreMapDocumentType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreMapDocumentType";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        MapDocumentType restoredMapDocumentType =  MapDocumentTypeMapper.mapOmrsEntityDetailToMapDocumentType(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredMapDocumentType;
    }    

    /**
     * Add classifications to the supplied mapDocumentType
     * @param userId user identity
     * @param entityGuid the GUID value for mapDocumentType
     * @param classifications the classifications to apply.
     * @return the mapDocumentType entity that has been classified
     */
     public MapDocumentType addMapDocumentTypeClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addMapDocumentTypeClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         MapDocumentType mapDocumentTypeClassificationBeans = MapDocumentTypeMapper.mapOmrsEntityDetailToMapDocumentType(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified MapDocumentType=" +  mapDocumentTypeClassificationBeans);
         }
         return  mapDocumentTypeClassificationBeans;
    }

    /**
     * Updates classifications to an existing mapDocumentType represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the mapDocumentType
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given mapDocumentType guid
     */
    public MapDocumentType updateMapDocumentTypeClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateMapDocumentTypeClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           MapDocumentType  mapDocumentTypeClassificationBeans = MapDocumentTypeMapper.mapOmrsEntityDetailToMapDocumentType(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  mapDocumentTypeClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing mapDocumentType represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the mapDocumentType
     * @param name name of the classification
     * @return deleted MapDocumentType  classification
     */
    public MapDocumentType deleteMapDocumentTypeClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteMapDocumentTypeClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       MapDocumentType declassifiedMapDocumentType =  MapDocumentTypeMapper.mapOmrsEntityDetailToMapDocumentType(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedMapDocumentType;
    }

    /**
      * Get the relationships associated with entity mapDocumentType represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the mapDocumentType
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getMapDocumentTypeRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getMapDocumentTypeRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an governancePolicy given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the governancePolicies relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return GovernancePolicy the GovernancePolicy entity with the requested GUID
     */
    public GovernancePolicy getGovernancePolicy(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getGovernancePolicy";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        GovernancePolicy gotgovernancePolicy = GovernancePolicyMapper.mapOmrsEntityDetailToGovernancePolicy(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotgovernancePolicy );
        }
        return gotgovernancePolicy;

    }
    /**
     * Create new governancePolicy.
     * @param userId user identity
     * @param governancePolicy the input entity with values.
     * @return GovernancePolicy the created entity.
     */

    public GovernancePolicy createGovernancePolicy(String userId,GovernancePolicy governancePolicy)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createGovernancePolicy";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = GovernancePolicyMapper.mapGovernancePolicyToOmrsEntityDetail(governancePolicy);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        GovernancePolicy createdGovernancePolicy =  GovernancePolicyMapper.mapOmrsEntityDetailToGovernancePolicy(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created GovernancePolicy="+ createdGovernancePolicy );
        }
        return createdGovernancePolicy;
    }
    /**
     * Update governancePolicy
     * @param userId user identity
     * @param governancePolicy   governancePolicy to update
     * @return GovernancePolicy the updated governancePolicy entity
     */
    public GovernancePolicy updateGovernancePolicy(String userId, GovernancePolicy governancePolicy)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateGovernancePolicy";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = GovernancePolicyMapper.mapGovernancePolicyToOmrsEntityDetail(governancePolicy);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            GovernancePolicy updatedGovernancePolicy =  GovernancePolicyMapper.mapOmrsEntityDetailToGovernancePolicy(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated GovernancePolicy="+ updatedGovernancePolicy );
            }
            return updatedGovernancePolicy;
        }

    /**
     * Delete an governancePolicy identified by its GUID. Delete is a soft delete, this means that the governancePolicy has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the governancePolicy
     * @return GovernancePolicy the deleted GovernancePolicy entity
     */

    public GovernancePolicy deleteGovernancePolicy(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteGovernancePolicy";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GovernancePolicy type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GovernancePolicy");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"GovernancePolicy",entityDef.getGUID(),entityGuid);
         GovernancePolicy deletedGovernancePolicy = GovernancePolicyMapper.mapOmrsEntityDetailToGovernancePolicy(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedGovernancePolicy;

    }
    /**
     * Purge an governancePolicy identified by its GUID. Delete is a hard delete, this means that the governancePolicy is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the governancePolicy
     */
    public void purgeGovernancePolicy(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeGovernancePolicy";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GovernancePolicy type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GovernancePolicy");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"GovernancePolicy",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an GovernancePolicy identified by its GUID. Restore resurrects a soft deleted GovernancePolicy. When a GovernancePolicy was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the GovernancePolicy
     * @return  GovernancePolicy the restored GovernancePolicy
     */
    public GovernancePolicy restoreGovernancePolicy(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreGovernancePolicy";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        GovernancePolicy restoredGovernancePolicy =  GovernancePolicyMapper.mapOmrsEntityDetailToGovernancePolicy(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredGovernancePolicy;
    }    

    /**
     * Add classifications to the supplied governancePolicy
     * @param userId user identity
     * @param entityGuid the GUID value for governancePolicy
     * @param classifications the classifications to apply.
     * @return the governancePolicy entity that has been classified
     */
     public GovernancePolicy addGovernancePolicyClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addGovernancePolicyClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         GovernancePolicy governancePolicyClassificationBeans = GovernancePolicyMapper.mapOmrsEntityDetailToGovernancePolicy(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified GovernancePolicy=" +  governancePolicyClassificationBeans);
         }
         return  governancePolicyClassificationBeans;
    }

    /**
     * Updates classifications to an existing governancePolicy represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the governancePolicy
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given governancePolicy guid
     */
    public GovernancePolicy updateGovernancePolicyClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateGovernancePolicyClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           GovernancePolicy  governancePolicyClassificationBeans = GovernancePolicyMapper.mapOmrsEntityDetailToGovernancePolicy(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  governancePolicyClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing governancePolicy represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the governancePolicy
     * @param name name of the classification
     * @return deleted GovernancePolicy  classification
     */
    public GovernancePolicy deleteGovernancePolicyClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteGovernancePolicyClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       GovernancePolicy declassifiedGovernancePolicy =  GovernancePolicyMapper.mapOmrsEntityDetailToGovernancePolicy(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedGovernancePolicy;
    }

    /**
      * Get the relationships associated with entity governancePolicy represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the governancePolicy
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getGovernancePolicyRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getGovernancePolicyRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an mapSchemaType given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the mapSchemaTypes relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return MapSchemaType the MapSchemaType entity with the requested GUID
     */
    public MapSchemaType getMapSchemaType(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getMapSchemaType";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        MapSchemaType gotmapSchemaType = MapSchemaTypeMapper.mapOmrsEntityDetailToMapSchemaType(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotmapSchemaType );
        }
        return gotmapSchemaType;

    }
    /**
     * Create new mapSchemaType.
     * @param userId user identity
     * @param mapSchemaType the input entity with values.
     * @return MapSchemaType the created entity.
     */

    public MapSchemaType createMapSchemaType(String userId,MapSchemaType mapSchemaType)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createMapSchemaType";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = MapSchemaTypeMapper.mapMapSchemaTypeToOmrsEntityDetail(mapSchemaType);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        MapSchemaType createdMapSchemaType =  MapSchemaTypeMapper.mapOmrsEntityDetailToMapSchemaType(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created MapSchemaType="+ createdMapSchemaType );
        }
        return createdMapSchemaType;
    }
    /**
     * Update mapSchemaType
     * @param userId user identity
     * @param mapSchemaType   mapSchemaType to update
     * @return MapSchemaType the updated mapSchemaType entity
     */
    public MapSchemaType updateMapSchemaType(String userId, MapSchemaType mapSchemaType)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateMapSchemaType";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = MapSchemaTypeMapper.mapMapSchemaTypeToOmrsEntityDetail(mapSchemaType);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            MapSchemaType updatedMapSchemaType =  MapSchemaTypeMapper.mapOmrsEntityDetailToMapSchemaType(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated MapSchemaType="+ updatedMapSchemaType );
            }
            return updatedMapSchemaType;
        }

    /**
     * Delete an mapSchemaType identified by its GUID. Delete is a soft delete, this means that the mapSchemaType has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the mapSchemaType
     * @return MapSchemaType the deleted MapSchemaType entity
     */

    public MapSchemaType deleteMapSchemaType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteMapSchemaType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the MapSchemaType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("MapSchemaType");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"MapSchemaType",entityDef.getGUID(),entityGuid);
         MapSchemaType deletedMapSchemaType = MapSchemaTypeMapper.mapOmrsEntityDetailToMapSchemaType(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedMapSchemaType;

    }
    /**
     * Purge an mapSchemaType identified by its GUID. Delete is a hard delete, this means that the mapSchemaType is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the mapSchemaType
     */
    public void purgeMapSchemaType(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeMapSchemaType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the MapSchemaType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("MapSchemaType");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"MapSchemaType",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an MapSchemaType identified by its GUID. Restore resurrects a soft deleted MapSchemaType. When a MapSchemaType was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the MapSchemaType
     * @return  MapSchemaType the restored MapSchemaType
     */
    public MapSchemaType restoreMapSchemaType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreMapSchemaType";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        MapSchemaType restoredMapSchemaType =  MapSchemaTypeMapper.mapOmrsEntityDetailToMapSchemaType(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredMapSchemaType;
    }    

    /**
     * Add classifications to the supplied mapSchemaType
     * @param userId user identity
     * @param entityGuid the GUID value for mapSchemaType
     * @param classifications the classifications to apply.
     * @return the mapSchemaType entity that has been classified
     */
     public MapSchemaType addMapSchemaTypeClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addMapSchemaTypeClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         MapSchemaType mapSchemaTypeClassificationBeans = MapSchemaTypeMapper.mapOmrsEntityDetailToMapSchemaType(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified MapSchemaType=" +  mapSchemaTypeClassificationBeans);
         }
         return  mapSchemaTypeClassificationBeans;
    }

    /**
     * Updates classifications to an existing mapSchemaType represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the mapSchemaType
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given mapSchemaType guid
     */
    public MapSchemaType updateMapSchemaTypeClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateMapSchemaTypeClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           MapSchemaType  mapSchemaTypeClassificationBeans = MapSchemaTypeMapper.mapOmrsEntityDetailToMapSchemaType(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  mapSchemaTypeClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing mapSchemaType represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the mapSchemaType
     * @param name name of the classification
     * @return deleted MapSchemaType  classification
     */
    public MapSchemaType deleteMapSchemaTypeClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteMapSchemaTypeClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       MapSchemaType declassifiedMapSchemaType =  MapSchemaTypeMapper.mapOmrsEntityDetailToMapSchemaType(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedMapSchemaType;
    }

    /**
      * Get the relationships associated with entity mapSchemaType represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the mapSchemaType
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getMapSchemaTypeRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getMapSchemaTypeRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an dataProfileAnnotation given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the dataProfileAnnotations relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return DataProfileAnnotation the DataProfileAnnotation entity with the requested GUID
     */
    public DataProfileAnnotation getDataProfileAnnotation(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getDataProfileAnnotation";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        DataProfileAnnotation gotdataProfileAnnotation = DataProfileAnnotationMapper.mapOmrsEntityDetailToDataProfileAnnotation(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotdataProfileAnnotation );
        }
        return gotdataProfileAnnotation;

    }
    /**
     * Create new dataProfileAnnotation.
     * @param userId user identity
     * @param dataProfileAnnotation the input entity with values.
     * @return DataProfileAnnotation the created entity.
     */

    public DataProfileAnnotation createDataProfileAnnotation(String userId,DataProfileAnnotation dataProfileAnnotation)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createDataProfileAnnotation";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = DataProfileAnnotationMapper.mapDataProfileAnnotationToOmrsEntityDetail(dataProfileAnnotation);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        DataProfileAnnotation createdDataProfileAnnotation =  DataProfileAnnotationMapper.mapOmrsEntityDetailToDataProfileAnnotation(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created DataProfileAnnotation="+ createdDataProfileAnnotation );
        }
        return createdDataProfileAnnotation;
    }
    /**
     * Update dataProfileAnnotation
     * @param userId user identity
     * @param dataProfileAnnotation   dataProfileAnnotation to update
     * @return DataProfileAnnotation the updated dataProfileAnnotation entity
     */
    public DataProfileAnnotation updateDataProfileAnnotation(String userId, DataProfileAnnotation dataProfileAnnotation)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateDataProfileAnnotation";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = DataProfileAnnotationMapper.mapDataProfileAnnotationToOmrsEntityDetail(dataProfileAnnotation);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            DataProfileAnnotation updatedDataProfileAnnotation =  DataProfileAnnotationMapper.mapOmrsEntityDetailToDataProfileAnnotation(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated DataProfileAnnotation="+ updatedDataProfileAnnotation );
            }
            return updatedDataProfileAnnotation;
        }

    /**
     * Delete an dataProfileAnnotation identified by its GUID. Delete is a soft delete, this means that the dataProfileAnnotation has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the dataProfileAnnotation
     * @return DataProfileAnnotation the deleted DataProfileAnnotation entity
     */

    public DataProfileAnnotation deleteDataProfileAnnotation(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteDataProfileAnnotation";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DataProfileAnnotation type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DataProfileAnnotation");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"DataProfileAnnotation",entityDef.getGUID(),entityGuid);
         DataProfileAnnotation deletedDataProfileAnnotation = DataProfileAnnotationMapper.mapOmrsEntityDetailToDataProfileAnnotation(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedDataProfileAnnotation;

    }
    /**
     * Purge an dataProfileAnnotation identified by its GUID. Delete is a hard delete, this means that the dataProfileAnnotation is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the dataProfileAnnotation
     */
    public void purgeDataProfileAnnotation(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeDataProfileAnnotation";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DataProfileAnnotation type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DataProfileAnnotation");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"DataProfileAnnotation",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an DataProfileAnnotation identified by its GUID. Restore resurrects a soft deleted DataProfileAnnotation. When a DataProfileAnnotation was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the DataProfileAnnotation
     * @return  DataProfileAnnotation the restored DataProfileAnnotation
     */
    public DataProfileAnnotation restoreDataProfileAnnotation(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreDataProfileAnnotation";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        DataProfileAnnotation restoredDataProfileAnnotation =  DataProfileAnnotationMapper.mapOmrsEntityDetailToDataProfileAnnotation(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredDataProfileAnnotation;
    }    

    /**
     * Add classifications to the supplied dataProfileAnnotation
     * @param userId user identity
     * @param entityGuid the GUID value for dataProfileAnnotation
     * @param classifications the classifications to apply.
     * @return the dataProfileAnnotation entity that has been classified
     */
     public DataProfileAnnotation addDataProfileAnnotationClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addDataProfileAnnotationClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         DataProfileAnnotation dataProfileAnnotationClassificationBeans = DataProfileAnnotationMapper.mapOmrsEntityDetailToDataProfileAnnotation(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified DataProfileAnnotation=" +  dataProfileAnnotationClassificationBeans);
         }
         return  dataProfileAnnotationClassificationBeans;
    }

    /**
     * Updates classifications to an existing dataProfileAnnotation represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the dataProfileAnnotation
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given dataProfileAnnotation guid
     */
    public DataProfileAnnotation updateDataProfileAnnotationClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateDataProfileAnnotationClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           DataProfileAnnotation  dataProfileAnnotationClassificationBeans = DataProfileAnnotationMapper.mapOmrsEntityDetailToDataProfileAnnotation(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  dataProfileAnnotationClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing dataProfileAnnotation represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the dataProfileAnnotation
     * @param name name of the classification
     * @return deleted DataProfileAnnotation  classification
     */
    public DataProfileAnnotation deleteDataProfileAnnotationClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteDataProfileAnnotationClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       DataProfileAnnotation declassifiedDataProfileAnnotation =  DataProfileAnnotationMapper.mapOmrsEntityDetailToDataProfileAnnotation(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedDataProfileAnnotation;
    }

    /**
      * Get the relationships associated with entity dataProfileAnnotation represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the dataProfileAnnotation
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getDataProfileAnnotationRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getDataProfileAnnotationRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an document given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the documents relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return Document the Document entity with the requested GUID
     */
    public Document getDocument(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getDocument";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        Document gotdocument = DocumentMapper.mapOmrsEntityDetailToDocument(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotdocument );
        }
        return gotdocument;

    }
    /**
     * Create new document.
     * @param userId user identity
     * @param document the input entity with values.
     * @return Document the created entity.
     */

    public Document createDocument(String userId,Document document)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createDocument";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = DocumentMapper.mapDocumentToOmrsEntityDetail(document);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        Document createdDocument =  DocumentMapper.mapOmrsEntityDetailToDocument(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created Document="+ createdDocument );
        }
        return createdDocument;
    }
    /**
     * Update document
     * @param userId user identity
     * @param document   document to update
     * @return Document the updated document entity
     */
    public Document updateDocument(String userId, Document document)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateDocument";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = DocumentMapper.mapDocumentToOmrsEntityDetail(document);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            Document updatedDocument =  DocumentMapper.mapOmrsEntityDetailToDocument(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated Document="+ updatedDocument );
            }
            return updatedDocument;
        }

    /**
     * Delete an document identified by its GUID. Delete is a soft delete, this means that the document has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the document
     * @return Document the deleted Document entity
     */

    public Document deleteDocument(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteDocument";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Document type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Document");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"Document",entityDef.getGUID(),entityGuid);
         Document deletedDocument = DocumentMapper.mapOmrsEntityDetailToDocument(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedDocument;

    }
    /**
     * Purge an document identified by its GUID. Delete is a hard delete, this means that the document is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the document
     */
    public void purgeDocument(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeDocument";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Document type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Document");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"Document",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an Document identified by its GUID. Restore resurrects a soft deleted Document. When a Document was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the Document
     * @return  Document the restored Document
     */
    public Document restoreDocument(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreDocument";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        Document restoredDocument =  DocumentMapper.mapOmrsEntityDetailToDocument(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredDocument;
    }    

    /**
     * Add classifications to the supplied document
     * @param userId user identity
     * @param entityGuid the GUID value for document
     * @param classifications the classifications to apply.
     * @return the document entity that has been classified
     */
     public Document addDocumentClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addDocumentClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         Document documentClassificationBeans = DocumentMapper.mapOmrsEntityDetailToDocument(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified Document=" +  documentClassificationBeans);
         }
         return  documentClassificationBeans;
    }

    /**
     * Updates classifications to an existing document represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the document
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given document guid
     */
    public Document updateDocumentClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateDocumentClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           Document  documentClassificationBeans = DocumentMapper.mapOmrsEntityDetailToDocument(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  documentClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing document represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the document
     * @param name name of the classification
     * @return deleted Document  classification
     */
    public Document deleteDocumentClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteDocumentClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       Document declassifiedDocument =  DocumentMapper.mapOmrsEntityDetailToDocument(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedDocument;
    }

    /**
      * Get the relationships associated with entity document represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the document
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getDocumentRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getDocumentRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an deployedSoftwareComponent given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the deployedSoftwareComponents relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return DeployedSoftwareComponent the DeployedSoftwareComponent entity with the requested GUID
     */
    public DeployedSoftwareComponent getDeployedSoftwareComponent(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getDeployedSoftwareComponent";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        DeployedSoftwareComponent gotdeployedSoftwareComponent = DeployedSoftwareComponentMapper.mapOmrsEntityDetailToDeployedSoftwareComponent(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotdeployedSoftwareComponent );
        }
        return gotdeployedSoftwareComponent;

    }
    /**
     * Create new deployedSoftwareComponent.
     * @param userId user identity
     * @param deployedSoftwareComponent the input entity with values.
     * @return DeployedSoftwareComponent the created entity.
     */

    public DeployedSoftwareComponent createDeployedSoftwareComponent(String userId,DeployedSoftwareComponent deployedSoftwareComponent)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createDeployedSoftwareComponent";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = DeployedSoftwareComponentMapper.mapDeployedSoftwareComponentToOmrsEntityDetail(deployedSoftwareComponent);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        DeployedSoftwareComponent createdDeployedSoftwareComponent =  DeployedSoftwareComponentMapper.mapOmrsEntityDetailToDeployedSoftwareComponent(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created DeployedSoftwareComponent="+ createdDeployedSoftwareComponent );
        }
        return createdDeployedSoftwareComponent;
    }
    /**
     * Update deployedSoftwareComponent
     * @param userId user identity
     * @param deployedSoftwareComponent   deployedSoftwareComponent to update
     * @return DeployedSoftwareComponent the updated deployedSoftwareComponent entity
     */
    public DeployedSoftwareComponent updateDeployedSoftwareComponent(String userId, DeployedSoftwareComponent deployedSoftwareComponent)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateDeployedSoftwareComponent";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = DeployedSoftwareComponentMapper.mapDeployedSoftwareComponentToOmrsEntityDetail(deployedSoftwareComponent);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            DeployedSoftwareComponent updatedDeployedSoftwareComponent =  DeployedSoftwareComponentMapper.mapOmrsEntityDetailToDeployedSoftwareComponent(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated DeployedSoftwareComponent="+ updatedDeployedSoftwareComponent );
            }
            return updatedDeployedSoftwareComponent;
        }

    /**
     * Delete an deployedSoftwareComponent identified by its GUID. Delete is a soft delete, this means that the deployedSoftwareComponent has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the deployedSoftwareComponent
     * @return DeployedSoftwareComponent the deleted DeployedSoftwareComponent entity
     */

    public DeployedSoftwareComponent deleteDeployedSoftwareComponent(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteDeployedSoftwareComponent";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DeployedSoftwareComponent type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DeployedSoftwareComponent");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"DeployedSoftwareComponent",entityDef.getGUID(),entityGuid);
         DeployedSoftwareComponent deletedDeployedSoftwareComponent = DeployedSoftwareComponentMapper.mapOmrsEntityDetailToDeployedSoftwareComponent(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedDeployedSoftwareComponent;

    }
    /**
     * Purge an deployedSoftwareComponent identified by its GUID. Delete is a hard delete, this means that the deployedSoftwareComponent is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the deployedSoftwareComponent
     */
    public void purgeDeployedSoftwareComponent(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeDeployedSoftwareComponent";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DeployedSoftwareComponent type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DeployedSoftwareComponent");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"DeployedSoftwareComponent",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an DeployedSoftwareComponent identified by its GUID. Restore resurrects a soft deleted DeployedSoftwareComponent. When a DeployedSoftwareComponent was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the DeployedSoftwareComponent
     * @return  DeployedSoftwareComponent the restored DeployedSoftwareComponent
     */
    public DeployedSoftwareComponent restoreDeployedSoftwareComponent(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreDeployedSoftwareComponent";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        DeployedSoftwareComponent restoredDeployedSoftwareComponent =  DeployedSoftwareComponentMapper.mapOmrsEntityDetailToDeployedSoftwareComponent(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredDeployedSoftwareComponent;
    }    

    /**
     * Add classifications to the supplied deployedSoftwareComponent
     * @param userId user identity
     * @param entityGuid the GUID value for deployedSoftwareComponent
     * @param classifications the classifications to apply.
     * @return the deployedSoftwareComponent entity that has been classified
     */
     public DeployedSoftwareComponent addDeployedSoftwareComponentClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addDeployedSoftwareComponentClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         DeployedSoftwareComponent deployedSoftwareComponentClassificationBeans = DeployedSoftwareComponentMapper.mapOmrsEntityDetailToDeployedSoftwareComponent(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified DeployedSoftwareComponent=" +  deployedSoftwareComponentClassificationBeans);
         }
         return  deployedSoftwareComponentClassificationBeans;
    }

    /**
     * Updates classifications to an existing deployedSoftwareComponent represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the deployedSoftwareComponent
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given deployedSoftwareComponent guid
     */
    public DeployedSoftwareComponent updateDeployedSoftwareComponentClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateDeployedSoftwareComponentClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           DeployedSoftwareComponent  deployedSoftwareComponentClassificationBeans = DeployedSoftwareComponentMapper.mapOmrsEntityDetailToDeployedSoftwareComponent(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  deployedSoftwareComponentClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing deployedSoftwareComponent represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the deployedSoftwareComponent
     * @param name name of the classification
     * @return deleted DeployedSoftwareComponent  classification
     */
    public DeployedSoftwareComponent deleteDeployedSoftwareComponentClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteDeployedSoftwareComponentClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       DeployedSoftwareComponent declassifiedDeployedSoftwareComponent =  DeployedSoftwareComponentMapper.mapOmrsEntityDetailToDeployedSoftwareComponent(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedDeployedSoftwareComponent;
    }

    /**
      * Get the relationships associated with entity deployedSoftwareComponent represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the deployedSoftwareComponent
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getDeployedSoftwareComponentRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getDeployedSoftwareComponentRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an dataFile given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the dataFiles relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return DataFile the DataFile entity with the requested GUID
     */
    public DataFile getDataFile(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getDataFile";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        DataFile gotdataFile = DataFileMapper.mapOmrsEntityDetailToDataFile(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotdataFile );
        }
        return gotdataFile;

    }
    /**
     * Create new dataFile.
     * @param userId user identity
     * @param dataFile the input entity with values.
     * @return DataFile the created entity.
     */

    public DataFile createDataFile(String userId,DataFile dataFile)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createDataFile";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = DataFileMapper.mapDataFileToOmrsEntityDetail(dataFile);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        DataFile createdDataFile =  DataFileMapper.mapOmrsEntityDetailToDataFile(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created DataFile="+ createdDataFile );
        }
        return createdDataFile;
    }
    /**
     * Update dataFile
     * @param userId user identity
     * @param dataFile   dataFile to update
     * @return DataFile the updated dataFile entity
     */
    public DataFile updateDataFile(String userId, DataFile dataFile)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateDataFile";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = DataFileMapper.mapDataFileToOmrsEntityDetail(dataFile);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            DataFile updatedDataFile =  DataFileMapper.mapOmrsEntityDetailToDataFile(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated DataFile="+ updatedDataFile );
            }
            return updatedDataFile;
        }

    /**
     * Delete an dataFile identified by its GUID. Delete is a soft delete, this means that the dataFile has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the dataFile
     * @return DataFile the deleted DataFile entity
     */

    public DataFile deleteDataFile(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteDataFile";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DataFile type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DataFile");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"DataFile",entityDef.getGUID(),entityGuid);
         DataFile deletedDataFile = DataFileMapper.mapOmrsEntityDetailToDataFile(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedDataFile;

    }
    /**
     * Purge an dataFile identified by its GUID. Delete is a hard delete, this means that the dataFile is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the dataFile
     */
    public void purgeDataFile(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeDataFile";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DataFile type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DataFile");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"DataFile",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an DataFile identified by its GUID. Restore resurrects a soft deleted DataFile. When a DataFile was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the DataFile
     * @return  DataFile the restored DataFile
     */
    public DataFile restoreDataFile(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreDataFile";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        DataFile restoredDataFile =  DataFileMapper.mapOmrsEntityDetailToDataFile(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredDataFile;
    }    

    /**
     * Add classifications to the supplied dataFile
     * @param userId user identity
     * @param entityGuid the GUID value for dataFile
     * @param classifications the classifications to apply.
     * @return the dataFile entity that has been classified
     */
     public DataFile addDataFileClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addDataFileClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         DataFile dataFileClassificationBeans = DataFileMapper.mapOmrsEntityDetailToDataFile(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified DataFile=" +  dataFileClassificationBeans);
         }
         return  dataFileClassificationBeans;
    }

    /**
     * Updates classifications to an existing dataFile represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the dataFile
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given dataFile guid
     */
    public DataFile updateDataFileClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateDataFileClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           DataFile  dataFileClassificationBeans = DataFileMapper.mapOmrsEntityDetailToDataFile(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  dataFileClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing dataFile represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the dataFile
     * @param name name of the classification
     * @return deleted DataFile  classification
     */
    public DataFile deleteDataFileClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteDataFileClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       DataFile declassifiedDataFile =  DataFileMapper.mapOmrsEntityDetailToDataFile(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedDataFile;
    }

    /**
      * Get the relationships associated with entity dataFile represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the dataFile
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getDataFileRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getDataFileRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an documentStore given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the documentStores relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return DocumentStore the DocumentStore entity with the requested GUID
     */
    public DocumentStore getDocumentStore(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getDocumentStore";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        DocumentStore gotdocumentStore = DocumentStoreMapper.mapOmrsEntityDetailToDocumentStore(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotdocumentStore );
        }
        return gotdocumentStore;

    }
    /**
     * Create new documentStore.
     * @param userId user identity
     * @param documentStore the input entity with values.
     * @return DocumentStore the created entity.
     */

    public DocumentStore createDocumentStore(String userId,DocumentStore documentStore)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createDocumentStore";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = DocumentStoreMapper.mapDocumentStoreToOmrsEntityDetail(documentStore);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        DocumentStore createdDocumentStore =  DocumentStoreMapper.mapOmrsEntityDetailToDocumentStore(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created DocumentStore="+ createdDocumentStore );
        }
        return createdDocumentStore;
    }
    /**
     * Update documentStore
     * @param userId user identity
     * @param documentStore   documentStore to update
     * @return DocumentStore the updated documentStore entity
     */
    public DocumentStore updateDocumentStore(String userId, DocumentStore documentStore)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateDocumentStore";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = DocumentStoreMapper.mapDocumentStoreToOmrsEntityDetail(documentStore);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            DocumentStore updatedDocumentStore =  DocumentStoreMapper.mapOmrsEntityDetailToDocumentStore(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated DocumentStore="+ updatedDocumentStore );
            }
            return updatedDocumentStore;
        }

    /**
     * Delete an documentStore identified by its GUID. Delete is a soft delete, this means that the documentStore has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the documentStore
     * @return DocumentStore the deleted DocumentStore entity
     */

    public DocumentStore deleteDocumentStore(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteDocumentStore";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DocumentStore type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DocumentStore");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"DocumentStore",entityDef.getGUID(),entityGuid);
         DocumentStore deletedDocumentStore = DocumentStoreMapper.mapOmrsEntityDetailToDocumentStore(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedDocumentStore;

    }
    /**
     * Purge an documentStore identified by its GUID. Delete is a hard delete, this means that the documentStore is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the documentStore
     */
    public void purgeDocumentStore(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeDocumentStore";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DocumentStore type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DocumentStore");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"DocumentStore",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an DocumentStore identified by its GUID. Restore resurrects a soft deleted DocumentStore. When a DocumentStore was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the DocumentStore
     * @return  DocumentStore the restored DocumentStore
     */
    public DocumentStore restoreDocumentStore(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreDocumentStore";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        DocumentStore restoredDocumentStore =  DocumentStoreMapper.mapOmrsEntityDetailToDocumentStore(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredDocumentStore;
    }    

    /**
     * Add classifications to the supplied documentStore
     * @param userId user identity
     * @param entityGuid the GUID value for documentStore
     * @param classifications the classifications to apply.
     * @return the documentStore entity that has been classified
     */
     public DocumentStore addDocumentStoreClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addDocumentStoreClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         DocumentStore documentStoreClassificationBeans = DocumentStoreMapper.mapOmrsEntityDetailToDocumentStore(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified DocumentStore=" +  documentStoreClassificationBeans);
         }
         return  documentStoreClassificationBeans;
    }

    /**
     * Updates classifications to an existing documentStore represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the documentStore
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given documentStore guid
     */
    public DocumentStore updateDocumentStoreClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateDocumentStoreClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           DocumentStore  documentStoreClassificationBeans = DocumentStoreMapper.mapOmrsEntityDetailToDocumentStore(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  documentStoreClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing documentStore represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the documentStore
     * @param name name of the classification
     * @return deleted DocumentStore  classification
     */
    public DocumentStore deleteDocumentStoreClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteDocumentStoreClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       DocumentStore declassifiedDocumentStore =  DocumentStoreMapper.mapOmrsEntityDetailToDocumentStore(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedDocumentStore;
    }

    /**
      * Get the relationships associated with entity documentStore represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the documentStore
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getDocumentStoreRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getDocumentStoreRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an referenceable given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the referenceables relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return Referenceable the Referenceable entity with the requested GUID
     */
    public Referenceable getReferenceable(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getReferenceable";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        Referenceable gotreferenceable = ReferenceableMapper.mapOmrsEntityDetailToReferenceable(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotreferenceable );
        }
        return gotreferenceable;

    }
    /**
     * Create new referenceable.
     * @param userId user identity
     * @param referenceable the input entity with values.
     * @return Referenceable the created entity.
     */

    public Referenceable createReferenceable(String userId,Referenceable referenceable)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createReferenceable";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = ReferenceableMapper.mapReferenceableToOmrsEntityDetail(referenceable);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        Referenceable createdReferenceable =  ReferenceableMapper.mapOmrsEntityDetailToReferenceable(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created Referenceable="+ createdReferenceable );
        }
        return createdReferenceable;
    }
    /**
     * Update referenceable
     * @param userId user identity
     * @param referenceable   referenceable to update
     * @return Referenceable the updated referenceable entity
     */
    public Referenceable updateReferenceable(String userId, Referenceable referenceable)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateReferenceable";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = ReferenceableMapper.mapReferenceableToOmrsEntityDetail(referenceable);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            Referenceable updatedReferenceable =  ReferenceableMapper.mapOmrsEntityDetailToReferenceable(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated Referenceable="+ updatedReferenceable );
            }
            return updatedReferenceable;
        }

    /**
     * Delete an referenceable identified by its GUID. Delete is a soft delete, this means that the referenceable has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the referenceable
     * @return Referenceable the deleted Referenceable entity
     */

    public Referenceable deleteReferenceable(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteReferenceable";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Referenceable type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Referenceable");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"Referenceable",entityDef.getGUID(),entityGuid);
         Referenceable deletedReferenceable = ReferenceableMapper.mapOmrsEntityDetailToReferenceable(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedReferenceable;

    }
    /**
     * Purge an referenceable identified by its GUID. Delete is a hard delete, this means that the referenceable is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the referenceable
     */
    public void purgeReferenceable(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeReferenceable";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Referenceable type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Referenceable");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"Referenceable",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an Referenceable identified by its GUID. Restore resurrects a soft deleted Referenceable. When a Referenceable was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the Referenceable
     * @return  Referenceable the restored Referenceable
     */
    public Referenceable restoreReferenceable(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreReferenceable";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        Referenceable restoredReferenceable =  ReferenceableMapper.mapOmrsEntityDetailToReferenceable(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredReferenceable;
    }    

    /**
     * Add classifications to the supplied referenceable
     * @param userId user identity
     * @param entityGuid the GUID value for referenceable
     * @param classifications the classifications to apply.
     * @return the referenceable entity that has been classified
     */
     public Referenceable addReferenceableClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addReferenceableClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         Referenceable referenceableClassificationBeans = ReferenceableMapper.mapOmrsEntityDetailToReferenceable(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified Referenceable=" +  referenceableClassificationBeans);
         }
         return  referenceableClassificationBeans;
    }

    /**
     * Updates classifications to an existing referenceable represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the referenceable
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given referenceable guid
     */
    public Referenceable updateReferenceableClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateReferenceableClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           Referenceable  referenceableClassificationBeans = ReferenceableMapper.mapOmrsEntityDetailToReferenceable(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  referenceableClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing referenceable represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the referenceable
     * @param name name of the classification
     * @return deleted Referenceable  classification
     */
    public Referenceable deleteReferenceableClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteReferenceableClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       Referenceable declassifiedReferenceable =  ReferenceableMapper.mapOmrsEntityDetailToReferenceable(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedReferenceable;
    }

    /**
      * Get the relationships associated with entity referenceable represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the referenceable
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getReferenceableRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getReferenceableRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an externalReference given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the externalReferences relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return ExternalReference the ExternalReference entity with the requested GUID
     */
    public ExternalReference getExternalReference(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getExternalReference";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        ExternalReference gotexternalReference = ExternalReferenceMapper.mapOmrsEntityDetailToExternalReference(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotexternalReference );
        }
        return gotexternalReference;

    }
    /**
     * Create new externalReference.
     * @param userId user identity
     * @param externalReference the input entity with values.
     * @return ExternalReference the created entity.
     */

    public ExternalReference createExternalReference(String userId,ExternalReference externalReference)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createExternalReference";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = ExternalReferenceMapper.mapExternalReferenceToOmrsEntityDetail(externalReference);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        ExternalReference createdExternalReference =  ExternalReferenceMapper.mapOmrsEntityDetailToExternalReference(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created ExternalReference="+ createdExternalReference );
        }
        return createdExternalReference;
    }
    /**
     * Update externalReference
     * @param userId user identity
     * @param externalReference   externalReference to update
     * @return ExternalReference the updated externalReference entity
     */
    public ExternalReference updateExternalReference(String userId, ExternalReference externalReference)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateExternalReference";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = ExternalReferenceMapper.mapExternalReferenceToOmrsEntityDetail(externalReference);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            ExternalReference updatedExternalReference =  ExternalReferenceMapper.mapOmrsEntityDetailToExternalReference(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated ExternalReference="+ updatedExternalReference );
            }
            return updatedExternalReference;
        }

    /**
     * Delete an externalReference identified by its GUID. Delete is a soft delete, this means that the externalReference has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the externalReference
     * @return ExternalReference the deleted ExternalReference entity
     */

    public ExternalReference deleteExternalReference(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteExternalReference";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ExternalReference type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ExternalReference");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"ExternalReference",entityDef.getGUID(),entityGuid);
         ExternalReference deletedExternalReference = ExternalReferenceMapper.mapOmrsEntityDetailToExternalReference(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedExternalReference;

    }
    /**
     * Purge an externalReference identified by its GUID. Delete is a hard delete, this means that the externalReference is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the externalReference
     */
    public void purgeExternalReference(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeExternalReference";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ExternalReference type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ExternalReference");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"ExternalReference",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an ExternalReference identified by its GUID. Restore resurrects a soft deleted ExternalReference. When a ExternalReference was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the ExternalReference
     * @return  ExternalReference the restored ExternalReference
     */
    public ExternalReference restoreExternalReference(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreExternalReference";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        ExternalReference restoredExternalReference =  ExternalReferenceMapper.mapOmrsEntityDetailToExternalReference(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredExternalReference;
    }    

    /**
     * Add classifications to the supplied externalReference
     * @param userId user identity
     * @param entityGuid the GUID value for externalReference
     * @param classifications the classifications to apply.
     * @return the externalReference entity that has been classified
     */
     public ExternalReference addExternalReferenceClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addExternalReferenceClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         ExternalReference externalReferenceClassificationBeans = ExternalReferenceMapper.mapOmrsEntityDetailToExternalReference(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified ExternalReference=" +  externalReferenceClassificationBeans);
         }
         return  externalReferenceClassificationBeans;
    }

    /**
     * Updates classifications to an existing externalReference represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the externalReference
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given externalReference guid
     */
    public ExternalReference updateExternalReferenceClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateExternalReferenceClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           ExternalReference  externalReferenceClassificationBeans = ExternalReferenceMapper.mapOmrsEntityDetailToExternalReference(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  externalReferenceClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing externalReference represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the externalReference
     * @param name name of the classification
     * @return deleted ExternalReference  classification
     */
    public ExternalReference deleteExternalReferenceClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteExternalReferenceClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       ExternalReference declassifiedExternalReference =  ExternalReferenceMapper.mapOmrsEntityDetailToExternalReference(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedExternalReference;
    }

    /**
      * Get the relationships associated with entity externalReference represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the externalReference
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getExternalReferenceRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getExternalReferenceRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an endpoint given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the endpoints relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return Endpoint the Endpoint entity with the requested GUID
     */
    public Endpoint getEndpoint(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getEndpoint";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        Endpoint gotendpoint = EndpointMapper.mapOmrsEntityDetailToEndpoint(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotendpoint );
        }
        return gotendpoint;

    }
    /**
     * Create new endpoint.
     * @param userId user identity
     * @param endpoint the input entity with values.
     * @return Endpoint the created entity.
     */

    public Endpoint createEndpoint(String userId,Endpoint endpoint)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createEndpoint";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = EndpointMapper.mapEndpointToOmrsEntityDetail(endpoint);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        Endpoint createdEndpoint =  EndpointMapper.mapOmrsEntityDetailToEndpoint(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created Endpoint="+ createdEndpoint );
        }
        return createdEndpoint;
    }
    /**
     * Update endpoint
     * @param userId user identity
     * @param endpoint   endpoint to update
     * @return Endpoint the updated endpoint entity
     */
    public Endpoint updateEndpoint(String userId, Endpoint endpoint)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateEndpoint";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = EndpointMapper.mapEndpointToOmrsEntityDetail(endpoint);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            Endpoint updatedEndpoint =  EndpointMapper.mapOmrsEntityDetailToEndpoint(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated Endpoint="+ updatedEndpoint );
            }
            return updatedEndpoint;
        }

    /**
     * Delete an endpoint identified by its GUID. Delete is a soft delete, this means that the endpoint has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the endpoint
     * @return Endpoint the deleted Endpoint entity
     */

    public Endpoint deleteEndpoint(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteEndpoint";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Endpoint type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Endpoint");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"Endpoint",entityDef.getGUID(),entityGuid);
         Endpoint deletedEndpoint = EndpointMapper.mapOmrsEntityDetailToEndpoint(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedEndpoint;

    }
    /**
     * Purge an endpoint identified by its GUID. Delete is a hard delete, this means that the endpoint is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the endpoint
     */
    public void purgeEndpoint(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeEndpoint";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Endpoint type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Endpoint");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"Endpoint",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an Endpoint identified by its GUID. Restore resurrects a soft deleted Endpoint. When a Endpoint was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the Endpoint
     * @return  Endpoint the restored Endpoint
     */
    public Endpoint restoreEndpoint(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreEndpoint";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        Endpoint restoredEndpoint =  EndpointMapper.mapOmrsEntityDetailToEndpoint(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredEndpoint;
    }    

    /**
     * Add classifications to the supplied endpoint
     * @param userId user identity
     * @param entityGuid the GUID value for endpoint
     * @param classifications the classifications to apply.
     * @return the endpoint entity that has been classified
     */
     public Endpoint addEndpointClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addEndpointClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         Endpoint endpointClassificationBeans = EndpointMapper.mapOmrsEntityDetailToEndpoint(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified Endpoint=" +  endpointClassificationBeans);
         }
         return  endpointClassificationBeans;
    }

    /**
     * Updates classifications to an existing endpoint represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the endpoint
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given endpoint guid
     */
    public Endpoint updateEndpointClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateEndpointClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           Endpoint  endpointClassificationBeans = EndpointMapper.mapOmrsEntityDetailToEndpoint(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  endpointClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing endpoint represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the endpoint
     * @param name name of the classification
     * @return deleted Endpoint  classification
     */
    public Endpoint deleteEndpointClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteEndpointClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       Endpoint declassifiedEndpoint =  EndpointMapper.mapOmrsEntityDetailToEndpoint(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedEndpoint;
    }

    /**
      * Get the relationships associated with entity endpoint represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the endpoint
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getEndpointRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getEndpointRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an contactDetails given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the contactDetailses relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return ContactDetails the ContactDetails entity with the requested GUID
     */
    public ContactDetails getContactDetails(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getContactDetails";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        ContactDetails gotcontactDetails = ContactDetailsMapper.mapOmrsEntityDetailToContactDetails(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotcontactDetails );
        }
        return gotcontactDetails;

    }
    /**
     * Create new contactDetails.
     * @param userId user identity
     * @param contactDetails the input entity with values.
     * @return ContactDetails the created entity.
     */

    public ContactDetails createContactDetails(String userId,ContactDetails contactDetails)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createContactDetails";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = ContactDetailsMapper.mapContactDetailsToOmrsEntityDetail(contactDetails);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        ContactDetails createdContactDetails =  ContactDetailsMapper.mapOmrsEntityDetailToContactDetails(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created ContactDetails="+ createdContactDetails );
        }
        return createdContactDetails;
    }
    /**
     * Update contactDetails
     * @param userId user identity
     * @param contactDetails   contactDetails to update
     * @return ContactDetails the updated contactDetails entity
     */
    public ContactDetails updateContactDetails(String userId, ContactDetails contactDetails)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateContactDetails";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = ContactDetailsMapper.mapContactDetailsToOmrsEntityDetail(contactDetails);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            ContactDetails updatedContactDetails =  ContactDetailsMapper.mapOmrsEntityDetailToContactDetails(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated ContactDetails="+ updatedContactDetails );
            }
            return updatedContactDetails;
        }

    /**
     * Delete an contactDetails identified by its GUID. Delete is a soft delete, this means that the contactDetails has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the contactDetails
     * @return ContactDetails the deleted ContactDetails entity
     */

    public ContactDetails deleteContactDetails(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteContactDetails";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ContactDetails type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ContactDetails");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"ContactDetails",entityDef.getGUID(),entityGuid);
         ContactDetails deletedContactDetails = ContactDetailsMapper.mapOmrsEntityDetailToContactDetails(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedContactDetails;

    }
    /**
     * Purge an contactDetails identified by its GUID. Delete is a hard delete, this means that the contactDetails is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the contactDetails
     */
    public void purgeContactDetails(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeContactDetails";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ContactDetails type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ContactDetails");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"ContactDetails",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an ContactDetails identified by its GUID. Restore resurrects a soft deleted ContactDetails. When a ContactDetails was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the ContactDetails
     * @return  ContactDetails the restored ContactDetails
     */
    public ContactDetails restoreContactDetails(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreContactDetails";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        ContactDetails restoredContactDetails =  ContactDetailsMapper.mapOmrsEntityDetailToContactDetails(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredContactDetails;
    }    

    /**
     * Add classifications to the supplied contactDetails
     * @param userId user identity
     * @param entityGuid the GUID value for contactDetails
     * @param classifications the classifications to apply.
     * @return the contactDetails entity that has been classified
     */
     public ContactDetails addContactDetailsClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addContactDetailsClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         ContactDetails contactDetailsClassificationBeans = ContactDetailsMapper.mapOmrsEntityDetailToContactDetails(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified ContactDetails=" +  contactDetailsClassificationBeans);
         }
         return  contactDetailsClassificationBeans;
    }

    /**
     * Updates classifications to an existing contactDetails represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the contactDetails
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given contactDetails guid
     */
    public ContactDetails updateContactDetailsClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateContactDetailsClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           ContactDetails  contactDetailsClassificationBeans = ContactDetailsMapper.mapOmrsEntityDetailToContactDetails(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  contactDetailsClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing contactDetails represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the contactDetails
     * @param name name of the classification
     * @return deleted ContactDetails  classification
     */
    public ContactDetails deleteContactDetailsClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteContactDetailsClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       ContactDetails declassifiedContactDetails =  ContactDetailsMapper.mapOmrsEntityDetailToContactDetails(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedContactDetails;
    }

    /**
      * Get the relationships associated with entity contactDetails represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the contactDetails
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getContactDetailsRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getContactDetailsRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an governanceDefinition given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the governanceDefinitions relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return GovernanceDefinition the GovernanceDefinition entity with the requested GUID
     */
    public GovernanceDefinition getGovernanceDefinition(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getGovernanceDefinition";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        GovernanceDefinition gotgovernanceDefinition = GovernanceDefinitionMapper.mapOmrsEntityDetailToGovernanceDefinition(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotgovernanceDefinition );
        }
        return gotgovernanceDefinition;

    }
    /**
     * Create new governanceDefinition.
     * @param userId user identity
     * @param governanceDefinition the input entity with values.
     * @return GovernanceDefinition the created entity.
     */

    public GovernanceDefinition createGovernanceDefinition(String userId,GovernanceDefinition governanceDefinition)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createGovernanceDefinition";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = GovernanceDefinitionMapper.mapGovernanceDefinitionToOmrsEntityDetail(governanceDefinition);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        GovernanceDefinition createdGovernanceDefinition =  GovernanceDefinitionMapper.mapOmrsEntityDetailToGovernanceDefinition(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created GovernanceDefinition="+ createdGovernanceDefinition );
        }
        return createdGovernanceDefinition;
    }
    /**
     * Update governanceDefinition
     * @param userId user identity
     * @param governanceDefinition   governanceDefinition to update
     * @return GovernanceDefinition the updated governanceDefinition entity
     */
    public GovernanceDefinition updateGovernanceDefinition(String userId, GovernanceDefinition governanceDefinition)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateGovernanceDefinition";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = GovernanceDefinitionMapper.mapGovernanceDefinitionToOmrsEntityDetail(governanceDefinition);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            GovernanceDefinition updatedGovernanceDefinition =  GovernanceDefinitionMapper.mapOmrsEntityDetailToGovernanceDefinition(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated GovernanceDefinition="+ updatedGovernanceDefinition );
            }
            return updatedGovernanceDefinition;
        }

    /**
     * Delete an governanceDefinition identified by its GUID. Delete is a soft delete, this means that the governanceDefinition has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the governanceDefinition
     * @return GovernanceDefinition the deleted GovernanceDefinition entity
     */

    public GovernanceDefinition deleteGovernanceDefinition(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteGovernanceDefinition";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GovernanceDefinition type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GovernanceDefinition");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"GovernanceDefinition",entityDef.getGUID(),entityGuid);
         GovernanceDefinition deletedGovernanceDefinition = GovernanceDefinitionMapper.mapOmrsEntityDetailToGovernanceDefinition(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedGovernanceDefinition;

    }
    /**
     * Purge an governanceDefinition identified by its GUID. Delete is a hard delete, this means that the governanceDefinition is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the governanceDefinition
     */
    public void purgeGovernanceDefinition(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeGovernanceDefinition";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GovernanceDefinition type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GovernanceDefinition");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"GovernanceDefinition",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an GovernanceDefinition identified by its GUID. Restore resurrects a soft deleted GovernanceDefinition. When a GovernanceDefinition was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the GovernanceDefinition
     * @return  GovernanceDefinition the restored GovernanceDefinition
     */
    public GovernanceDefinition restoreGovernanceDefinition(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreGovernanceDefinition";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        GovernanceDefinition restoredGovernanceDefinition =  GovernanceDefinitionMapper.mapOmrsEntityDetailToGovernanceDefinition(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredGovernanceDefinition;
    }    

    /**
     * Add classifications to the supplied governanceDefinition
     * @param userId user identity
     * @param entityGuid the GUID value for governanceDefinition
     * @param classifications the classifications to apply.
     * @return the governanceDefinition entity that has been classified
     */
     public GovernanceDefinition addGovernanceDefinitionClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addGovernanceDefinitionClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         GovernanceDefinition governanceDefinitionClassificationBeans = GovernanceDefinitionMapper.mapOmrsEntityDetailToGovernanceDefinition(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified GovernanceDefinition=" +  governanceDefinitionClassificationBeans);
         }
         return  governanceDefinitionClassificationBeans;
    }

    /**
     * Updates classifications to an existing governanceDefinition represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the governanceDefinition
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given governanceDefinition guid
     */
    public GovernanceDefinition updateGovernanceDefinitionClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateGovernanceDefinitionClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           GovernanceDefinition  governanceDefinitionClassificationBeans = GovernanceDefinitionMapper.mapOmrsEntityDetailToGovernanceDefinition(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  governanceDefinitionClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing governanceDefinition represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the governanceDefinition
     * @param name name of the classification
     * @return deleted GovernanceDefinition  classification
     */
    public GovernanceDefinition deleteGovernanceDefinitionClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteGovernanceDefinitionClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       GovernanceDefinition declassifiedGovernanceDefinition =  GovernanceDefinitionMapper.mapOmrsEntityDetailToGovernanceDefinition(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedGovernanceDefinition;
    }

    /**
      * Get the relationships associated with entity governanceDefinition represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the governanceDefinition
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getGovernanceDefinitionRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getGovernanceDefinitionRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an network given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the networks relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return Network the Network entity with the requested GUID
     */
    public Network getNetwork(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getNetwork";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        Network gotnetwork = NetworkMapper.mapOmrsEntityDetailToNetwork(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotnetwork );
        }
        return gotnetwork;

    }
    /**
     * Create new network.
     * @param userId user identity
     * @param network the input entity with values.
     * @return Network the created entity.
     */

    public Network createNetwork(String userId,Network network)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createNetwork";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = NetworkMapper.mapNetworkToOmrsEntityDetail(network);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        Network createdNetwork =  NetworkMapper.mapOmrsEntityDetailToNetwork(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created Network="+ createdNetwork );
        }
        return createdNetwork;
    }
    /**
     * Update network
     * @param userId user identity
     * @param network   network to update
     * @return Network the updated network entity
     */
    public Network updateNetwork(String userId, Network network)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateNetwork";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = NetworkMapper.mapNetworkToOmrsEntityDetail(network);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            Network updatedNetwork =  NetworkMapper.mapOmrsEntityDetailToNetwork(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated Network="+ updatedNetwork );
            }
            return updatedNetwork;
        }

    /**
     * Delete an network identified by its GUID. Delete is a soft delete, this means that the network has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the network
     * @return Network the deleted Network entity
     */

    public Network deleteNetwork(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteNetwork";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Network type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Network");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"Network",entityDef.getGUID(),entityGuid);
         Network deletedNetwork = NetworkMapper.mapOmrsEntityDetailToNetwork(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedNetwork;

    }
    /**
     * Purge an network identified by its GUID. Delete is a hard delete, this means that the network is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the network
     */
    public void purgeNetwork(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeNetwork";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Network type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Network");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"Network",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an Network identified by its GUID. Restore resurrects a soft deleted Network. When a Network was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the Network
     * @return  Network the restored Network
     */
    public Network restoreNetwork(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreNetwork";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        Network restoredNetwork =  NetworkMapper.mapOmrsEntityDetailToNetwork(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredNetwork;
    }    

    /**
     * Add classifications to the supplied network
     * @param userId user identity
     * @param entityGuid the GUID value for network
     * @param classifications the classifications to apply.
     * @return the network entity that has been classified
     */
     public Network addNetworkClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addNetworkClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         Network networkClassificationBeans = NetworkMapper.mapOmrsEntityDetailToNetwork(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified Network=" +  networkClassificationBeans);
         }
         return  networkClassificationBeans;
    }

    /**
     * Updates classifications to an existing network represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the network
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given network guid
     */
    public Network updateNetworkClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateNetworkClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           Network  networkClassificationBeans = NetworkMapper.mapOmrsEntityDetailToNetwork(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  networkClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing network represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the network
     * @param name name of the classification
     * @return deleted Network  classification
     */
    public Network deleteNetworkClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteNetworkClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       Network declassifiedNetwork =  NetworkMapper.mapOmrsEntityDetailToNetwork(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedNetwork;
    }

    /**
      * Get the relationships associated with entity network represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the network
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getNetworkRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getNetworkRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an dataStore given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the dataStores relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return DataStore the DataStore entity with the requested GUID
     */
    public DataStore getDataStore(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getDataStore";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        DataStore gotdataStore = DataStoreMapper.mapOmrsEntityDetailToDataStore(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotdataStore );
        }
        return gotdataStore;

    }
    /**
     * Create new dataStore.
     * @param userId user identity
     * @param dataStore the input entity with values.
     * @return DataStore the created entity.
     */

    public DataStore createDataStore(String userId,DataStore dataStore)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createDataStore";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = DataStoreMapper.mapDataStoreToOmrsEntityDetail(dataStore);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        DataStore createdDataStore =  DataStoreMapper.mapOmrsEntityDetailToDataStore(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created DataStore="+ createdDataStore );
        }
        return createdDataStore;
    }
    /**
     * Update dataStore
     * @param userId user identity
     * @param dataStore   dataStore to update
     * @return DataStore the updated dataStore entity
     */
    public DataStore updateDataStore(String userId, DataStore dataStore)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateDataStore";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = DataStoreMapper.mapDataStoreToOmrsEntityDetail(dataStore);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            DataStore updatedDataStore =  DataStoreMapper.mapOmrsEntityDetailToDataStore(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated DataStore="+ updatedDataStore );
            }
            return updatedDataStore;
        }

    /**
     * Delete an dataStore identified by its GUID. Delete is a soft delete, this means that the dataStore has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the dataStore
     * @return DataStore the deleted DataStore entity
     */

    public DataStore deleteDataStore(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteDataStore";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DataStore type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DataStore");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"DataStore",entityDef.getGUID(),entityGuid);
         DataStore deletedDataStore = DataStoreMapper.mapOmrsEntityDetailToDataStore(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedDataStore;

    }
    /**
     * Purge an dataStore identified by its GUID. Delete is a hard delete, this means that the dataStore is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the dataStore
     */
    public void purgeDataStore(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeDataStore";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DataStore type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DataStore");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"DataStore",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an DataStore identified by its GUID. Restore resurrects a soft deleted DataStore. When a DataStore was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the DataStore
     * @return  DataStore the restored DataStore
     */
    public DataStore restoreDataStore(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreDataStore";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        DataStore restoredDataStore =  DataStoreMapper.mapOmrsEntityDetailToDataStore(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredDataStore;
    }    

    /**
     * Add classifications to the supplied dataStore
     * @param userId user identity
     * @param entityGuid the GUID value for dataStore
     * @param classifications the classifications to apply.
     * @return the dataStore entity that has been classified
     */
     public DataStore addDataStoreClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addDataStoreClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         DataStore dataStoreClassificationBeans = DataStoreMapper.mapOmrsEntityDetailToDataStore(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified DataStore=" +  dataStoreClassificationBeans);
         }
         return  dataStoreClassificationBeans;
    }

    /**
     * Updates classifications to an existing dataStore represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the dataStore
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given dataStore guid
     */
    public DataStore updateDataStoreClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateDataStoreClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           DataStore  dataStoreClassificationBeans = DataStoreMapper.mapOmrsEntityDetailToDataStore(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  dataStoreClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing dataStore represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the dataStore
     * @param name name of the classification
     * @return deleted DataStore  classification
     */
    public DataStore deleteDataStoreClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteDataStoreClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       DataStore declassifiedDataStore =  DataStoreMapper.mapOmrsEntityDetailToDataStore(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedDataStore;
    }

    /**
      * Get the relationships associated with entity dataStore represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the dataStore
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getDataStoreRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getDataStoreRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an database given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the databases relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return Database the Database entity with the requested GUID
     */
    public Database getDatabase(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getDatabase";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        Database gotdatabase = DatabaseMapper.mapOmrsEntityDetailToDatabase(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotdatabase );
        }
        return gotdatabase;

    }
    /**
     * Create new database.
     * @param userId user identity
     * @param database the input entity with values.
     * @return Database the created entity.
     */

    public Database createDatabase(String userId,Database database)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createDatabase";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = DatabaseMapper.mapDatabaseToOmrsEntityDetail(database);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        Database createdDatabase =  DatabaseMapper.mapOmrsEntityDetailToDatabase(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created Database="+ createdDatabase );
        }
        return createdDatabase;
    }
    /**
     * Update database
     * @param userId user identity
     * @param database   database to update
     * @return Database the updated database entity
     */
    public Database updateDatabase(String userId, Database database)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateDatabase";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = DatabaseMapper.mapDatabaseToOmrsEntityDetail(database);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            Database updatedDatabase =  DatabaseMapper.mapOmrsEntityDetailToDatabase(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated Database="+ updatedDatabase );
            }
            return updatedDatabase;
        }

    /**
     * Delete an database identified by its GUID. Delete is a soft delete, this means that the database has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the database
     * @return Database the deleted Database entity
     */

    public Database deleteDatabase(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteDatabase";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Database type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Database");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"Database",entityDef.getGUID(),entityGuid);
         Database deletedDatabase = DatabaseMapper.mapOmrsEntityDetailToDatabase(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedDatabase;

    }
    /**
     * Purge an database identified by its GUID. Delete is a hard delete, this means that the database is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the database
     */
    public void purgeDatabase(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeDatabase";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Database type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Database");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"Database",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an Database identified by its GUID. Restore resurrects a soft deleted Database. When a Database was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the Database
     * @return  Database the restored Database
     */
    public Database restoreDatabase(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreDatabase";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        Database restoredDatabase =  DatabaseMapper.mapOmrsEntityDetailToDatabase(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredDatabase;
    }    

    /**
     * Add classifications to the supplied database
     * @param userId user identity
     * @param entityGuid the GUID value for database
     * @param classifications the classifications to apply.
     * @return the database entity that has been classified
     */
     public Database addDatabaseClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addDatabaseClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         Database databaseClassificationBeans = DatabaseMapper.mapOmrsEntityDetailToDatabase(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified Database=" +  databaseClassificationBeans);
         }
         return  databaseClassificationBeans;
    }

    /**
     * Updates classifications to an existing database represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the database
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given database guid
     */
    public Database updateDatabaseClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateDatabaseClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           Database  databaseClassificationBeans = DatabaseMapper.mapOmrsEntityDetailToDatabase(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  databaseClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing database represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the database
     * @param name name of the classification
     * @return deleted Database  classification
     */
    public Database deleteDatabaseClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteDatabaseClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       Database declassifiedDatabase =  DatabaseMapper.mapOmrsEntityDetailToDatabase(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedDatabase;
    }

    /**
      * Get the relationships associated with entity database represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the database
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getDatabaseRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getDatabaseRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an asset given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the assets relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return Asset the Asset entity with the requested GUID
     */
    public Asset getAsset(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getAsset";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        Asset gotasset = AssetMapper.mapOmrsEntityDetailToAsset(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotasset );
        }
        return gotasset;

    }
    /**
     * Create new asset.
     * @param userId user identity
     * @param asset the input entity with values.
     * @return Asset the created entity.
     */

    public Asset createAsset(String userId,Asset asset)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createAsset";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = AssetMapper.mapAssetToOmrsEntityDetail(asset);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        Asset createdAsset =  AssetMapper.mapOmrsEntityDetailToAsset(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created Asset="+ createdAsset );
        }
        return createdAsset;
    }
    /**
     * Update asset
     * @param userId user identity
     * @param asset   asset to update
     * @return Asset the updated asset entity
     */
    public Asset updateAsset(String userId, Asset asset)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateAsset";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = AssetMapper.mapAssetToOmrsEntityDetail(asset);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            Asset updatedAsset =  AssetMapper.mapOmrsEntityDetailToAsset(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated Asset="+ updatedAsset );
            }
            return updatedAsset;
        }

    /**
     * Delete an asset identified by its GUID. Delete is a soft delete, this means that the asset has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the asset
     * @return Asset the deleted Asset entity
     */

    public Asset deleteAsset(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteAsset";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Asset type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Asset");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"Asset",entityDef.getGUID(),entityGuid);
         Asset deletedAsset = AssetMapper.mapOmrsEntityDetailToAsset(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedAsset;

    }
    /**
     * Purge an asset identified by its GUID. Delete is a hard delete, this means that the asset is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the asset
     */
    public void purgeAsset(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeAsset";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Asset type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Asset");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"Asset",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an Asset identified by its GUID. Restore resurrects a soft deleted Asset. When a Asset was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the Asset
     * @return  Asset the restored Asset
     */
    public Asset restoreAsset(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreAsset";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        Asset restoredAsset =  AssetMapper.mapOmrsEntityDetailToAsset(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredAsset;
    }    

    /**
     * Add classifications to the supplied asset
     * @param userId user identity
     * @param entityGuid the GUID value for asset
     * @param classifications the classifications to apply.
     * @return the asset entity that has been classified
     */
     public Asset addAssetClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addAssetClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         Asset assetClassificationBeans = AssetMapper.mapOmrsEntityDetailToAsset(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified Asset=" +  assetClassificationBeans);
         }
         return  assetClassificationBeans;
    }

    /**
     * Updates classifications to an existing asset represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the asset
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given asset guid
     */
    public Asset updateAssetClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateAssetClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           Asset  assetClassificationBeans = AssetMapper.mapOmrsEntityDetailToAsset(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  assetClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing asset represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the asset
     * @param name name of the classification
     * @return deleted Asset  classification
     */
    public Asset deleteAssetClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteAssetClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       Asset declassifiedAsset =  AssetMapper.mapOmrsEntityDetailToAsset(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedAsset;
    }

    /**
      * Get the relationships associated with entity asset represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the asset
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getAssetRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getAssetRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an setSchemaType given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the setSchemaTypes relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return SetSchemaType the SetSchemaType entity with the requested GUID
     */
    public SetSchemaType getSetSchemaType(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getSetSchemaType";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        SetSchemaType gotsetSchemaType = SetSchemaTypeMapper.mapOmrsEntityDetailToSetSchemaType(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotsetSchemaType );
        }
        return gotsetSchemaType;

    }
    /**
     * Create new setSchemaType.
     * @param userId user identity
     * @param setSchemaType the input entity with values.
     * @return SetSchemaType the created entity.
     */

    public SetSchemaType createSetSchemaType(String userId,SetSchemaType setSchemaType)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createSetSchemaType";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = SetSchemaTypeMapper.mapSetSchemaTypeToOmrsEntityDetail(setSchemaType);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        SetSchemaType createdSetSchemaType =  SetSchemaTypeMapper.mapOmrsEntityDetailToSetSchemaType(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created SetSchemaType="+ createdSetSchemaType );
        }
        return createdSetSchemaType;
    }
    /**
     * Update setSchemaType
     * @param userId user identity
     * @param setSchemaType   setSchemaType to update
     * @return SetSchemaType the updated setSchemaType entity
     */
    public SetSchemaType updateSetSchemaType(String userId, SetSchemaType setSchemaType)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateSetSchemaType";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = SetSchemaTypeMapper.mapSetSchemaTypeToOmrsEntityDetail(setSchemaType);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            SetSchemaType updatedSetSchemaType =  SetSchemaTypeMapper.mapOmrsEntityDetailToSetSchemaType(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated SetSchemaType="+ updatedSetSchemaType );
            }
            return updatedSetSchemaType;
        }

    /**
     * Delete an setSchemaType identified by its GUID. Delete is a soft delete, this means that the setSchemaType has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the setSchemaType
     * @return SetSchemaType the deleted SetSchemaType entity
     */

    public SetSchemaType deleteSetSchemaType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteSetSchemaType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the SetSchemaType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("SetSchemaType");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"SetSchemaType",entityDef.getGUID(),entityGuid);
         SetSchemaType deletedSetSchemaType = SetSchemaTypeMapper.mapOmrsEntityDetailToSetSchemaType(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedSetSchemaType;

    }
    /**
     * Purge an setSchemaType identified by its GUID. Delete is a hard delete, this means that the setSchemaType is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the setSchemaType
     */
    public void purgeSetSchemaType(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeSetSchemaType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the SetSchemaType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("SetSchemaType");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"SetSchemaType",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an SetSchemaType identified by its GUID. Restore resurrects a soft deleted SetSchemaType. When a SetSchemaType was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the SetSchemaType
     * @return  SetSchemaType the restored SetSchemaType
     */
    public SetSchemaType restoreSetSchemaType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreSetSchemaType";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        SetSchemaType restoredSetSchemaType =  SetSchemaTypeMapper.mapOmrsEntityDetailToSetSchemaType(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredSetSchemaType;
    }    

    /**
     * Add classifications to the supplied setSchemaType
     * @param userId user identity
     * @param entityGuid the GUID value for setSchemaType
     * @param classifications the classifications to apply.
     * @return the setSchemaType entity that has been classified
     */
     public SetSchemaType addSetSchemaTypeClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addSetSchemaTypeClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         SetSchemaType setSchemaTypeClassificationBeans = SetSchemaTypeMapper.mapOmrsEntityDetailToSetSchemaType(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified SetSchemaType=" +  setSchemaTypeClassificationBeans);
         }
         return  setSchemaTypeClassificationBeans;
    }

    /**
     * Updates classifications to an existing setSchemaType represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the setSchemaType
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given setSchemaType guid
     */
    public SetSchemaType updateSetSchemaTypeClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateSetSchemaTypeClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           SetSchemaType  setSchemaTypeClassificationBeans = SetSchemaTypeMapper.mapOmrsEntityDetailToSetSchemaType(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  setSchemaTypeClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing setSchemaType represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the setSchemaType
     * @param name name of the classification
     * @return deleted SetSchemaType  classification
     */
    public SetSchemaType deleteSetSchemaTypeClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteSetSchemaTypeClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       SetSchemaType declassifiedSetSchemaType =  SetSchemaTypeMapper.mapOmrsEntityDetailToSetSchemaType(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedSetSchemaType;
    }

    /**
      * Get the relationships associated with entity setSchemaType represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the setSchemaType
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getSetSchemaTypeRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getSetSchemaTypeRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an objectAttribute given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the objectAttributes relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return ObjectAttribute the ObjectAttribute entity with the requested GUID
     */
    public ObjectAttribute getObjectAttribute(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getObjectAttribute";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        ObjectAttribute gotobjectAttribute = ObjectAttributeMapper.mapOmrsEntityDetailToObjectAttribute(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotobjectAttribute );
        }
        return gotobjectAttribute;

    }
    /**
     * Create new objectAttribute.
     * @param userId user identity
     * @param objectAttribute the input entity with values.
     * @return ObjectAttribute the created entity.
     */

    public ObjectAttribute createObjectAttribute(String userId,ObjectAttribute objectAttribute)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createObjectAttribute";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = ObjectAttributeMapper.mapObjectAttributeToOmrsEntityDetail(objectAttribute);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        ObjectAttribute createdObjectAttribute =  ObjectAttributeMapper.mapOmrsEntityDetailToObjectAttribute(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created ObjectAttribute="+ createdObjectAttribute );
        }
        return createdObjectAttribute;
    }
    /**
     * Update objectAttribute
     * @param userId user identity
     * @param objectAttribute   objectAttribute to update
     * @return ObjectAttribute the updated objectAttribute entity
     */
    public ObjectAttribute updateObjectAttribute(String userId, ObjectAttribute objectAttribute)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateObjectAttribute";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = ObjectAttributeMapper.mapObjectAttributeToOmrsEntityDetail(objectAttribute);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            ObjectAttribute updatedObjectAttribute =  ObjectAttributeMapper.mapOmrsEntityDetailToObjectAttribute(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated ObjectAttribute="+ updatedObjectAttribute );
            }
            return updatedObjectAttribute;
        }

    /**
     * Delete an objectAttribute identified by its GUID. Delete is a soft delete, this means that the objectAttribute has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the objectAttribute
     * @return ObjectAttribute the deleted ObjectAttribute entity
     */

    public ObjectAttribute deleteObjectAttribute(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteObjectAttribute";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ObjectAttribute type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ObjectAttribute");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"ObjectAttribute",entityDef.getGUID(),entityGuid);
         ObjectAttribute deletedObjectAttribute = ObjectAttributeMapper.mapOmrsEntityDetailToObjectAttribute(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedObjectAttribute;

    }
    /**
     * Purge an objectAttribute identified by its GUID. Delete is a hard delete, this means that the objectAttribute is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the objectAttribute
     */
    public void purgeObjectAttribute(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeObjectAttribute";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ObjectAttribute type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ObjectAttribute");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"ObjectAttribute",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an ObjectAttribute identified by its GUID. Restore resurrects a soft deleted ObjectAttribute. When a ObjectAttribute was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the ObjectAttribute
     * @return  ObjectAttribute the restored ObjectAttribute
     */
    public ObjectAttribute restoreObjectAttribute(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreObjectAttribute";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        ObjectAttribute restoredObjectAttribute =  ObjectAttributeMapper.mapOmrsEntityDetailToObjectAttribute(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredObjectAttribute;
    }    

    /**
     * Add classifications to the supplied objectAttribute
     * @param userId user identity
     * @param entityGuid the GUID value for objectAttribute
     * @param classifications the classifications to apply.
     * @return the objectAttribute entity that has been classified
     */
     public ObjectAttribute addObjectAttributeClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addObjectAttributeClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         ObjectAttribute objectAttributeClassificationBeans = ObjectAttributeMapper.mapOmrsEntityDetailToObjectAttribute(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified ObjectAttribute=" +  objectAttributeClassificationBeans);
         }
         return  objectAttributeClassificationBeans;
    }

    /**
     * Updates classifications to an existing objectAttribute represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the objectAttribute
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given objectAttribute guid
     */
    public ObjectAttribute updateObjectAttributeClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateObjectAttributeClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           ObjectAttribute  objectAttributeClassificationBeans = ObjectAttributeMapper.mapOmrsEntityDetailToObjectAttribute(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  objectAttributeClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing objectAttribute represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the objectAttribute
     * @param name name of the classification
     * @return deleted ObjectAttribute  classification
     */
    public ObjectAttribute deleteObjectAttributeClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteObjectAttributeClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       ObjectAttribute declassifiedObjectAttribute =  ObjectAttributeMapper.mapOmrsEntityDetailToObjectAttribute(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedObjectAttribute;
    }

    /**
      * Get the relationships associated with entity objectAttribute represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the objectAttribute
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getObjectAttributeRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getObjectAttributeRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an governanceProcedure given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the governanceProcedures relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return GovernanceProcedure the GovernanceProcedure entity with the requested GUID
     */
    public GovernanceProcedure getGovernanceProcedure(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getGovernanceProcedure";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        GovernanceProcedure gotgovernanceProcedure = GovernanceProcedureMapper.mapOmrsEntityDetailToGovernanceProcedure(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotgovernanceProcedure );
        }
        return gotgovernanceProcedure;

    }
    /**
     * Create new governanceProcedure.
     * @param userId user identity
     * @param governanceProcedure the input entity with values.
     * @return GovernanceProcedure the created entity.
     */

    public GovernanceProcedure createGovernanceProcedure(String userId,GovernanceProcedure governanceProcedure)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createGovernanceProcedure";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = GovernanceProcedureMapper.mapGovernanceProcedureToOmrsEntityDetail(governanceProcedure);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        GovernanceProcedure createdGovernanceProcedure =  GovernanceProcedureMapper.mapOmrsEntityDetailToGovernanceProcedure(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created GovernanceProcedure="+ createdGovernanceProcedure );
        }
        return createdGovernanceProcedure;
    }
    /**
     * Update governanceProcedure
     * @param userId user identity
     * @param governanceProcedure   governanceProcedure to update
     * @return GovernanceProcedure the updated governanceProcedure entity
     */
    public GovernanceProcedure updateGovernanceProcedure(String userId, GovernanceProcedure governanceProcedure)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateGovernanceProcedure";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = GovernanceProcedureMapper.mapGovernanceProcedureToOmrsEntityDetail(governanceProcedure);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            GovernanceProcedure updatedGovernanceProcedure =  GovernanceProcedureMapper.mapOmrsEntityDetailToGovernanceProcedure(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated GovernanceProcedure="+ updatedGovernanceProcedure );
            }
            return updatedGovernanceProcedure;
        }

    /**
     * Delete an governanceProcedure identified by its GUID. Delete is a soft delete, this means that the governanceProcedure has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the governanceProcedure
     * @return GovernanceProcedure the deleted GovernanceProcedure entity
     */

    public GovernanceProcedure deleteGovernanceProcedure(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteGovernanceProcedure";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GovernanceProcedure type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GovernanceProcedure");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"GovernanceProcedure",entityDef.getGUID(),entityGuid);
         GovernanceProcedure deletedGovernanceProcedure = GovernanceProcedureMapper.mapOmrsEntityDetailToGovernanceProcedure(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedGovernanceProcedure;

    }
    /**
     * Purge an governanceProcedure identified by its GUID. Delete is a hard delete, this means that the governanceProcedure is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the governanceProcedure
     */
    public void purgeGovernanceProcedure(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeGovernanceProcedure";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GovernanceProcedure type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GovernanceProcedure");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"GovernanceProcedure",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an GovernanceProcedure identified by its GUID. Restore resurrects a soft deleted GovernanceProcedure. When a GovernanceProcedure was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the GovernanceProcedure
     * @return  GovernanceProcedure the restored GovernanceProcedure
     */
    public GovernanceProcedure restoreGovernanceProcedure(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreGovernanceProcedure";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        GovernanceProcedure restoredGovernanceProcedure =  GovernanceProcedureMapper.mapOmrsEntityDetailToGovernanceProcedure(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredGovernanceProcedure;
    }    

    /**
     * Add classifications to the supplied governanceProcedure
     * @param userId user identity
     * @param entityGuid the GUID value for governanceProcedure
     * @param classifications the classifications to apply.
     * @return the governanceProcedure entity that has been classified
     */
     public GovernanceProcedure addGovernanceProcedureClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addGovernanceProcedureClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         GovernanceProcedure governanceProcedureClassificationBeans = GovernanceProcedureMapper.mapOmrsEntityDetailToGovernanceProcedure(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified GovernanceProcedure=" +  governanceProcedureClassificationBeans);
         }
         return  governanceProcedureClassificationBeans;
    }

    /**
     * Updates classifications to an existing governanceProcedure represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the governanceProcedure
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given governanceProcedure guid
     */
    public GovernanceProcedure updateGovernanceProcedureClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateGovernanceProcedureClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           GovernanceProcedure  governanceProcedureClassificationBeans = GovernanceProcedureMapper.mapOmrsEntityDetailToGovernanceProcedure(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  governanceProcedureClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing governanceProcedure represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the governanceProcedure
     * @param name name of the classification
     * @return deleted GovernanceProcedure  classification
     */
    public GovernanceProcedure deleteGovernanceProcedureClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteGovernanceProcedureClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       GovernanceProcedure declassifiedGovernanceProcedure =  GovernanceProcedureMapper.mapOmrsEntityDetailToGovernanceProcedure(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedGovernanceProcedure;
    }

    /**
      * Get the relationships associated with entity governanceProcedure represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the governanceProcedure
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getGovernanceProcedureRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getGovernanceProcedureRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an semanticAnnotation given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the semanticAnnotations relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return SemanticAnnotation the SemanticAnnotation entity with the requested GUID
     */
    public SemanticAnnotation getSemanticAnnotation(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getSemanticAnnotation";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        SemanticAnnotation gotsemanticAnnotation = SemanticAnnotationMapper.mapOmrsEntityDetailToSemanticAnnotation(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotsemanticAnnotation );
        }
        return gotsemanticAnnotation;

    }
    /**
     * Create new semanticAnnotation.
     * @param userId user identity
     * @param semanticAnnotation the input entity with values.
     * @return SemanticAnnotation the created entity.
     */

    public SemanticAnnotation createSemanticAnnotation(String userId,SemanticAnnotation semanticAnnotation)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createSemanticAnnotation";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = SemanticAnnotationMapper.mapSemanticAnnotationToOmrsEntityDetail(semanticAnnotation);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        SemanticAnnotation createdSemanticAnnotation =  SemanticAnnotationMapper.mapOmrsEntityDetailToSemanticAnnotation(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created SemanticAnnotation="+ createdSemanticAnnotation );
        }
        return createdSemanticAnnotation;
    }
    /**
     * Update semanticAnnotation
     * @param userId user identity
     * @param semanticAnnotation   semanticAnnotation to update
     * @return SemanticAnnotation the updated semanticAnnotation entity
     */
    public SemanticAnnotation updateSemanticAnnotation(String userId, SemanticAnnotation semanticAnnotation)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateSemanticAnnotation";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = SemanticAnnotationMapper.mapSemanticAnnotationToOmrsEntityDetail(semanticAnnotation);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            SemanticAnnotation updatedSemanticAnnotation =  SemanticAnnotationMapper.mapOmrsEntityDetailToSemanticAnnotation(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated SemanticAnnotation="+ updatedSemanticAnnotation );
            }
            return updatedSemanticAnnotation;
        }

    /**
     * Delete an semanticAnnotation identified by its GUID. Delete is a soft delete, this means that the semanticAnnotation has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the semanticAnnotation
     * @return SemanticAnnotation the deleted SemanticAnnotation entity
     */

    public SemanticAnnotation deleteSemanticAnnotation(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteSemanticAnnotation";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the SemanticAnnotation type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("SemanticAnnotation");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"SemanticAnnotation",entityDef.getGUID(),entityGuid);
         SemanticAnnotation deletedSemanticAnnotation = SemanticAnnotationMapper.mapOmrsEntityDetailToSemanticAnnotation(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedSemanticAnnotation;

    }
    /**
     * Purge an semanticAnnotation identified by its GUID. Delete is a hard delete, this means that the semanticAnnotation is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the semanticAnnotation
     */
    public void purgeSemanticAnnotation(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeSemanticAnnotation";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the SemanticAnnotation type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("SemanticAnnotation");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"SemanticAnnotation",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an SemanticAnnotation identified by its GUID. Restore resurrects a soft deleted SemanticAnnotation. When a SemanticAnnotation was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the SemanticAnnotation
     * @return  SemanticAnnotation the restored SemanticAnnotation
     */
    public SemanticAnnotation restoreSemanticAnnotation(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreSemanticAnnotation";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        SemanticAnnotation restoredSemanticAnnotation =  SemanticAnnotationMapper.mapOmrsEntityDetailToSemanticAnnotation(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredSemanticAnnotation;
    }    

    /**
     * Add classifications to the supplied semanticAnnotation
     * @param userId user identity
     * @param entityGuid the GUID value for semanticAnnotation
     * @param classifications the classifications to apply.
     * @return the semanticAnnotation entity that has been classified
     */
     public SemanticAnnotation addSemanticAnnotationClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addSemanticAnnotationClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         SemanticAnnotation semanticAnnotationClassificationBeans = SemanticAnnotationMapper.mapOmrsEntityDetailToSemanticAnnotation(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified SemanticAnnotation=" +  semanticAnnotationClassificationBeans);
         }
         return  semanticAnnotationClassificationBeans;
    }

    /**
     * Updates classifications to an existing semanticAnnotation represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the semanticAnnotation
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given semanticAnnotation guid
     */
    public SemanticAnnotation updateSemanticAnnotationClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateSemanticAnnotationClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           SemanticAnnotation  semanticAnnotationClassificationBeans = SemanticAnnotationMapper.mapOmrsEntityDetailToSemanticAnnotation(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  semanticAnnotationClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing semanticAnnotation represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the semanticAnnotation
     * @param name name of the classification
     * @return deleted SemanticAnnotation  classification
     */
    public SemanticAnnotation deleteSemanticAnnotationClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteSemanticAnnotationClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       SemanticAnnotation declassifiedSemanticAnnotation =  SemanticAnnotationMapper.mapOmrsEntityDetailToSemanticAnnotation(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedSemanticAnnotation;
    }

    /**
      * Get the relationships associated with entity semanticAnnotation represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the semanticAnnotation
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getSemanticAnnotationRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getSemanticAnnotationRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an assetOwner given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the assetOwners relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return AssetOwner the AssetOwner entity with the requested GUID
     */
    public AssetOwner getAssetOwner(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getAssetOwner";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        AssetOwner gotassetOwner = AssetOwnerMapper.mapOmrsEntityDetailToAssetOwner(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotassetOwner );
        }
        return gotassetOwner;

    }
    /**
     * Create new assetOwner.
     * @param userId user identity
     * @param assetOwner the input entity with values.
     * @return AssetOwner the created entity.
     */

    public AssetOwner createAssetOwner(String userId,AssetOwner assetOwner)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createAssetOwner";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = AssetOwnerMapper.mapAssetOwnerToOmrsEntityDetail(assetOwner);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        AssetOwner createdAssetOwner =  AssetOwnerMapper.mapOmrsEntityDetailToAssetOwner(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created AssetOwner="+ createdAssetOwner );
        }
        return createdAssetOwner;
    }
    /**
     * Update assetOwner
     * @param userId user identity
     * @param assetOwner   assetOwner to update
     * @return AssetOwner the updated assetOwner entity
     */
    public AssetOwner updateAssetOwner(String userId, AssetOwner assetOwner)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateAssetOwner";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = AssetOwnerMapper.mapAssetOwnerToOmrsEntityDetail(assetOwner);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            AssetOwner updatedAssetOwner =  AssetOwnerMapper.mapOmrsEntityDetailToAssetOwner(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated AssetOwner="+ updatedAssetOwner );
            }
            return updatedAssetOwner;
        }

    /**
     * Delete an assetOwner identified by its GUID. Delete is a soft delete, this means that the assetOwner has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the assetOwner
     * @return AssetOwner the deleted AssetOwner entity
     */

    public AssetOwner deleteAssetOwner(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteAssetOwner";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the AssetOwner type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("AssetOwner");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"AssetOwner",entityDef.getGUID(),entityGuid);
         AssetOwner deletedAssetOwner = AssetOwnerMapper.mapOmrsEntityDetailToAssetOwner(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedAssetOwner;

    }
    /**
     * Purge an assetOwner identified by its GUID. Delete is a hard delete, this means that the assetOwner is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the assetOwner
     */
    public void purgeAssetOwner(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeAssetOwner";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the AssetOwner type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("AssetOwner");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"AssetOwner",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an AssetOwner identified by its GUID. Restore resurrects a soft deleted AssetOwner. When a AssetOwner was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the AssetOwner
     * @return  AssetOwner the restored AssetOwner
     */
    public AssetOwner restoreAssetOwner(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreAssetOwner";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        AssetOwner restoredAssetOwner =  AssetOwnerMapper.mapOmrsEntityDetailToAssetOwner(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredAssetOwner;
    }    

    /**
     * Add classifications to the supplied assetOwner
     * @param userId user identity
     * @param entityGuid the GUID value for assetOwner
     * @param classifications the classifications to apply.
     * @return the assetOwner entity that has been classified
     */
     public AssetOwner addAssetOwnerClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addAssetOwnerClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         AssetOwner assetOwnerClassificationBeans = AssetOwnerMapper.mapOmrsEntityDetailToAssetOwner(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified AssetOwner=" +  assetOwnerClassificationBeans);
         }
         return  assetOwnerClassificationBeans;
    }

    /**
     * Updates classifications to an existing assetOwner represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the assetOwner
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given assetOwner guid
     */
    public AssetOwner updateAssetOwnerClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateAssetOwnerClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           AssetOwner  assetOwnerClassificationBeans = AssetOwnerMapper.mapOmrsEntityDetailToAssetOwner(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  assetOwnerClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing assetOwner represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the assetOwner
     * @param name name of the classification
     * @return deleted AssetOwner  classification
     */
    public AssetOwner deleteAssetOwnerClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteAssetOwnerClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       AssetOwner declassifiedAssetOwner =  AssetOwnerMapper.mapOmrsEntityDetailToAssetOwner(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedAssetOwner;
    }

    /**
      * Get the relationships associated with entity assetOwner represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the assetOwner
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getAssetOwnerRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getAssetOwnerRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an networkGateway given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the networkGatewaies relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return NetworkGateway the NetworkGateway entity with the requested GUID
     */
    public NetworkGateway getNetworkGateway(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getNetworkGateway";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        NetworkGateway gotnetworkGateway = NetworkGatewayMapper.mapOmrsEntityDetailToNetworkGateway(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotnetworkGateway );
        }
        return gotnetworkGateway;

    }
    /**
     * Create new networkGateway.
     * @param userId user identity
     * @param networkGateway the input entity with values.
     * @return NetworkGateway the created entity.
     */

    public NetworkGateway createNetworkGateway(String userId,NetworkGateway networkGateway)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createNetworkGateway";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = NetworkGatewayMapper.mapNetworkGatewayToOmrsEntityDetail(networkGateway);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        NetworkGateway createdNetworkGateway =  NetworkGatewayMapper.mapOmrsEntityDetailToNetworkGateway(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created NetworkGateway="+ createdNetworkGateway );
        }
        return createdNetworkGateway;
    }
    /**
     * Update networkGateway
     * @param userId user identity
     * @param networkGateway   networkGateway to update
     * @return NetworkGateway the updated networkGateway entity
     */
    public NetworkGateway updateNetworkGateway(String userId, NetworkGateway networkGateway)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateNetworkGateway";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = NetworkGatewayMapper.mapNetworkGatewayToOmrsEntityDetail(networkGateway);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            NetworkGateway updatedNetworkGateway =  NetworkGatewayMapper.mapOmrsEntityDetailToNetworkGateway(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated NetworkGateway="+ updatedNetworkGateway );
            }
            return updatedNetworkGateway;
        }

    /**
     * Delete an networkGateway identified by its GUID. Delete is a soft delete, this means that the networkGateway has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the networkGateway
     * @return NetworkGateway the deleted NetworkGateway entity
     */

    public NetworkGateway deleteNetworkGateway(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteNetworkGateway";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the NetworkGateway type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("NetworkGateway");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"NetworkGateway",entityDef.getGUID(),entityGuid);
         NetworkGateway deletedNetworkGateway = NetworkGatewayMapper.mapOmrsEntityDetailToNetworkGateway(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedNetworkGateway;

    }
    /**
     * Purge an networkGateway identified by its GUID. Delete is a hard delete, this means that the networkGateway is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the networkGateway
     */
    public void purgeNetworkGateway(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeNetworkGateway";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the NetworkGateway type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("NetworkGateway");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"NetworkGateway",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an NetworkGateway identified by its GUID. Restore resurrects a soft deleted NetworkGateway. When a NetworkGateway was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the NetworkGateway
     * @return  NetworkGateway the restored NetworkGateway
     */
    public NetworkGateway restoreNetworkGateway(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreNetworkGateway";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        NetworkGateway restoredNetworkGateway =  NetworkGatewayMapper.mapOmrsEntityDetailToNetworkGateway(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredNetworkGateway;
    }    

    /**
     * Add classifications to the supplied networkGateway
     * @param userId user identity
     * @param entityGuid the GUID value for networkGateway
     * @param classifications the classifications to apply.
     * @return the networkGateway entity that has been classified
     */
     public NetworkGateway addNetworkGatewayClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addNetworkGatewayClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         NetworkGateway networkGatewayClassificationBeans = NetworkGatewayMapper.mapOmrsEntityDetailToNetworkGateway(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified NetworkGateway=" +  networkGatewayClassificationBeans);
         }
         return  networkGatewayClassificationBeans;
    }

    /**
     * Updates classifications to an existing networkGateway represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the networkGateway
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given networkGateway guid
     */
    public NetworkGateway updateNetworkGatewayClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateNetworkGatewayClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           NetworkGateway  networkGatewayClassificationBeans = NetworkGatewayMapper.mapOmrsEntityDetailToNetworkGateway(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  networkGatewayClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing networkGateway represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the networkGateway
     * @param name name of the classification
     * @return deleted NetworkGateway  classification
     */
    public NetworkGateway deleteNetworkGatewayClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteNetworkGatewayClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       NetworkGateway declassifiedNetworkGateway =  NetworkGatewayMapper.mapOmrsEntityDetailToNetworkGateway(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedNetworkGateway;
    }

    /**
      * Get the relationships associated with entity networkGateway represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the networkGateway
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getNetworkGatewayRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getNetworkGatewayRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an implementationSnippet given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the implementationSnippets relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return ImplementationSnippet the ImplementationSnippet entity with the requested GUID
     */
    public ImplementationSnippet getImplementationSnippet(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getImplementationSnippet";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        ImplementationSnippet gotimplementationSnippet = ImplementationSnippetMapper.mapOmrsEntityDetailToImplementationSnippet(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotimplementationSnippet );
        }
        return gotimplementationSnippet;

    }
    /**
     * Create new implementationSnippet.
     * @param userId user identity
     * @param implementationSnippet the input entity with values.
     * @return ImplementationSnippet the created entity.
     */

    public ImplementationSnippet createImplementationSnippet(String userId,ImplementationSnippet implementationSnippet)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createImplementationSnippet";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = ImplementationSnippetMapper.mapImplementationSnippetToOmrsEntityDetail(implementationSnippet);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        ImplementationSnippet createdImplementationSnippet =  ImplementationSnippetMapper.mapOmrsEntityDetailToImplementationSnippet(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created ImplementationSnippet="+ createdImplementationSnippet );
        }
        return createdImplementationSnippet;
    }
    /**
     * Update implementationSnippet
     * @param userId user identity
     * @param implementationSnippet   implementationSnippet to update
     * @return ImplementationSnippet the updated implementationSnippet entity
     */
    public ImplementationSnippet updateImplementationSnippet(String userId, ImplementationSnippet implementationSnippet)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateImplementationSnippet";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = ImplementationSnippetMapper.mapImplementationSnippetToOmrsEntityDetail(implementationSnippet);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            ImplementationSnippet updatedImplementationSnippet =  ImplementationSnippetMapper.mapOmrsEntityDetailToImplementationSnippet(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated ImplementationSnippet="+ updatedImplementationSnippet );
            }
            return updatedImplementationSnippet;
        }

    /**
     * Delete an implementationSnippet identified by its GUID. Delete is a soft delete, this means that the implementationSnippet has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the implementationSnippet
     * @return ImplementationSnippet the deleted ImplementationSnippet entity
     */

    public ImplementationSnippet deleteImplementationSnippet(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteImplementationSnippet";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ImplementationSnippet type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ImplementationSnippet");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"ImplementationSnippet",entityDef.getGUID(),entityGuid);
         ImplementationSnippet deletedImplementationSnippet = ImplementationSnippetMapper.mapOmrsEntityDetailToImplementationSnippet(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedImplementationSnippet;

    }
    /**
     * Purge an implementationSnippet identified by its GUID. Delete is a hard delete, this means that the implementationSnippet is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the implementationSnippet
     */
    public void purgeImplementationSnippet(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeImplementationSnippet";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ImplementationSnippet type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ImplementationSnippet");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"ImplementationSnippet",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an ImplementationSnippet identified by its GUID. Restore resurrects a soft deleted ImplementationSnippet. When a ImplementationSnippet was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the ImplementationSnippet
     * @return  ImplementationSnippet the restored ImplementationSnippet
     */
    public ImplementationSnippet restoreImplementationSnippet(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreImplementationSnippet";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        ImplementationSnippet restoredImplementationSnippet =  ImplementationSnippetMapper.mapOmrsEntityDetailToImplementationSnippet(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredImplementationSnippet;
    }    

    /**
     * Add classifications to the supplied implementationSnippet
     * @param userId user identity
     * @param entityGuid the GUID value for implementationSnippet
     * @param classifications the classifications to apply.
     * @return the implementationSnippet entity that has been classified
     */
     public ImplementationSnippet addImplementationSnippetClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addImplementationSnippetClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         ImplementationSnippet implementationSnippetClassificationBeans = ImplementationSnippetMapper.mapOmrsEntityDetailToImplementationSnippet(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified ImplementationSnippet=" +  implementationSnippetClassificationBeans);
         }
         return  implementationSnippetClassificationBeans;
    }

    /**
     * Updates classifications to an existing implementationSnippet represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the implementationSnippet
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given implementationSnippet guid
     */
    public ImplementationSnippet updateImplementationSnippetClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateImplementationSnippetClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           ImplementationSnippet  implementationSnippetClassificationBeans = ImplementationSnippetMapper.mapOmrsEntityDetailToImplementationSnippet(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  implementationSnippetClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing implementationSnippet represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the implementationSnippet
     * @param name name of the classification
     * @return deleted ImplementationSnippet  classification
     */
    public ImplementationSnippet deleteImplementationSnippetClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteImplementationSnippetClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       ImplementationSnippet declassifiedImplementationSnippet =  ImplementationSnippetMapper.mapOmrsEntityDetailToImplementationSnippet(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedImplementationSnippet;
    }

    /**
      * Get the relationships associated with entity implementationSnippet represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the implementationSnippet
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getImplementationSnippetRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getImplementationSnippetRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an relationalTable given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the relationalTables relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return RelationalTable the RelationalTable entity with the requested GUID
     */
    public RelationalTable getRelationalTable(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getRelationalTable";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        RelationalTable gotrelationalTable = RelationalTableMapper.mapOmrsEntityDetailToRelationalTable(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotrelationalTable );
        }
        return gotrelationalTable;

    }
    /**
     * Create new relationalTable.
     * @param userId user identity
     * @param relationalTable the input entity with values.
     * @return RelationalTable the created entity.
     */

    public RelationalTable createRelationalTable(String userId,RelationalTable relationalTable)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createRelationalTable";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = RelationalTableMapper.mapRelationalTableToOmrsEntityDetail(relationalTable);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        RelationalTable createdRelationalTable =  RelationalTableMapper.mapOmrsEntityDetailToRelationalTable(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created RelationalTable="+ createdRelationalTable );
        }
        return createdRelationalTable;
    }
    /**
     * Update relationalTable
     * @param userId user identity
     * @param relationalTable   relationalTable to update
     * @return RelationalTable the updated relationalTable entity
     */
    public RelationalTable updateRelationalTable(String userId, RelationalTable relationalTable)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateRelationalTable";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = RelationalTableMapper.mapRelationalTableToOmrsEntityDetail(relationalTable);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            RelationalTable updatedRelationalTable =  RelationalTableMapper.mapOmrsEntityDetailToRelationalTable(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated RelationalTable="+ updatedRelationalTable );
            }
            return updatedRelationalTable;
        }

    /**
     * Delete an relationalTable identified by its GUID. Delete is a soft delete, this means that the relationalTable has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the relationalTable
     * @return RelationalTable the deleted RelationalTable entity
     */

    public RelationalTable deleteRelationalTable(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteRelationalTable";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the RelationalTable type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("RelationalTable");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"RelationalTable",entityDef.getGUID(),entityGuid);
         RelationalTable deletedRelationalTable = RelationalTableMapper.mapOmrsEntityDetailToRelationalTable(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedRelationalTable;

    }
    /**
     * Purge an relationalTable identified by its GUID. Delete is a hard delete, this means that the relationalTable is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the relationalTable
     */
    public void purgeRelationalTable(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeRelationalTable";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the RelationalTable type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("RelationalTable");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"RelationalTable",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an RelationalTable identified by its GUID. Restore resurrects a soft deleted RelationalTable. When a RelationalTable was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the RelationalTable
     * @return  RelationalTable the restored RelationalTable
     */
    public RelationalTable restoreRelationalTable(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreRelationalTable";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        RelationalTable restoredRelationalTable =  RelationalTableMapper.mapOmrsEntityDetailToRelationalTable(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredRelationalTable;
    }    

    /**
     * Add classifications to the supplied relationalTable
     * @param userId user identity
     * @param entityGuid the GUID value for relationalTable
     * @param classifications the classifications to apply.
     * @return the relationalTable entity that has been classified
     */
     public RelationalTable addRelationalTableClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addRelationalTableClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         RelationalTable relationalTableClassificationBeans = RelationalTableMapper.mapOmrsEntityDetailToRelationalTable(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified RelationalTable=" +  relationalTableClassificationBeans);
         }
         return  relationalTableClassificationBeans;
    }

    /**
     * Updates classifications to an existing relationalTable represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the relationalTable
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given relationalTable guid
     */
    public RelationalTable updateRelationalTableClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateRelationalTableClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           RelationalTable  relationalTableClassificationBeans = RelationalTableMapper.mapOmrsEntityDetailToRelationalTable(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  relationalTableClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing relationalTable represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the relationalTable
     * @param name name of the classification
     * @return deleted RelationalTable  classification
     */
    public RelationalTable deleteRelationalTableClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteRelationalTableClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       RelationalTable declassifiedRelationalTable =  RelationalTableMapper.mapOmrsEntityDetailToRelationalTable(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedRelationalTable;
    }

    /**
      * Get the relationships associated with entity relationalTable represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the relationalTable
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getRelationalTableRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getRelationalTableRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an userIdentity given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the userIdentities relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return UserIdentity the UserIdentity entity with the requested GUID
     */
    public UserIdentity getUserIdentity(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getUserIdentity";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        UserIdentity gotuserIdentity = UserIdentityMapper.mapOmrsEntityDetailToUserIdentity(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotuserIdentity );
        }
        return gotuserIdentity;

    }
    /**
     * Create new userIdentity.
     * @param userId user identity
     * @param userIdentity the input entity with values.
     * @return UserIdentity the created entity.
     */

    public UserIdentity createUserIdentity(String userId,UserIdentity userIdentity)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createUserIdentity";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = UserIdentityMapper.mapUserIdentityToOmrsEntityDetail(userIdentity);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        UserIdentity createdUserIdentity =  UserIdentityMapper.mapOmrsEntityDetailToUserIdentity(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created UserIdentity="+ createdUserIdentity );
        }
        return createdUserIdentity;
    }
    /**
     * Update userIdentity
     * @param userId user identity
     * @param userIdentity   userIdentity to update
     * @return UserIdentity the updated userIdentity entity
     */
    public UserIdentity updateUserIdentity(String userId, UserIdentity userIdentity)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateUserIdentity";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = UserIdentityMapper.mapUserIdentityToOmrsEntityDetail(userIdentity);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            UserIdentity updatedUserIdentity =  UserIdentityMapper.mapOmrsEntityDetailToUserIdentity(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated UserIdentity="+ updatedUserIdentity );
            }
            return updatedUserIdentity;
        }

    /**
     * Delete an userIdentity identified by its GUID. Delete is a soft delete, this means that the userIdentity has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the userIdentity
     * @return UserIdentity the deleted UserIdentity entity
     */

    public UserIdentity deleteUserIdentity(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteUserIdentity";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the UserIdentity type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("UserIdentity");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"UserIdentity",entityDef.getGUID(),entityGuid);
         UserIdentity deletedUserIdentity = UserIdentityMapper.mapOmrsEntityDetailToUserIdentity(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedUserIdentity;

    }
    /**
     * Purge an userIdentity identified by its GUID. Delete is a hard delete, this means that the userIdentity is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the userIdentity
     */
    public void purgeUserIdentity(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeUserIdentity";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the UserIdentity type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("UserIdentity");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"UserIdentity",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an UserIdentity identified by its GUID. Restore resurrects a soft deleted UserIdentity. When a UserIdentity was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the UserIdentity
     * @return  UserIdentity the restored UserIdentity
     */
    public UserIdentity restoreUserIdentity(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreUserIdentity";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        UserIdentity restoredUserIdentity =  UserIdentityMapper.mapOmrsEntityDetailToUserIdentity(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredUserIdentity;
    }    

    /**
     * Add classifications to the supplied userIdentity
     * @param userId user identity
     * @param entityGuid the GUID value for userIdentity
     * @param classifications the classifications to apply.
     * @return the userIdentity entity that has been classified
     */
     public UserIdentity addUserIdentityClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addUserIdentityClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         UserIdentity userIdentityClassificationBeans = UserIdentityMapper.mapOmrsEntityDetailToUserIdentity(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified UserIdentity=" +  userIdentityClassificationBeans);
         }
         return  userIdentityClassificationBeans;
    }

    /**
     * Updates classifications to an existing userIdentity represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the userIdentity
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given userIdentity guid
     */
    public UserIdentity updateUserIdentityClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateUserIdentityClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           UserIdentity  userIdentityClassificationBeans = UserIdentityMapper.mapOmrsEntityDetailToUserIdentity(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  userIdentityClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing userIdentity represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the userIdentity
     * @param name name of the classification
     * @return deleted UserIdentity  classification
     */
    public UserIdentity deleteUserIdentityClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteUserIdentityClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       UserIdentity declassifiedUserIdentity =  UserIdentityMapper.mapOmrsEntityDetailToUserIdentity(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedUserIdentity;
    }

    /**
      * Get the relationships associated with entity userIdentity represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the userIdentity
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getUserIdentityRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getUserIdentityRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an contributionRecord given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the contributionRecords relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return ContributionRecord the ContributionRecord entity with the requested GUID
     */
    public ContributionRecord getContributionRecord(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getContributionRecord";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        ContributionRecord gotcontributionRecord = ContributionRecordMapper.mapOmrsEntityDetailToContributionRecord(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotcontributionRecord );
        }
        return gotcontributionRecord;

    }
    /**
     * Create new contributionRecord.
     * @param userId user identity
     * @param contributionRecord the input entity with values.
     * @return ContributionRecord the created entity.
     */

    public ContributionRecord createContributionRecord(String userId,ContributionRecord contributionRecord)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createContributionRecord";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = ContributionRecordMapper.mapContributionRecordToOmrsEntityDetail(contributionRecord);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        ContributionRecord createdContributionRecord =  ContributionRecordMapper.mapOmrsEntityDetailToContributionRecord(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created ContributionRecord="+ createdContributionRecord );
        }
        return createdContributionRecord;
    }
    /**
     * Update contributionRecord
     * @param userId user identity
     * @param contributionRecord   contributionRecord to update
     * @return ContributionRecord the updated contributionRecord entity
     */
    public ContributionRecord updateContributionRecord(String userId, ContributionRecord contributionRecord)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateContributionRecord";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = ContributionRecordMapper.mapContributionRecordToOmrsEntityDetail(contributionRecord);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            ContributionRecord updatedContributionRecord =  ContributionRecordMapper.mapOmrsEntityDetailToContributionRecord(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated ContributionRecord="+ updatedContributionRecord );
            }
            return updatedContributionRecord;
        }

    /**
     * Delete an contributionRecord identified by its GUID. Delete is a soft delete, this means that the contributionRecord has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the contributionRecord
     * @return ContributionRecord the deleted ContributionRecord entity
     */

    public ContributionRecord deleteContributionRecord(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteContributionRecord";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ContributionRecord type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ContributionRecord");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"ContributionRecord",entityDef.getGUID(),entityGuid);
         ContributionRecord deletedContributionRecord = ContributionRecordMapper.mapOmrsEntityDetailToContributionRecord(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedContributionRecord;

    }
    /**
     * Purge an contributionRecord identified by its GUID. Delete is a hard delete, this means that the contributionRecord is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the contributionRecord
     */
    public void purgeContributionRecord(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeContributionRecord";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ContributionRecord type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ContributionRecord");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"ContributionRecord",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an ContributionRecord identified by its GUID. Restore resurrects a soft deleted ContributionRecord. When a ContributionRecord was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the ContributionRecord
     * @return  ContributionRecord the restored ContributionRecord
     */
    public ContributionRecord restoreContributionRecord(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreContributionRecord";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        ContributionRecord restoredContributionRecord =  ContributionRecordMapper.mapOmrsEntityDetailToContributionRecord(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredContributionRecord;
    }    

    /**
     * Add classifications to the supplied contributionRecord
     * @param userId user identity
     * @param entityGuid the GUID value for contributionRecord
     * @param classifications the classifications to apply.
     * @return the contributionRecord entity that has been classified
     */
     public ContributionRecord addContributionRecordClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addContributionRecordClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         ContributionRecord contributionRecordClassificationBeans = ContributionRecordMapper.mapOmrsEntityDetailToContributionRecord(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified ContributionRecord=" +  contributionRecordClassificationBeans);
         }
         return  contributionRecordClassificationBeans;
    }

    /**
     * Updates classifications to an existing contributionRecord represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the contributionRecord
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given contributionRecord guid
     */
    public ContributionRecord updateContributionRecordClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateContributionRecordClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           ContributionRecord  contributionRecordClassificationBeans = ContributionRecordMapper.mapOmrsEntityDetailToContributionRecord(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  contributionRecordClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing contributionRecord represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the contributionRecord
     * @param name name of the classification
     * @return deleted ContributionRecord  classification
     */
    public ContributionRecord deleteContributionRecordClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteContributionRecordClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       ContributionRecord declassifiedContributionRecord =  ContributionRecordMapper.mapOmrsEntityDetailToContributionRecord(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedContributionRecord;
    }

    /**
      * Get the relationships associated with entity contributionRecord represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the contributionRecord
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getContributionRecordRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getContributionRecordRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an structDocumentType given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the structDocumentTypes relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return StructDocumentType the StructDocumentType entity with the requested GUID
     */
    public StructDocumentType getStructDocumentType(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getStructDocumentType";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        StructDocumentType gotstructDocumentType = StructDocumentTypeMapper.mapOmrsEntityDetailToStructDocumentType(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotstructDocumentType );
        }
        return gotstructDocumentType;

    }
    /**
     * Create new structDocumentType.
     * @param userId user identity
     * @param structDocumentType the input entity with values.
     * @return StructDocumentType the created entity.
     */

    public StructDocumentType createStructDocumentType(String userId,StructDocumentType structDocumentType)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createStructDocumentType";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = StructDocumentTypeMapper.mapStructDocumentTypeToOmrsEntityDetail(structDocumentType);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        StructDocumentType createdStructDocumentType =  StructDocumentTypeMapper.mapOmrsEntityDetailToStructDocumentType(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created StructDocumentType="+ createdStructDocumentType );
        }
        return createdStructDocumentType;
    }
    /**
     * Update structDocumentType
     * @param userId user identity
     * @param structDocumentType   structDocumentType to update
     * @return StructDocumentType the updated structDocumentType entity
     */
    public StructDocumentType updateStructDocumentType(String userId, StructDocumentType structDocumentType)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateStructDocumentType";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = StructDocumentTypeMapper.mapStructDocumentTypeToOmrsEntityDetail(structDocumentType);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            StructDocumentType updatedStructDocumentType =  StructDocumentTypeMapper.mapOmrsEntityDetailToStructDocumentType(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated StructDocumentType="+ updatedStructDocumentType );
            }
            return updatedStructDocumentType;
        }

    /**
     * Delete an structDocumentType identified by its GUID. Delete is a soft delete, this means that the structDocumentType has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the structDocumentType
     * @return StructDocumentType the deleted StructDocumentType entity
     */

    public StructDocumentType deleteStructDocumentType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteStructDocumentType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the StructDocumentType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("StructDocumentType");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"StructDocumentType",entityDef.getGUID(),entityGuid);
         StructDocumentType deletedStructDocumentType = StructDocumentTypeMapper.mapOmrsEntityDetailToStructDocumentType(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedStructDocumentType;

    }
    /**
     * Purge an structDocumentType identified by its GUID. Delete is a hard delete, this means that the structDocumentType is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the structDocumentType
     */
    public void purgeStructDocumentType(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeStructDocumentType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the StructDocumentType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("StructDocumentType");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"StructDocumentType",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an StructDocumentType identified by its GUID. Restore resurrects a soft deleted StructDocumentType. When a StructDocumentType was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the StructDocumentType
     * @return  StructDocumentType the restored StructDocumentType
     */
    public StructDocumentType restoreStructDocumentType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreStructDocumentType";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        StructDocumentType restoredStructDocumentType =  StructDocumentTypeMapper.mapOmrsEntityDetailToStructDocumentType(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredStructDocumentType;
    }    

    /**
     * Add classifications to the supplied structDocumentType
     * @param userId user identity
     * @param entityGuid the GUID value for structDocumentType
     * @param classifications the classifications to apply.
     * @return the structDocumentType entity that has been classified
     */
     public StructDocumentType addStructDocumentTypeClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addStructDocumentTypeClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         StructDocumentType structDocumentTypeClassificationBeans = StructDocumentTypeMapper.mapOmrsEntityDetailToStructDocumentType(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified StructDocumentType=" +  structDocumentTypeClassificationBeans);
         }
         return  structDocumentTypeClassificationBeans;
    }

    /**
     * Updates classifications to an existing structDocumentType represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the structDocumentType
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given structDocumentType guid
     */
    public StructDocumentType updateStructDocumentTypeClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateStructDocumentTypeClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           StructDocumentType  structDocumentTypeClassificationBeans = StructDocumentTypeMapper.mapOmrsEntityDetailToStructDocumentType(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  structDocumentTypeClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing structDocumentType represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the structDocumentType
     * @param name name of the classification
     * @return deleted StructDocumentType  classification
     */
    public StructDocumentType deleteStructDocumentTypeClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteStructDocumentTypeClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       StructDocumentType declassifiedStructDocumentType =  StructDocumentTypeMapper.mapOmrsEntityDetailToStructDocumentType(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedStructDocumentType;
    }

    /**
      * Get the relationships associated with entity structDocumentType represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the structDocumentType
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getStructDocumentTypeRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getStructDocumentTypeRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an requestForAction given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the requestForActions relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return RequestForAction the RequestForAction entity with the requested GUID
     */
    public RequestForAction getRequestForAction(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getRequestForAction";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        RequestForAction gotrequestForAction = RequestForActionMapper.mapOmrsEntityDetailToRequestForAction(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotrequestForAction );
        }
        return gotrequestForAction;

    }
    /**
     * Create new requestForAction.
     * @param userId user identity
     * @param requestForAction the input entity with values.
     * @return RequestForAction the created entity.
     */

    public RequestForAction createRequestForAction(String userId,RequestForAction requestForAction)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createRequestForAction";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = RequestForActionMapper.mapRequestForActionToOmrsEntityDetail(requestForAction);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        RequestForAction createdRequestForAction =  RequestForActionMapper.mapOmrsEntityDetailToRequestForAction(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created RequestForAction="+ createdRequestForAction );
        }
        return createdRequestForAction;
    }
    /**
     * Update requestForAction
     * @param userId user identity
     * @param requestForAction   requestForAction to update
     * @return RequestForAction the updated requestForAction entity
     */
    public RequestForAction updateRequestForAction(String userId, RequestForAction requestForAction)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateRequestForAction";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = RequestForActionMapper.mapRequestForActionToOmrsEntityDetail(requestForAction);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            RequestForAction updatedRequestForAction =  RequestForActionMapper.mapOmrsEntityDetailToRequestForAction(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated RequestForAction="+ updatedRequestForAction );
            }
            return updatedRequestForAction;
        }

    /**
     * Delete an requestForAction identified by its GUID. Delete is a soft delete, this means that the requestForAction has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the requestForAction
     * @return RequestForAction the deleted RequestForAction entity
     */

    public RequestForAction deleteRequestForAction(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteRequestForAction";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the RequestForAction type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("RequestForAction");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"RequestForAction",entityDef.getGUID(),entityGuid);
         RequestForAction deletedRequestForAction = RequestForActionMapper.mapOmrsEntityDetailToRequestForAction(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedRequestForAction;

    }
    /**
     * Purge an requestForAction identified by its GUID. Delete is a hard delete, this means that the requestForAction is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the requestForAction
     */
    public void purgeRequestForAction(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeRequestForAction";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the RequestForAction type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("RequestForAction");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"RequestForAction",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an RequestForAction identified by its GUID. Restore resurrects a soft deleted RequestForAction. When a RequestForAction was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the RequestForAction
     * @return  RequestForAction the restored RequestForAction
     */
    public RequestForAction restoreRequestForAction(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreRequestForAction";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        RequestForAction restoredRequestForAction =  RequestForActionMapper.mapOmrsEntityDetailToRequestForAction(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredRequestForAction;
    }    

    /**
     * Add classifications to the supplied requestForAction
     * @param userId user identity
     * @param entityGuid the GUID value for requestForAction
     * @param classifications the classifications to apply.
     * @return the requestForAction entity that has been classified
     */
     public RequestForAction addRequestForActionClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addRequestForActionClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         RequestForAction requestForActionClassificationBeans = RequestForActionMapper.mapOmrsEntityDetailToRequestForAction(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified RequestForAction=" +  requestForActionClassificationBeans);
         }
         return  requestForActionClassificationBeans;
    }

    /**
     * Updates classifications to an existing requestForAction represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the requestForAction
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given requestForAction guid
     */
    public RequestForAction updateRequestForActionClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateRequestForActionClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           RequestForAction  requestForActionClassificationBeans = RequestForActionMapper.mapOmrsEntityDetailToRequestForAction(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  requestForActionClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing requestForAction represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the requestForAction
     * @param name name of the classification
     * @return deleted RequestForAction  classification
     */
    public RequestForAction deleteRequestForActionClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteRequestForActionClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       RequestForAction declassifiedRequestForAction =  RequestForActionMapper.mapOmrsEntityDetailToRequestForAction(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedRequestForAction;
    }

    /**
      * Get the relationships associated with entity requestForAction represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the requestForAction
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getRequestForActionRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getRequestForActionRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an project given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the projects relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return Project the Project entity with the requested GUID
     */
    public Project getProject(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getProject";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        Project gotproject = ProjectMapper.mapOmrsEntityDetailToProject(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotproject );
        }
        return gotproject;

    }
    /**
     * Create new project.
     * @param userId user identity
     * @param project the input entity with values.
     * @return Project the created entity.
     */

    public Project createProject(String userId,Project project)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createProject";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = ProjectMapper.mapProjectToOmrsEntityDetail(project);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        Project createdProject =  ProjectMapper.mapOmrsEntityDetailToProject(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created Project="+ createdProject );
        }
        return createdProject;
    }
    /**
     * Update project
     * @param userId user identity
     * @param project   project to update
     * @return Project the updated project entity
     */
    public Project updateProject(String userId, Project project)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateProject";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = ProjectMapper.mapProjectToOmrsEntityDetail(project);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            Project updatedProject =  ProjectMapper.mapOmrsEntityDetailToProject(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated Project="+ updatedProject );
            }
            return updatedProject;
        }

    /**
     * Delete an project identified by its GUID. Delete is a soft delete, this means that the project has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the project
     * @return Project the deleted Project entity
     */

    public Project deleteProject(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteProject";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Project type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Project");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"Project",entityDef.getGUID(),entityGuid);
         Project deletedProject = ProjectMapper.mapOmrsEntityDetailToProject(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedProject;

    }
    /**
     * Purge an project identified by its GUID. Delete is a hard delete, this means that the project is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the project
     */
    public void purgeProject(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeProject";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Project type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Project");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"Project",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an Project identified by its GUID. Restore resurrects a soft deleted Project. When a Project was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the Project
     * @return  Project the restored Project
     */
    public Project restoreProject(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreProject";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        Project restoredProject =  ProjectMapper.mapOmrsEntityDetailToProject(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredProject;
    }    

    /**
     * Add classifications to the supplied project
     * @param userId user identity
     * @param entityGuid the GUID value for project
     * @param classifications the classifications to apply.
     * @return the project entity that has been classified
     */
     public Project addProjectClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addProjectClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         Project projectClassificationBeans = ProjectMapper.mapOmrsEntityDetailToProject(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified Project=" +  projectClassificationBeans);
         }
         return  projectClassificationBeans;
    }

    /**
     * Updates classifications to an existing project represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the project
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given project guid
     */
    public Project updateProjectClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateProjectClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           Project  projectClassificationBeans = ProjectMapper.mapOmrsEntityDetailToProject(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  projectClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing project represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the project
     * @param name name of the classification
     * @return deleted Project  classification
     */
    public Project deleteProjectClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteProjectClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       Project declassifiedProject =  ProjectMapper.mapOmrsEntityDetailToProject(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedProject;
    }

    /**
      * Get the relationships associated with entity project represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the project
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getProjectRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getProjectRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an dataField given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the dataFields relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return DataField the DataField entity with the requested GUID
     */
    public DataField getDataField(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getDataField";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        DataField gotdataField = DataFieldMapper.mapOmrsEntityDetailToDataField(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotdataField );
        }
        return gotdataField;

    }
    /**
     * Create new dataField.
     * @param userId user identity
     * @param dataField the input entity with values.
     * @return DataField the created entity.
     */

    public DataField createDataField(String userId,DataField dataField)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createDataField";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = DataFieldMapper.mapDataFieldToOmrsEntityDetail(dataField);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        DataField createdDataField =  DataFieldMapper.mapOmrsEntityDetailToDataField(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created DataField="+ createdDataField );
        }
        return createdDataField;
    }
    /**
     * Update dataField
     * @param userId user identity
     * @param dataField   dataField to update
     * @return DataField the updated dataField entity
     */
    public DataField updateDataField(String userId, DataField dataField)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateDataField";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = DataFieldMapper.mapDataFieldToOmrsEntityDetail(dataField);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            DataField updatedDataField =  DataFieldMapper.mapOmrsEntityDetailToDataField(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated DataField="+ updatedDataField );
            }
            return updatedDataField;
        }

    /**
     * Delete an dataField identified by its GUID. Delete is a soft delete, this means that the dataField has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the dataField
     * @return DataField the deleted DataField entity
     */

    public DataField deleteDataField(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteDataField";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DataField type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DataField");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"DataField",entityDef.getGUID(),entityGuid);
         DataField deletedDataField = DataFieldMapper.mapOmrsEntityDetailToDataField(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedDataField;

    }
    /**
     * Purge an dataField identified by its GUID. Delete is a hard delete, this means that the dataField is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the dataField
     */
    public void purgeDataField(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeDataField";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DataField type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DataField");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"DataField",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an DataField identified by its GUID. Restore resurrects a soft deleted DataField. When a DataField was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the DataField
     * @return  DataField the restored DataField
     */
    public DataField restoreDataField(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreDataField";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        DataField restoredDataField =  DataFieldMapper.mapOmrsEntityDetailToDataField(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredDataField;
    }    

    /**
     * Add classifications to the supplied dataField
     * @param userId user identity
     * @param entityGuid the GUID value for dataField
     * @param classifications the classifications to apply.
     * @return the dataField entity that has been classified
     */
     public DataField addDataFieldClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addDataFieldClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         DataField dataFieldClassificationBeans = DataFieldMapper.mapOmrsEntityDetailToDataField(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified DataField=" +  dataFieldClassificationBeans);
         }
         return  dataFieldClassificationBeans;
    }

    /**
     * Updates classifications to an existing dataField represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the dataField
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given dataField guid
     */
    public DataField updateDataFieldClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateDataFieldClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           DataField  dataFieldClassificationBeans = DataFieldMapper.mapOmrsEntityDetailToDataField(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  dataFieldClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing dataField represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the dataField
     * @param name name of the classification
     * @return deleted DataField  classification
     */
    public DataField deleteDataFieldClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteDataFieldClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       DataField declassifiedDataField =  DataFieldMapper.mapOmrsEntityDetailToDataField(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedDataField;
    }

    /**
      * Get the relationships associated with entity dataField represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the dataField
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getDataFieldRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getDataFieldRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an hostCluster given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the hostClusters relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return HostCluster the HostCluster entity with the requested GUID
     */
    public HostCluster getHostCluster(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getHostCluster";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        HostCluster gothostCluster = HostClusterMapper.mapOmrsEntityDetailToHostCluster(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gothostCluster );
        }
        return gothostCluster;

    }
    /**
     * Create new hostCluster.
     * @param userId user identity
     * @param hostCluster the input entity with values.
     * @return HostCluster the created entity.
     */

    public HostCluster createHostCluster(String userId,HostCluster hostCluster)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createHostCluster";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = HostClusterMapper.mapHostClusterToOmrsEntityDetail(hostCluster);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        HostCluster createdHostCluster =  HostClusterMapper.mapOmrsEntityDetailToHostCluster(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created HostCluster="+ createdHostCluster );
        }
        return createdHostCluster;
    }
    /**
     * Update hostCluster
     * @param userId user identity
     * @param hostCluster   hostCluster to update
     * @return HostCluster the updated hostCluster entity
     */
    public HostCluster updateHostCluster(String userId, HostCluster hostCluster)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateHostCluster";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = HostClusterMapper.mapHostClusterToOmrsEntityDetail(hostCluster);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            HostCluster updatedHostCluster =  HostClusterMapper.mapOmrsEntityDetailToHostCluster(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated HostCluster="+ updatedHostCluster );
            }
            return updatedHostCluster;
        }

    /**
     * Delete an hostCluster identified by its GUID. Delete is a soft delete, this means that the hostCluster has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the hostCluster
     * @return HostCluster the deleted HostCluster entity
     */

    public HostCluster deleteHostCluster(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteHostCluster";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the HostCluster type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("HostCluster");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"HostCluster",entityDef.getGUID(),entityGuid);
         HostCluster deletedHostCluster = HostClusterMapper.mapOmrsEntityDetailToHostCluster(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedHostCluster;

    }
    /**
     * Purge an hostCluster identified by its GUID. Delete is a hard delete, this means that the hostCluster is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the hostCluster
     */
    public void purgeHostCluster(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeHostCluster";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the HostCluster type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("HostCluster");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"HostCluster",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an HostCluster identified by its GUID. Restore resurrects a soft deleted HostCluster. When a HostCluster was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the HostCluster
     * @return  HostCluster the restored HostCluster
     */
    public HostCluster restoreHostCluster(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreHostCluster";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        HostCluster restoredHostCluster =  HostClusterMapper.mapOmrsEntityDetailToHostCluster(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredHostCluster;
    }    

    /**
     * Add classifications to the supplied hostCluster
     * @param userId user identity
     * @param entityGuid the GUID value for hostCluster
     * @param classifications the classifications to apply.
     * @return the hostCluster entity that has been classified
     */
     public HostCluster addHostClusterClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addHostClusterClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         HostCluster hostClusterClassificationBeans = HostClusterMapper.mapOmrsEntityDetailToHostCluster(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified HostCluster=" +  hostClusterClassificationBeans);
         }
         return  hostClusterClassificationBeans;
    }

    /**
     * Updates classifications to an existing hostCluster represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the hostCluster
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given hostCluster guid
     */
    public HostCluster updateHostClusterClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateHostClusterClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           HostCluster  hostClusterClassificationBeans = HostClusterMapper.mapOmrsEntityDetailToHostCluster(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  hostClusterClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing hostCluster represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the hostCluster
     * @param name name of the classification
     * @return deleted HostCluster  classification
     */
    public HostCluster deleteHostClusterClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteHostClusterClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       HostCluster declassifiedHostCluster =  HostClusterMapper.mapOmrsEntityDetailToHostCluster(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedHostCluster;
    }

    /**
      * Get the relationships associated with entity hostCluster represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the hostCluster
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getHostClusterRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getHostClusterRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an glossaryCategory given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the glossaryCategories relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return GlossaryCategory the GlossaryCategory entity with the requested GUID
     */
    public GlossaryCategory getGlossaryCategory(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getGlossaryCategory";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        GlossaryCategory gotglossaryCategory = GlossaryCategoryMapper.mapOmrsEntityDetailToGlossaryCategory(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotglossaryCategory );
        }
        return gotglossaryCategory;

    }
    /**
     * Create new glossaryCategory.
     * @param userId user identity
     * @param glossaryCategory the input entity with values.
     * @return GlossaryCategory the created entity.
     */

    public GlossaryCategory createGlossaryCategory(String userId,GlossaryCategory glossaryCategory)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createGlossaryCategory";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = GlossaryCategoryMapper.mapGlossaryCategoryToOmrsEntityDetail(glossaryCategory);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        GlossaryCategory createdGlossaryCategory =  GlossaryCategoryMapper.mapOmrsEntityDetailToGlossaryCategory(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created GlossaryCategory="+ createdGlossaryCategory );
        }
        return createdGlossaryCategory;
    }
    /**
     * Update glossaryCategory
     * @param userId user identity
     * @param glossaryCategory   glossaryCategory to update
     * @return GlossaryCategory the updated glossaryCategory entity
     */
    public GlossaryCategory updateGlossaryCategory(String userId, GlossaryCategory glossaryCategory)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateGlossaryCategory";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = GlossaryCategoryMapper.mapGlossaryCategoryToOmrsEntityDetail(glossaryCategory);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            GlossaryCategory updatedGlossaryCategory =  GlossaryCategoryMapper.mapOmrsEntityDetailToGlossaryCategory(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated GlossaryCategory="+ updatedGlossaryCategory );
            }
            return updatedGlossaryCategory;
        }

    /**
     * Delete an glossaryCategory identified by its GUID. Delete is a soft delete, this means that the glossaryCategory has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the glossaryCategory
     * @return GlossaryCategory the deleted GlossaryCategory entity
     */

    public GlossaryCategory deleteGlossaryCategory(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteGlossaryCategory";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GlossaryCategory type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GlossaryCategory");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"GlossaryCategory",entityDef.getGUID(),entityGuid);
         GlossaryCategory deletedGlossaryCategory = GlossaryCategoryMapper.mapOmrsEntityDetailToGlossaryCategory(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedGlossaryCategory;

    }
    /**
     * Purge an glossaryCategory identified by its GUID. Delete is a hard delete, this means that the glossaryCategory is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the glossaryCategory
     */
    public void purgeGlossaryCategory(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeGlossaryCategory";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GlossaryCategory type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GlossaryCategory");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"GlossaryCategory",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an GlossaryCategory identified by its GUID. Restore resurrects a soft deleted GlossaryCategory. When a GlossaryCategory was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the GlossaryCategory
     * @return  GlossaryCategory the restored GlossaryCategory
     */
    public GlossaryCategory restoreGlossaryCategory(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreGlossaryCategory";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        GlossaryCategory restoredGlossaryCategory =  GlossaryCategoryMapper.mapOmrsEntityDetailToGlossaryCategory(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredGlossaryCategory;
    }    

    /**
     * Add classifications to the supplied glossaryCategory
     * @param userId user identity
     * @param entityGuid the GUID value for glossaryCategory
     * @param classifications the classifications to apply.
     * @return the glossaryCategory entity that has been classified
     */
     public GlossaryCategory addGlossaryCategoryClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addGlossaryCategoryClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         GlossaryCategory glossaryCategoryClassificationBeans = GlossaryCategoryMapper.mapOmrsEntityDetailToGlossaryCategory(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified GlossaryCategory=" +  glossaryCategoryClassificationBeans);
         }
         return  glossaryCategoryClassificationBeans;
    }

    /**
     * Updates classifications to an existing glossaryCategory represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the glossaryCategory
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given glossaryCategory guid
     */
    public GlossaryCategory updateGlossaryCategoryClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateGlossaryCategoryClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           GlossaryCategory  glossaryCategoryClassificationBeans = GlossaryCategoryMapper.mapOmrsEntityDetailToGlossaryCategory(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  glossaryCategoryClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing glossaryCategory represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the glossaryCategory
     * @param name name of the classification
     * @return deleted GlossaryCategory  classification
     */
    public GlossaryCategory deleteGlossaryCategoryClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteGlossaryCategoryClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       GlossaryCategory declassifiedGlossaryCategory =  GlossaryCategoryMapper.mapOmrsEntityDetailToGlossaryCategory(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedGlossaryCategory;
    }

    /**
      * Get the relationships associated with entity glossaryCategory represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the glossaryCategory
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getGlossaryCategoryRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getGlossaryCategoryRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an namingStandardRuleSet given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the namingStandardRuleSets relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return NamingStandardRuleSet the NamingStandardRuleSet entity with the requested GUID
     */
    public NamingStandardRuleSet getNamingStandardRuleSet(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getNamingStandardRuleSet";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        NamingStandardRuleSet gotnamingStandardRuleSet = NamingStandardRuleSetMapper.mapOmrsEntityDetailToNamingStandardRuleSet(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotnamingStandardRuleSet );
        }
        return gotnamingStandardRuleSet;

    }
    /**
     * Create new namingStandardRuleSet.
     * @param userId user identity
     * @param namingStandardRuleSet the input entity with values.
     * @return NamingStandardRuleSet the created entity.
     */

    public NamingStandardRuleSet createNamingStandardRuleSet(String userId,NamingStandardRuleSet namingStandardRuleSet)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createNamingStandardRuleSet";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = NamingStandardRuleSetMapper.mapNamingStandardRuleSetToOmrsEntityDetail(namingStandardRuleSet);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        NamingStandardRuleSet createdNamingStandardRuleSet =  NamingStandardRuleSetMapper.mapOmrsEntityDetailToNamingStandardRuleSet(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created NamingStandardRuleSet="+ createdNamingStandardRuleSet );
        }
        return createdNamingStandardRuleSet;
    }
    /**
     * Update namingStandardRuleSet
     * @param userId user identity
     * @param namingStandardRuleSet   namingStandardRuleSet to update
     * @return NamingStandardRuleSet the updated namingStandardRuleSet entity
     */
    public NamingStandardRuleSet updateNamingStandardRuleSet(String userId, NamingStandardRuleSet namingStandardRuleSet)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateNamingStandardRuleSet";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = NamingStandardRuleSetMapper.mapNamingStandardRuleSetToOmrsEntityDetail(namingStandardRuleSet);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            NamingStandardRuleSet updatedNamingStandardRuleSet =  NamingStandardRuleSetMapper.mapOmrsEntityDetailToNamingStandardRuleSet(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated NamingStandardRuleSet="+ updatedNamingStandardRuleSet );
            }
            return updatedNamingStandardRuleSet;
        }

    /**
     * Delete an namingStandardRuleSet identified by its GUID. Delete is a soft delete, this means that the namingStandardRuleSet has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the namingStandardRuleSet
     * @return NamingStandardRuleSet the deleted NamingStandardRuleSet entity
     */

    public NamingStandardRuleSet deleteNamingStandardRuleSet(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteNamingStandardRuleSet";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the NamingStandardRuleSet type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("NamingStandardRuleSet");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"NamingStandardRuleSet",entityDef.getGUID(),entityGuid);
         NamingStandardRuleSet deletedNamingStandardRuleSet = NamingStandardRuleSetMapper.mapOmrsEntityDetailToNamingStandardRuleSet(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedNamingStandardRuleSet;

    }
    /**
     * Purge an namingStandardRuleSet identified by its GUID. Delete is a hard delete, this means that the namingStandardRuleSet is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the namingStandardRuleSet
     */
    public void purgeNamingStandardRuleSet(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeNamingStandardRuleSet";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the NamingStandardRuleSet type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("NamingStandardRuleSet");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"NamingStandardRuleSet",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an NamingStandardRuleSet identified by its GUID. Restore resurrects a soft deleted NamingStandardRuleSet. When a NamingStandardRuleSet was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the NamingStandardRuleSet
     * @return  NamingStandardRuleSet the restored NamingStandardRuleSet
     */
    public NamingStandardRuleSet restoreNamingStandardRuleSet(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreNamingStandardRuleSet";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        NamingStandardRuleSet restoredNamingStandardRuleSet =  NamingStandardRuleSetMapper.mapOmrsEntityDetailToNamingStandardRuleSet(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredNamingStandardRuleSet;
    }    

    /**
     * Add classifications to the supplied namingStandardRuleSet
     * @param userId user identity
     * @param entityGuid the GUID value for namingStandardRuleSet
     * @param classifications the classifications to apply.
     * @return the namingStandardRuleSet entity that has been classified
     */
     public NamingStandardRuleSet addNamingStandardRuleSetClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addNamingStandardRuleSetClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         NamingStandardRuleSet namingStandardRuleSetClassificationBeans = NamingStandardRuleSetMapper.mapOmrsEntityDetailToNamingStandardRuleSet(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified NamingStandardRuleSet=" +  namingStandardRuleSetClassificationBeans);
         }
         return  namingStandardRuleSetClassificationBeans;
    }

    /**
     * Updates classifications to an existing namingStandardRuleSet represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the namingStandardRuleSet
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given namingStandardRuleSet guid
     */
    public NamingStandardRuleSet updateNamingStandardRuleSetClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateNamingStandardRuleSetClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           NamingStandardRuleSet  namingStandardRuleSetClassificationBeans = NamingStandardRuleSetMapper.mapOmrsEntityDetailToNamingStandardRuleSet(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  namingStandardRuleSetClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing namingStandardRuleSet represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the namingStandardRuleSet
     * @param name name of the classification
     * @return deleted NamingStandardRuleSet  classification
     */
    public NamingStandardRuleSet deleteNamingStandardRuleSetClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteNamingStandardRuleSetClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       NamingStandardRuleSet declassifiedNamingStandardRuleSet =  NamingStandardRuleSetMapper.mapOmrsEntityDetailToNamingStandardRuleSet(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedNamingStandardRuleSet;
    }

    /**
      * Get the relationships associated with entity namingStandardRuleSet represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the namingStandardRuleSet
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getNamingStandardRuleSetRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getNamingStandardRuleSetRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an teamLeader given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the teamLeaders relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return TeamLeader the TeamLeader entity with the requested GUID
     */
    public TeamLeader getTeamLeader(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getTeamLeader";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        TeamLeader gotteamLeader = TeamLeaderMapper.mapOmrsEntityDetailToTeamLeader(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotteamLeader );
        }
        return gotteamLeader;

    }
    /**
     * Create new teamLeader.
     * @param userId user identity
     * @param teamLeader the input entity with values.
     * @return TeamLeader the created entity.
     */

    public TeamLeader createTeamLeader(String userId,TeamLeader teamLeader)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createTeamLeader";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = TeamLeaderMapper.mapTeamLeaderToOmrsEntityDetail(teamLeader);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        TeamLeader createdTeamLeader =  TeamLeaderMapper.mapOmrsEntityDetailToTeamLeader(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created TeamLeader="+ createdTeamLeader );
        }
        return createdTeamLeader;
    }
    /**
     * Update teamLeader
     * @param userId user identity
     * @param teamLeader   teamLeader to update
     * @return TeamLeader the updated teamLeader entity
     */
    public TeamLeader updateTeamLeader(String userId, TeamLeader teamLeader)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateTeamLeader";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = TeamLeaderMapper.mapTeamLeaderToOmrsEntityDetail(teamLeader);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            TeamLeader updatedTeamLeader =  TeamLeaderMapper.mapOmrsEntityDetailToTeamLeader(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated TeamLeader="+ updatedTeamLeader );
            }
            return updatedTeamLeader;
        }

    /**
     * Delete an teamLeader identified by its GUID. Delete is a soft delete, this means that the teamLeader has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the teamLeader
     * @return TeamLeader the deleted TeamLeader entity
     */

    public TeamLeader deleteTeamLeader(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteTeamLeader";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the TeamLeader type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("TeamLeader");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"TeamLeader",entityDef.getGUID(),entityGuid);
         TeamLeader deletedTeamLeader = TeamLeaderMapper.mapOmrsEntityDetailToTeamLeader(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedTeamLeader;

    }
    /**
     * Purge an teamLeader identified by its GUID. Delete is a hard delete, this means that the teamLeader is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the teamLeader
     */
    public void purgeTeamLeader(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeTeamLeader";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the TeamLeader type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("TeamLeader");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"TeamLeader",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an TeamLeader identified by its GUID. Restore resurrects a soft deleted TeamLeader. When a TeamLeader was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the TeamLeader
     * @return  TeamLeader the restored TeamLeader
     */
    public TeamLeader restoreTeamLeader(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreTeamLeader";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        TeamLeader restoredTeamLeader =  TeamLeaderMapper.mapOmrsEntityDetailToTeamLeader(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredTeamLeader;
    }    

    /**
     * Add classifications to the supplied teamLeader
     * @param userId user identity
     * @param entityGuid the GUID value for teamLeader
     * @param classifications the classifications to apply.
     * @return the teamLeader entity that has been classified
     */
     public TeamLeader addTeamLeaderClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addTeamLeaderClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         TeamLeader teamLeaderClassificationBeans = TeamLeaderMapper.mapOmrsEntityDetailToTeamLeader(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified TeamLeader=" +  teamLeaderClassificationBeans);
         }
         return  teamLeaderClassificationBeans;
    }

    /**
     * Updates classifications to an existing teamLeader represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the teamLeader
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given teamLeader guid
     */
    public TeamLeader updateTeamLeaderClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateTeamLeaderClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           TeamLeader  teamLeaderClassificationBeans = TeamLeaderMapper.mapOmrsEntityDetailToTeamLeader(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  teamLeaderClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing teamLeader represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the teamLeader
     * @param name name of the classification
     * @return deleted TeamLeader  classification
     */
    public TeamLeader deleteTeamLeaderClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteTeamLeaderClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       TeamLeader declassifiedTeamLeader =  TeamLeaderMapper.mapOmrsEntityDetailToTeamLeader(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedTeamLeader;
    }

    /**
      * Get the relationships associated with entity teamLeader represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the teamLeader
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getTeamLeaderRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getTeamLeaderRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an relationshipAdviceAnnotation given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the relationshipAdviceAnnotations relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return RelationshipAdviceAnnotation the RelationshipAdviceAnnotation entity with the requested GUID
     */
    public RelationshipAdviceAnnotation getRelationshipAdviceAnnotation(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getRelationshipAdviceAnnotation";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        RelationshipAdviceAnnotation gotrelationshipAdviceAnnotation = RelationshipAdviceAnnotationMapper.mapOmrsEntityDetailToRelationshipAdviceAnnotation(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotrelationshipAdviceAnnotation );
        }
        return gotrelationshipAdviceAnnotation;

    }
    /**
     * Create new relationshipAdviceAnnotation.
     * @param userId user identity
     * @param relationshipAdviceAnnotation the input entity with values.
     * @return RelationshipAdviceAnnotation the created entity.
     */

    public RelationshipAdviceAnnotation createRelationshipAdviceAnnotation(String userId,RelationshipAdviceAnnotation relationshipAdviceAnnotation)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createRelationshipAdviceAnnotation";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = RelationshipAdviceAnnotationMapper.mapRelationshipAdviceAnnotationToOmrsEntityDetail(relationshipAdviceAnnotation);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        RelationshipAdviceAnnotation createdRelationshipAdviceAnnotation =  RelationshipAdviceAnnotationMapper.mapOmrsEntityDetailToRelationshipAdviceAnnotation(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created RelationshipAdviceAnnotation="+ createdRelationshipAdviceAnnotation );
        }
        return createdRelationshipAdviceAnnotation;
    }
    /**
     * Update relationshipAdviceAnnotation
     * @param userId user identity
     * @param relationshipAdviceAnnotation   relationshipAdviceAnnotation to update
     * @return RelationshipAdviceAnnotation the updated relationshipAdviceAnnotation entity
     */
    public RelationshipAdviceAnnotation updateRelationshipAdviceAnnotation(String userId, RelationshipAdviceAnnotation relationshipAdviceAnnotation)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateRelationshipAdviceAnnotation";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = RelationshipAdviceAnnotationMapper.mapRelationshipAdviceAnnotationToOmrsEntityDetail(relationshipAdviceAnnotation);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            RelationshipAdviceAnnotation updatedRelationshipAdviceAnnotation =  RelationshipAdviceAnnotationMapper.mapOmrsEntityDetailToRelationshipAdviceAnnotation(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated RelationshipAdviceAnnotation="+ updatedRelationshipAdviceAnnotation );
            }
            return updatedRelationshipAdviceAnnotation;
        }

    /**
     * Delete an relationshipAdviceAnnotation identified by its GUID. Delete is a soft delete, this means that the relationshipAdviceAnnotation has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the relationshipAdviceAnnotation
     * @return RelationshipAdviceAnnotation the deleted RelationshipAdviceAnnotation entity
     */

    public RelationshipAdviceAnnotation deleteRelationshipAdviceAnnotation(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteRelationshipAdviceAnnotation";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the RelationshipAdviceAnnotation type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("RelationshipAdviceAnnotation");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"RelationshipAdviceAnnotation",entityDef.getGUID(),entityGuid);
         RelationshipAdviceAnnotation deletedRelationshipAdviceAnnotation = RelationshipAdviceAnnotationMapper.mapOmrsEntityDetailToRelationshipAdviceAnnotation(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedRelationshipAdviceAnnotation;

    }
    /**
     * Purge an relationshipAdviceAnnotation identified by its GUID. Delete is a hard delete, this means that the relationshipAdviceAnnotation is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the relationshipAdviceAnnotation
     */
    public void purgeRelationshipAdviceAnnotation(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeRelationshipAdviceAnnotation";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the RelationshipAdviceAnnotation type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("RelationshipAdviceAnnotation");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"RelationshipAdviceAnnotation",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an RelationshipAdviceAnnotation identified by its GUID. Restore resurrects a soft deleted RelationshipAdviceAnnotation. When a RelationshipAdviceAnnotation was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the RelationshipAdviceAnnotation
     * @return  RelationshipAdviceAnnotation the restored RelationshipAdviceAnnotation
     */
    public RelationshipAdviceAnnotation restoreRelationshipAdviceAnnotation(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreRelationshipAdviceAnnotation";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        RelationshipAdviceAnnotation restoredRelationshipAdviceAnnotation =  RelationshipAdviceAnnotationMapper.mapOmrsEntityDetailToRelationshipAdviceAnnotation(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredRelationshipAdviceAnnotation;
    }    

    /**
     * Add classifications to the supplied relationshipAdviceAnnotation
     * @param userId user identity
     * @param entityGuid the GUID value for relationshipAdviceAnnotation
     * @param classifications the classifications to apply.
     * @return the relationshipAdviceAnnotation entity that has been classified
     */
     public RelationshipAdviceAnnotation addRelationshipAdviceAnnotationClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addRelationshipAdviceAnnotationClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         RelationshipAdviceAnnotation relationshipAdviceAnnotationClassificationBeans = RelationshipAdviceAnnotationMapper.mapOmrsEntityDetailToRelationshipAdviceAnnotation(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified RelationshipAdviceAnnotation=" +  relationshipAdviceAnnotationClassificationBeans);
         }
         return  relationshipAdviceAnnotationClassificationBeans;
    }

    /**
     * Updates classifications to an existing relationshipAdviceAnnotation represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the relationshipAdviceAnnotation
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given relationshipAdviceAnnotation guid
     */
    public RelationshipAdviceAnnotation updateRelationshipAdviceAnnotationClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateRelationshipAdviceAnnotationClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           RelationshipAdviceAnnotation  relationshipAdviceAnnotationClassificationBeans = RelationshipAdviceAnnotationMapper.mapOmrsEntityDetailToRelationshipAdviceAnnotation(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  relationshipAdviceAnnotationClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing relationshipAdviceAnnotation represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the relationshipAdviceAnnotation
     * @param name name of the classification
     * @return deleted RelationshipAdviceAnnotation  classification
     */
    public RelationshipAdviceAnnotation deleteRelationshipAdviceAnnotationClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteRelationshipAdviceAnnotationClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       RelationshipAdviceAnnotation declassifiedRelationshipAdviceAnnotation =  RelationshipAdviceAnnotationMapper.mapOmrsEntityDetailToRelationshipAdviceAnnotation(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedRelationshipAdviceAnnotation;
    }

    /**
      * Get the relationships associated with entity relationshipAdviceAnnotation represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the relationshipAdviceAnnotation
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getRelationshipAdviceAnnotationRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getRelationshipAdviceAnnotationRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an informalTag given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the informalTags relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return InformalTag the InformalTag entity with the requested GUID
     */
    public InformalTag getInformalTag(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getInformalTag";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        InformalTag gotinformalTag = InformalTagMapper.mapOmrsEntityDetailToInformalTag(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotinformalTag );
        }
        return gotinformalTag;

    }
    /**
     * Create new informalTag.
     * @param userId user identity
     * @param informalTag the input entity with values.
     * @return InformalTag the created entity.
     */

    public InformalTag createInformalTag(String userId,InformalTag informalTag)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createInformalTag";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = InformalTagMapper.mapInformalTagToOmrsEntityDetail(informalTag);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        InformalTag createdInformalTag =  InformalTagMapper.mapOmrsEntityDetailToInformalTag(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created InformalTag="+ createdInformalTag );
        }
        return createdInformalTag;
    }
    /**
     * Update informalTag
     * @param userId user identity
     * @param informalTag   informalTag to update
     * @return InformalTag the updated informalTag entity
     */
    public InformalTag updateInformalTag(String userId, InformalTag informalTag)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateInformalTag";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = InformalTagMapper.mapInformalTagToOmrsEntityDetail(informalTag);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            InformalTag updatedInformalTag =  InformalTagMapper.mapOmrsEntityDetailToInformalTag(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated InformalTag="+ updatedInformalTag );
            }
            return updatedInformalTag;
        }

    /**
     * Delete an informalTag identified by its GUID. Delete is a soft delete, this means that the informalTag has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the informalTag
     * @return InformalTag the deleted InformalTag entity
     */

    public InformalTag deleteInformalTag(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteInformalTag";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the InformalTag type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("InformalTag");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"InformalTag",entityDef.getGUID(),entityGuid);
         InformalTag deletedInformalTag = InformalTagMapper.mapOmrsEntityDetailToInformalTag(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedInformalTag;

    }
    /**
     * Purge an informalTag identified by its GUID. Delete is a hard delete, this means that the informalTag is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the informalTag
     */
    public void purgeInformalTag(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeInformalTag";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the InformalTag type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("InformalTag");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"InformalTag",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an InformalTag identified by its GUID. Restore resurrects a soft deleted InformalTag. When a InformalTag was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the InformalTag
     * @return  InformalTag the restored InformalTag
     */
    public InformalTag restoreInformalTag(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreInformalTag";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        InformalTag restoredInformalTag =  InformalTagMapper.mapOmrsEntityDetailToInformalTag(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredInformalTag;
    }    

    /**
     * Add classifications to the supplied informalTag
     * @param userId user identity
     * @param entityGuid the GUID value for informalTag
     * @param classifications the classifications to apply.
     * @return the informalTag entity that has been classified
     */
     public InformalTag addInformalTagClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addInformalTagClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         InformalTag informalTagClassificationBeans = InformalTagMapper.mapOmrsEntityDetailToInformalTag(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified InformalTag=" +  informalTagClassificationBeans);
         }
         return  informalTagClassificationBeans;
    }

    /**
     * Updates classifications to an existing informalTag represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the informalTag
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given informalTag guid
     */
    public InformalTag updateInformalTagClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateInformalTagClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           InformalTag  informalTagClassificationBeans = InformalTagMapper.mapOmrsEntityDetailToInformalTag(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  informalTagClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing informalTag represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the informalTag
     * @param name name of the classification
     * @return deleted InformalTag  classification
     */
    public InformalTag deleteInformalTagClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteInformalTagClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       InformalTag declassifiedInformalTag =  InformalTagMapper.mapOmrsEntityDetailToInformalTag(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedInformalTag;
    }

    /**
      * Get the relationships associated with entity informalTag represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the informalTag
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getInformalTagRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getInformalTagRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an crowdSourcingContributor given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the crowdSourcingContributors relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return CrowdSourcingContributor the CrowdSourcingContributor entity with the requested GUID
     */
    public CrowdSourcingContributor getCrowdSourcingContributor(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getCrowdSourcingContributor";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        CrowdSourcingContributor gotcrowdSourcingContributor = CrowdSourcingContributorMapper.mapOmrsEntityDetailToCrowdSourcingContributor(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotcrowdSourcingContributor );
        }
        return gotcrowdSourcingContributor;

    }
    /**
     * Create new crowdSourcingContributor.
     * @param userId user identity
     * @param crowdSourcingContributor the input entity with values.
     * @return CrowdSourcingContributor the created entity.
     */

    public CrowdSourcingContributor createCrowdSourcingContributor(String userId,CrowdSourcingContributor crowdSourcingContributor)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createCrowdSourcingContributor";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = CrowdSourcingContributorMapper.mapCrowdSourcingContributorToOmrsEntityDetail(crowdSourcingContributor);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        CrowdSourcingContributor createdCrowdSourcingContributor =  CrowdSourcingContributorMapper.mapOmrsEntityDetailToCrowdSourcingContributor(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created CrowdSourcingContributor="+ createdCrowdSourcingContributor );
        }
        return createdCrowdSourcingContributor;
    }
    /**
     * Update crowdSourcingContributor
     * @param userId user identity
     * @param crowdSourcingContributor   crowdSourcingContributor to update
     * @return CrowdSourcingContributor the updated crowdSourcingContributor entity
     */
    public CrowdSourcingContributor updateCrowdSourcingContributor(String userId, CrowdSourcingContributor crowdSourcingContributor)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateCrowdSourcingContributor";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = CrowdSourcingContributorMapper.mapCrowdSourcingContributorToOmrsEntityDetail(crowdSourcingContributor);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            CrowdSourcingContributor updatedCrowdSourcingContributor =  CrowdSourcingContributorMapper.mapOmrsEntityDetailToCrowdSourcingContributor(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated CrowdSourcingContributor="+ updatedCrowdSourcingContributor );
            }
            return updatedCrowdSourcingContributor;
        }

    /**
     * Delete an crowdSourcingContributor identified by its GUID. Delete is a soft delete, this means that the crowdSourcingContributor has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the crowdSourcingContributor
     * @return CrowdSourcingContributor the deleted CrowdSourcingContributor entity
     */

    public CrowdSourcingContributor deleteCrowdSourcingContributor(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteCrowdSourcingContributor";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the CrowdSourcingContributor type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("CrowdSourcingContributor");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"CrowdSourcingContributor",entityDef.getGUID(),entityGuid);
         CrowdSourcingContributor deletedCrowdSourcingContributor = CrowdSourcingContributorMapper.mapOmrsEntityDetailToCrowdSourcingContributor(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedCrowdSourcingContributor;

    }
    /**
     * Purge an crowdSourcingContributor identified by its GUID. Delete is a hard delete, this means that the crowdSourcingContributor is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the crowdSourcingContributor
     */
    public void purgeCrowdSourcingContributor(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeCrowdSourcingContributor";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the CrowdSourcingContributor type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("CrowdSourcingContributor");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"CrowdSourcingContributor",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an CrowdSourcingContributor identified by its GUID. Restore resurrects a soft deleted CrowdSourcingContributor. When a CrowdSourcingContributor was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the CrowdSourcingContributor
     * @return  CrowdSourcingContributor the restored CrowdSourcingContributor
     */
    public CrowdSourcingContributor restoreCrowdSourcingContributor(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreCrowdSourcingContributor";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        CrowdSourcingContributor restoredCrowdSourcingContributor =  CrowdSourcingContributorMapper.mapOmrsEntityDetailToCrowdSourcingContributor(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredCrowdSourcingContributor;
    }    

    /**
     * Add classifications to the supplied crowdSourcingContributor
     * @param userId user identity
     * @param entityGuid the GUID value for crowdSourcingContributor
     * @param classifications the classifications to apply.
     * @return the crowdSourcingContributor entity that has been classified
     */
     public CrowdSourcingContributor addCrowdSourcingContributorClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addCrowdSourcingContributorClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         CrowdSourcingContributor crowdSourcingContributorClassificationBeans = CrowdSourcingContributorMapper.mapOmrsEntityDetailToCrowdSourcingContributor(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified CrowdSourcingContributor=" +  crowdSourcingContributorClassificationBeans);
         }
         return  crowdSourcingContributorClassificationBeans;
    }

    /**
     * Updates classifications to an existing crowdSourcingContributor represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the crowdSourcingContributor
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given crowdSourcingContributor guid
     */
    public CrowdSourcingContributor updateCrowdSourcingContributorClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateCrowdSourcingContributorClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           CrowdSourcingContributor  crowdSourcingContributorClassificationBeans = CrowdSourcingContributorMapper.mapOmrsEntityDetailToCrowdSourcingContributor(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  crowdSourcingContributorClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing crowdSourcingContributor represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the crowdSourcingContributor
     * @param name name of the classification
     * @return deleted CrowdSourcingContributor  classification
     */
    public CrowdSourcingContributor deleteCrowdSourcingContributorClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteCrowdSourcingContributorClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       CrowdSourcingContributor declassifiedCrowdSourcingContributor =  CrowdSourcingContributorMapper.mapOmrsEntityDetailToCrowdSourcingContributor(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedCrowdSourcingContributor;
    }

    /**
      * Get the relationships associated with entity crowdSourcingContributor represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the crowdSourcingContributor
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getCrowdSourcingContributorRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getCrowdSourcingContributorRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an application given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the applications relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return Application the Application entity with the requested GUID
     */
    public Application getApplication(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getApplication";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        Application gotapplication = ApplicationMapper.mapOmrsEntityDetailToApplication(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotapplication );
        }
        return gotapplication;

    }
    /**
     * Create new application.
     * @param userId user identity
     * @param application the input entity with values.
     * @return Application the created entity.
     */

    public Application createApplication(String userId,Application application)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createApplication";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = ApplicationMapper.mapApplicationToOmrsEntityDetail(application);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        Application createdApplication =  ApplicationMapper.mapOmrsEntityDetailToApplication(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created Application="+ createdApplication );
        }
        return createdApplication;
    }
    /**
     * Update application
     * @param userId user identity
     * @param application   application to update
     * @return Application the updated application entity
     */
    public Application updateApplication(String userId, Application application)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateApplication";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = ApplicationMapper.mapApplicationToOmrsEntityDetail(application);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            Application updatedApplication =  ApplicationMapper.mapOmrsEntityDetailToApplication(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated Application="+ updatedApplication );
            }
            return updatedApplication;
        }

    /**
     * Delete an application identified by its GUID. Delete is a soft delete, this means that the application has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the application
     * @return Application the deleted Application entity
     */

    public Application deleteApplication(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteApplication";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Application type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Application");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"Application",entityDef.getGUID(),entityGuid);
         Application deletedApplication = ApplicationMapper.mapOmrsEntityDetailToApplication(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedApplication;

    }
    /**
     * Purge an application identified by its GUID. Delete is a hard delete, this means that the application is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the application
     */
    public void purgeApplication(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeApplication";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Application type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Application");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"Application",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an Application identified by its GUID. Restore resurrects a soft deleted Application. When a Application was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the Application
     * @return  Application the restored Application
     */
    public Application restoreApplication(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreApplication";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        Application restoredApplication =  ApplicationMapper.mapOmrsEntityDetailToApplication(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredApplication;
    }    

    /**
     * Add classifications to the supplied application
     * @param userId user identity
     * @param entityGuid the GUID value for application
     * @param classifications the classifications to apply.
     * @return the application entity that has been classified
     */
     public Application addApplicationClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addApplicationClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         Application applicationClassificationBeans = ApplicationMapper.mapOmrsEntityDetailToApplication(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified Application=" +  applicationClassificationBeans);
         }
         return  applicationClassificationBeans;
    }

    /**
     * Updates classifications to an existing application represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the application
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given application guid
     */
    public Application updateApplicationClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateApplicationClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           Application  applicationClassificationBeans = ApplicationMapper.mapOmrsEntityDetailToApplication(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  applicationClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing application represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the application
     * @param name name of the classification
     * @return deleted Application  classification
     */
    public Application deleteApplicationClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteApplicationClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       Application declassifiedApplication =  ApplicationMapper.mapOmrsEntityDetailToApplication(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedApplication;
    }

    /**
      * Get the relationships associated with entity application represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the application
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getApplicationRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getApplicationRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an person given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the persons relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return Person the Person entity with the requested GUID
     */
    public Person getPerson(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getPerson";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        Person gotperson = PersonMapper.mapOmrsEntityDetailToPerson(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotperson );
        }
        return gotperson;

    }
    /**
     * Create new person.
     * @param userId user identity
     * @param person the input entity with values.
     * @return Person the created entity.
     */

    public Person createPerson(String userId,Person person)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createPerson";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = PersonMapper.mapPersonToOmrsEntityDetail(person);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        Person createdPerson =  PersonMapper.mapOmrsEntityDetailToPerson(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created Person="+ createdPerson );
        }
        return createdPerson;
    }
    /**
     * Update person
     * @param userId user identity
     * @param person   person to update
     * @return Person the updated person entity
     */
    public Person updatePerson(String userId, Person person)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updatePerson";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = PersonMapper.mapPersonToOmrsEntityDetail(person);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            Person updatedPerson =  PersonMapper.mapOmrsEntityDetailToPerson(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated Person="+ updatedPerson );
            }
            return updatedPerson;
        }

    /**
     * Delete an person identified by its GUID. Delete is a soft delete, this means that the person has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the person
     * @return Person the deleted Person entity
     */

    public Person deletePerson(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deletePerson";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Person type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Person");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"Person",entityDef.getGUID(),entityGuid);
         Person deletedPerson = PersonMapper.mapOmrsEntityDetailToPerson(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedPerson;

    }
    /**
     * Purge an person identified by its GUID. Delete is a hard delete, this means that the person is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the person
     */
    public void purgePerson(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgePerson";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Person type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Person");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"Person",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an Person identified by its GUID. Restore resurrects a soft deleted Person. When a Person was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the Person
     * @return  Person the restored Person
     */
    public Person restorePerson(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restorePerson";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        Person restoredPerson =  PersonMapper.mapOmrsEntityDetailToPerson(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredPerson;
    }    

    /**
     * Add classifications to the supplied person
     * @param userId user identity
     * @param entityGuid the GUID value for person
     * @param classifications the classifications to apply.
     * @return the person entity that has been classified
     */
     public Person addPersonClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addPersonClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         Person personClassificationBeans = PersonMapper.mapOmrsEntityDetailToPerson(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified Person=" +  personClassificationBeans);
         }
         return  personClassificationBeans;
    }

    /**
     * Updates classifications to an existing person represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the person
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given person guid
     */
    public Person updatePersonClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updatePersonClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           Person  personClassificationBeans = PersonMapper.mapOmrsEntityDetailToPerson(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  personClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing person represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the person
     * @param name name of the classification
     * @return deleted Person  classification
     */
    public Person deletePersonClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deletePersonClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       Person declassifiedPerson =  PersonMapper.mapOmrsEntityDetailToPerson(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedPerson;
    }

    /**
      * Get the relationships associated with entity person represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the person
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getPersonRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getPersonRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an virtualContainer given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the virtualContainers relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return VirtualContainer the VirtualContainer entity with the requested GUID
     */
    public VirtualContainer getVirtualContainer(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getVirtualContainer";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        VirtualContainer gotvirtualContainer = VirtualContainerMapper.mapOmrsEntityDetailToVirtualContainer(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotvirtualContainer );
        }
        return gotvirtualContainer;

    }
    /**
     * Create new virtualContainer.
     * @param userId user identity
     * @param virtualContainer the input entity with values.
     * @return VirtualContainer the created entity.
     */

    public VirtualContainer createVirtualContainer(String userId,VirtualContainer virtualContainer)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createVirtualContainer";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = VirtualContainerMapper.mapVirtualContainerToOmrsEntityDetail(virtualContainer);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        VirtualContainer createdVirtualContainer =  VirtualContainerMapper.mapOmrsEntityDetailToVirtualContainer(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created VirtualContainer="+ createdVirtualContainer );
        }
        return createdVirtualContainer;
    }
    /**
     * Update virtualContainer
     * @param userId user identity
     * @param virtualContainer   virtualContainer to update
     * @return VirtualContainer the updated virtualContainer entity
     */
    public VirtualContainer updateVirtualContainer(String userId, VirtualContainer virtualContainer)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateVirtualContainer";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = VirtualContainerMapper.mapVirtualContainerToOmrsEntityDetail(virtualContainer);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            VirtualContainer updatedVirtualContainer =  VirtualContainerMapper.mapOmrsEntityDetailToVirtualContainer(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated VirtualContainer="+ updatedVirtualContainer );
            }
            return updatedVirtualContainer;
        }

    /**
     * Delete an virtualContainer identified by its GUID. Delete is a soft delete, this means that the virtualContainer has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the virtualContainer
     * @return VirtualContainer the deleted VirtualContainer entity
     */

    public VirtualContainer deleteVirtualContainer(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteVirtualContainer";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the VirtualContainer type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("VirtualContainer");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"VirtualContainer",entityDef.getGUID(),entityGuid);
         VirtualContainer deletedVirtualContainer = VirtualContainerMapper.mapOmrsEntityDetailToVirtualContainer(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedVirtualContainer;

    }
    /**
     * Purge an virtualContainer identified by its GUID. Delete is a hard delete, this means that the virtualContainer is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the virtualContainer
     */
    public void purgeVirtualContainer(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeVirtualContainer";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the VirtualContainer type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("VirtualContainer");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"VirtualContainer",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an VirtualContainer identified by its GUID. Restore resurrects a soft deleted VirtualContainer. When a VirtualContainer was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the VirtualContainer
     * @return  VirtualContainer the restored VirtualContainer
     */
    public VirtualContainer restoreVirtualContainer(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreVirtualContainer";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        VirtualContainer restoredVirtualContainer =  VirtualContainerMapper.mapOmrsEntityDetailToVirtualContainer(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredVirtualContainer;
    }    

    /**
     * Add classifications to the supplied virtualContainer
     * @param userId user identity
     * @param entityGuid the GUID value for virtualContainer
     * @param classifications the classifications to apply.
     * @return the virtualContainer entity that has been classified
     */
     public VirtualContainer addVirtualContainerClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addVirtualContainerClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         VirtualContainer virtualContainerClassificationBeans = VirtualContainerMapper.mapOmrsEntityDetailToVirtualContainer(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified VirtualContainer=" +  virtualContainerClassificationBeans);
         }
         return  virtualContainerClassificationBeans;
    }

    /**
     * Updates classifications to an existing virtualContainer represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the virtualContainer
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given virtualContainer guid
     */
    public VirtualContainer updateVirtualContainerClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateVirtualContainerClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           VirtualContainer  virtualContainerClassificationBeans = VirtualContainerMapper.mapOmrsEntityDetailToVirtualContainer(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  virtualContainerClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing virtualContainer represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the virtualContainer
     * @param name name of the classification
     * @return deleted VirtualContainer  classification
     */
    public VirtualContainer deleteVirtualContainerClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteVirtualContainerClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       VirtualContainer declassifiedVirtualContainer =  VirtualContainerMapper.mapOmrsEntityDetailToVirtualContainer(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedVirtualContainer;
    }

    /**
      * Get the relationships associated with entity virtualContainer represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the virtualContainer
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getVirtualContainerRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getVirtualContainerRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an governanceObligation given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the governanceObligations relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return GovernanceObligation the GovernanceObligation entity with the requested GUID
     */
    public GovernanceObligation getGovernanceObligation(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getGovernanceObligation";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        GovernanceObligation gotgovernanceObligation = GovernanceObligationMapper.mapOmrsEntityDetailToGovernanceObligation(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotgovernanceObligation );
        }
        return gotgovernanceObligation;

    }
    /**
     * Create new governanceObligation.
     * @param userId user identity
     * @param governanceObligation the input entity with values.
     * @return GovernanceObligation the created entity.
     */

    public GovernanceObligation createGovernanceObligation(String userId,GovernanceObligation governanceObligation)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createGovernanceObligation";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = GovernanceObligationMapper.mapGovernanceObligationToOmrsEntityDetail(governanceObligation);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        GovernanceObligation createdGovernanceObligation =  GovernanceObligationMapper.mapOmrsEntityDetailToGovernanceObligation(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created GovernanceObligation="+ createdGovernanceObligation );
        }
        return createdGovernanceObligation;
    }
    /**
     * Update governanceObligation
     * @param userId user identity
     * @param governanceObligation   governanceObligation to update
     * @return GovernanceObligation the updated governanceObligation entity
     */
    public GovernanceObligation updateGovernanceObligation(String userId, GovernanceObligation governanceObligation)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateGovernanceObligation";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = GovernanceObligationMapper.mapGovernanceObligationToOmrsEntityDetail(governanceObligation);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            GovernanceObligation updatedGovernanceObligation =  GovernanceObligationMapper.mapOmrsEntityDetailToGovernanceObligation(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated GovernanceObligation="+ updatedGovernanceObligation );
            }
            return updatedGovernanceObligation;
        }

    /**
     * Delete an governanceObligation identified by its GUID. Delete is a soft delete, this means that the governanceObligation has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the governanceObligation
     * @return GovernanceObligation the deleted GovernanceObligation entity
     */

    public GovernanceObligation deleteGovernanceObligation(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteGovernanceObligation";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GovernanceObligation type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GovernanceObligation");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"GovernanceObligation",entityDef.getGUID(),entityGuid);
         GovernanceObligation deletedGovernanceObligation = GovernanceObligationMapper.mapOmrsEntityDetailToGovernanceObligation(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedGovernanceObligation;

    }
    /**
     * Purge an governanceObligation identified by its GUID. Delete is a hard delete, this means that the governanceObligation is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the governanceObligation
     */
    public void purgeGovernanceObligation(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeGovernanceObligation";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GovernanceObligation type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GovernanceObligation");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"GovernanceObligation",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an GovernanceObligation identified by its GUID. Restore resurrects a soft deleted GovernanceObligation. When a GovernanceObligation was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the GovernanceObligation
     * @return  GovernanceObligation the restored GovernanceObligation
     */
    public GovernanceObligation restoreGovernanceObligation(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreGovernanceObligation";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        GovernanceObligation restoredGovernanceObligation =  GovernanceObligationMapper.mapOmrsEntityDetailToGovernanceObligation(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredGovernanceObligation;
    }    

    /**
     * Add classifications to the supplied governanceObligation
     * @param userId user identity
     * @param entityGuid the GUID value for governanceObligation
     * @param classifications the classifications to apply.
     * @return the governanceObligation entity that has been classified
     */
     public GovernanceObligation addGovernanceObligationClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addGovernanceObligationClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         GovernanceObligation governanceObligationClassificationBeans = GovernanceObligationMapper.mapOmrsEntityDetailToGovernanceObligation(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified GovernanceObligation=" +  governanceObligationClassificationBeans);
         }
         return  governanceObligationClassificationBeans;
    }

    /**
     * Updates classifications to an existing governanceObligation represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the governanceObligation
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given governanceObligation guid
     */
    public GovernanceObligation updateGovernanceObligationClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateGovernanceObligationClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           GovernanceObligation  governanceObligationClassificationBeans = GovernanceObligationMapper.mapOmrsEntityDetailToGovernanceObligation(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  governanceObligationClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing governanceObligation represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the governanceObligation
     * @param name name of the classification
     * @return deleted GovernanceObligation  classification
     */
    public GovernanceObligation deleteGovernanceObligationClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteGovernanceObligationClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       GovernanceObligation declassifiedGovernanceObligation =  GovernanceObligationMapper.mapOmrsEntityDetailToGovernanceObligation(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedGovernanceObligation;
    }

    /**
      * Get the relationships associated with entity governanceObligation represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the governanceObligation
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getGovernanceObligationRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getGovernanceObligationRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an governanceDriver given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the governanceDrivers relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return GovernanceDriver the GovernanceDriver entity with the requested GUID
     */
    public GovernanceDriver getGovernanceDriver(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getGovernanceDriver";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        GovernanceDriver gotgovernanceDriver = GovernanceDriverMapper.mapOmrsEntityDetailToGovernanceDriver(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotgovernanceDriver );
        }
        return gotgovernanceDriver;

    }
    /**
     * Create new governanceDriver.
     * @param userId user identity
     * @param governanceDriver the input entity with values.
     * @return GovernanceDriver the created entity.
     */

    public GovernanceDriver createGovernanceDriver(String userId,GovernanceDriver governanceDriver)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createGovernanceDriver";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = GovernanceDriverMapper.mapGovernanceDriverToOmrsEntityDetail(governanceDriver);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        GovernanceDriver createdGovernanceDriver =  GovernanceDriverMapper.mapOmrsEntityDetailToGovernanceDriver(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created GovernanceDriver="+ createdGovernanceDriver );
        }
        return createdGovernanceDriver;
    }
    /**
     * Update governanceDriver
     * @param userId user identity
     * @param governanceDriver   governanceDriver to update
     * @return GovernanceDriver the updated governanceDriver entity
     */
    public GovernanceDriver updateGovernanceDriver(String userId, GovernanceDriver governanceDriver)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateGovernanceDriver";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = GovernanceDriverMapper.mapGovernanceDriverToOmrsEntityDetail(governanceDriver);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            GovernanceDriver updatedGovernanceDriver =  GovernanceDriverMapper.mapOmrsEntityDetailToGovernanceDriver(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated GovernanceDriver="+ updatedGovernanceDriver );
            }
            return updatedGovernanceDriver;
        }

    /**
     * Delete an governanceDriver identified by its GUID. Delete is a soft delete, this means that the governanceDriver has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the governanceDriver
     * @return GovernanceDriver the deleted GovernanceDriver entity
     */

    public GovernanceDriver deleteGovernanceDriver(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteGovernanceDriver";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GovernanceDriver type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GovernanceDriver");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"GovernanceDriver",entityDef.getGUID(),entityGuid);
         GovernanceDriver deletedGovernanceDriver = GovernanceDriverMapper.mapOmrsEntityDetailToGovernanceDriver(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedGovernanceDriver;

    }
    /**
     * Purge an governanceDriver identified by its GUID. Delete is a hard delete, this means that the governanceDriver is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the governanceDriver
     */
    public void purgeGovernanceDriver(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeGovernanceDriver";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GovernanceDriver type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GovernanceDriver");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"GovernanceDriver",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an GovernanceDriver identified by its GUID. Restore resurrects a soft deleted GovernanceDriver. When a GovernanceDriver was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the GovernanceDriver
     * @return  GovernanceDriver the restored GovernanceDriver
     */
    public GovernanceDriver restoreGovernanceDriver(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreGovernanceDriver";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        GovernanceDriver restoredGovernanceDriver =  GovernanceDriverMapper.mapOmrsEntityDetailToGovernanceDriver(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredGovernanceDriver;
    }    

    /**
     * Add classifications to the supplied governanceDriver
     * @param userId user identity
     * @param entityGuid the GUID value for governanceDriver
     * @param classifications the classifications to apply.
     * @return the governanceDriver entity that has been classified
     */
     public GovernanceDriver addGovernanceDriverClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addGovernanceDriverClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         GovernanceDriver governanceDriverClassificationBeans = GovernanceDriverMapper.mapOmrsEntityDetailToGovernanceDriver(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified GovernanceDriver=" +  governanceDriverClassificationBeans);
         }
         return  governanceDriverClassificationBeans;
    }

    /**
     * Updates classifications to an existing governanceDriver represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the governanceDriver
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given governanceDriver guid
     */
    public GovernanceDriver updateGovernanceDriverClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateGovernanceDriverClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           GovernanceDriver  governanceDriverClassificationBeans = GovernanceDriverMapper.mapOmrsEntityDetailToGovernanceDriver(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  governanceDriverClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing governanceDriver represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the governanceDriver
     * @param name name of the classification
     * @return deleted GovernanceDriver  classification
     */
    public GovernanceDriver deleteGovernanceDriverClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteGovernanceDriverClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       GovernanceDriver declassifiedGovernanceDriver =  GovernanceDriverMapper.mapOmrsEntityDetailToGovernanceDriver(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedGovernanceDriver;
    }

    /**
      * Get the relationships associated with entity governanceDriver represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the governanceDriver
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getGovernanceDriverRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getGovernanceDriverRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an organization given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the organizations relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return Organization the Organization entity with the requested GUID
     */
    public Organization getOrganization(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getOrganization";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        Organization gotorganization = OrganizationMapper.mapOmrsEntityDetailToOrganization(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotorganization );
        }
        return gotorganization;

    }
    /**
     * Create new organization.
     * @param userId user identity
     * @param organization the input entity with values.
     * @return Organization the created entity.
     */

    public Organization createOrganization(String userId,Organization organization)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createOrganization";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = OrganizationMapper.mapOrganizationToOmrsEntityDetail(organization);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        Organization createdOrganization =  OrganizationMapper.mapOmrsEntityDetailToOrganization(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created Organization="+ createdOrganization );
        }
        return createdOrganization;
    }
    /**
     * Update organization
     * @param userId user identity
     * @param organization   organization to update
     * @return Organization the updated organization entity
     */
    public Organization updateOrganization(String userId, Organization organization)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateOrganization";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = OrganizationMapper.mapOrganizationToOmrsEntityDetail(organization);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            Organization updatedOrganization =  OrganizationMapper.mapOmrsEntityDetailToOrganization(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated Organization="+ updatedOrganization );
            }
            return updatedOrganization;
        }

    /**
     * Delete an organization identified by its GUID. Delete is a soft delete, this means that the organization has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the organization
     * @return Organization the deleted Organization entity
     */

    public Organization deleteOrganization(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteOrganization";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Organization type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Organization");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"Organization",entityDef.getGUID(),entityGuid);
         Organization deletedOrganization = OrganizationMapper.mapOmrsEntityDetailToOrganization(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedOrganization;

    }
    /**
     * Purge an organization identified by its GUID. Delete is a hard delete, this means that the organization is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the organization
     */
    public void purgeOrganization(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeOrganization";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Organization type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Organization");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"Organization",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an Organization identified by its GUID. Restore resurrects a soft deleted Organization. When a Organization was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the Organization
     * @return  Organization the restored Organization
     */
    public Organization restoreOrganization(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreOrganization";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        Organization restoredOrganization =  OrganizationMapper.mapOmrsEntityDetailToOrganization(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredOrganization;
    }    

    /**
     * Add classifications to the supplied organization
     * @param userId user identity
     * @param entityGuid the GUID value for organization
     * @param classifications the classifications to apply.
     * @return the organization entity that has been classified
     */
     public Organization addOrganizationClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addOrganizationClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         Organization organizationClassificationBeans = OrganizationMapper.mapOmrsEntityDetailToOrganization(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified Organization=" +  organizationClassificationBeans);
         }
         return  organizationClassificationBeans;
    }

    /**
     * Updates classifications to an existing organization represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the organization
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given organization guid
     */
    public Organization updateOrganizationClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateOrganizationClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           Organization  organizationClassificationBeans = OrganizationMapper.mapOmrsEntityDetailToOrganization(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  organizationClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing organization represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the organization
     * @param name name of the classification
     * @return deleted Organization  classification
     */
    public Organization deleteOrganizationClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteOrganizationClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       Organization declassifiedOrganization =  OrganizationMapper.mapOmrsEntityDetailToOrganization(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedOrganization;
    }

    /**
      * Get the relationships associated with entity organization represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the organization
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getOrganizationRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getOrganizationRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an meeting given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the meetings relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return Meeting the Meeting entity with the requested GUID
     */
    public Meeting getMeeting(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getMeeting";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        Meeting gotmeeting = MeetingMapper.mapOmrsEntityDetailToMeeting(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotmeeting );
        }
        return gotmeeting;

    }
    /**
     * Create new meeting.
     * @param userId user identity
     * @param meeting the input entity with values.
     * @return Meeting the created entity.
     */

    public Meeting createMeeting(String userId,Meeting meeting)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createMeeting";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = MeetingMapper.mapMeetingToOmrsEntityDetail(meeting);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        Meeting createdMeeting =  MeetingMapper.mapOmrsEntityDetailToMeeting(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created Meeting="+ createdMeeting );
        }
        return createdMeeting;
    }
    /**
     * Update meeting
     * @param userId user identity
     * @param meeting   meeting to update
     * @return Meeting the updated meeting entity
     */
    public Meeting updateMeeting(String userId, Meeting meeting)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateMeeting";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = MeetingMapper.mapMeetingToOmrsEntityDetail(meeting);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            Meeting updatedMeeting =  MeetingMapper.mapOmrsEntityDetailToMeeting(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated Meeting="+ updatedMeeting );
            }
            return updatedMeeting;
        }

    /**
     * Delete an meeting identified by its GUID. Delete is a soft delete, this means that the meeting has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the meeting
     * @return Meeting the deleted Meeting entity
     */

    public Meeting deleteMeeting(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteMeeting";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Meeting type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Meeting");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"Meeting",entityDef.getGUID(),entityGuid);
         Meeting deletedMeeting = MeetingMapper.mapOmrsEntityDetailToMeeting(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedMeeting;

    }
    /**
     * Purge an meeting identified by its GUID. Delete is a hard delete, this means that the meeting is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the meeting
     */
    public void purgeMeeting(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeMeeting";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Meeting type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Meeting");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"Meeting",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an Meeting identified by its GUID. Restore resurrects a soft deleted Meeting. When a Meeting was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the Meeting
     * @return  Meeting the restored Meeting
     */
    public Meeting restoreMeeting(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreMeeting";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        Meeting restoredMeeting =  MeetingMapper.mapOmrsEntityDetailToMeeting(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredMeeting;
    }    

    /**
     * Add classifications to the supplied meeting
     * @param userId user identity
     * @param entityGuid the GUID value for meeting
     * @param classifications the classifications to apply.
     * @return the meeting entity that has been classified
     */
     public Meeting addMeetingClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addMeetingClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         Meeting meetingClassificationBeans = MeetingMapper.mapOmrsEntityDetailToMeeting(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified Meeting=" +  meetingClassificationBeans);
         }
         return  meetingClassificationBeans;
    }

    /**
     * Updates classifications to an existing meeting represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the meeting
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given meeting guid
     */
    public Meeting updateMeetingClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateMeetingClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           Meeting  meetingClassificationBeans = MeetingMapper.mapOmrsEntityDetailToMeeting(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  meetingClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing meeting represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the meeting
     * @param name name of the classification
     * @return deleted Meeting  classification
     */
    public Meeting deleteMeetingClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteMeetingClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       Meeting declassifiedMeeting =  MeetingMapper.mapOmrsEntityDetailToMeeting(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedMeeting;
    }

    /**
      * Get the relationships associated with entity meeting represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the meeting
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getMeetingRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getMeetingRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an softwareServerPlatform given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the softwareServerPlatforms relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return SoftwareServerPlatform the SoftwareServerPlatform entity with the requested GUID
     */
    public SoftwareServerPlatform getSoftwareServerPlatform(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getSoftwareServerPlatform";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        SoftwareServerPlatform gotsoftwareServerPlatform = SoftwareServerPlatformMapper.mapOmrsEntityDetailToSoftwareServerPlatform(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotsoftwareServerPlatform );
        }
        return gotsoftwareServerPlatform;

    }
    /**
     * Create new softwareServerPlatform.
     * @param userId user identity
     * @param softwareServerPlatform the input entity with values.
     * @return SoftwareServerPlatform the created entity.
     */

    public SoftwareServerPlatform createSoftwareServerPlatform(String userId,SoftwareServerPlatform softwareServerPlatform)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createSoftwareServerPlatform";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = SoftwareServerPlatformMapper.mapSoftwareServerPlatformToOmrsEntityDetail(softwareServerPlatform);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        SoftwareServerPlatform createdSoftwareServerPlatform =  SoftwareServerPlatformMapper.mapOmrsEntityDetailToSoftwareServerPlatform(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created SoftwareServerPlatform="+ createdSoftwareServerPlatform );
        }
        return createdSoftwareServerPlatform;
    }
    /**
     * Update softwareServerPlatform
     * @param userId user identity
     * @param softwareServerPlatform   softwareServerPlatform to update
     * @return SoftwareServerPlatform the updated softwareServerPlatform entity
     */
    public SoftwareServerPlatform updateSoftwareServerPlatform(String userId, SoftwareServerPlatform softwareServerPlatform)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateSoftwareServerPlatform";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = SoftwareServerPlatformMapper.mapSoftwareServerPlatformToOmrsEntityDetail(softwareServerPlatform);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            SoftwareServerPlatform updatedSoftwareServerPlatform =  SoftwareServerPlatformMapper.mapOmrsEntityDetailToSoftwareServerPlatform(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated SoftwareServerPlatform="+ updatedSoftwareServerPlatform );
            }
            return updatedSoftwareServerPlatform;
        }

    /**
     * Delete an softwareServerPlatform identified by its GUID. Delete is a soft delete, this means that the softwareServerPlatform has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the softwareServerPlatform
     * @return SoftwareServerPlatform the deleted SoftwareServerPlatform entity
     */

    public SoftwareServerPlatform deleteSoftwareServerPlatform(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteSoftwareServerPlatform";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the SoftwareServerPlatform type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("SoftwareServerPlatform");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"SoftwareServerPlatform",entityDef.getGUID(),entityGuid);
         SoftwareServerPlatform deletedSoftwareServerPlatform = SoftwareServerPlatformMapper.mapOmrsEntityDetailToSoftwareServerPlatform(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedSoftwareServerPlatform;

    }
    /**
     * Purge an softwareServerPlatform identified by its GUID. Delete is a hard delete, this means that the softwareServerPlatform is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the softwareServerPlatform
     */
    public void purgeSoftwareServerPlatform(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeSoftwareServerPlatform";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the SoftwareServerPlatform type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("SoftwareServerPlatform");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"SoftwareServerPlatform",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an SoftwareServerPlatform identified by its GUID. Restore resurrects a soft deleted SoftwareServerPlatform. When a SoftwareServerPlatform was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the SoftwareServerPlatform
     * @return  SoftwareServerPlatform the restored SoftwareServerPlatform
     */
    public SoftwareServerPlatform restoreSoftwareServerPlatform(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreSoftwareServerPlatform";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        SoftwareServerPlatform restoredSoftwareServerPlatform =  SoftwareServerPlatformMapper.mapOmrsEntityDetailToSoftwareServerPlatform(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredSoftwareServerPlatform;
    }    

    /**
     * Add classifications to the supplied softwareServerPlatform
     * @param userId user identity
     * @param entityGuid the GUID value for softwareServerPlatform
     * @param classifications the classifications to apply.
     * @return the softwareServerPlatform entity that has been classified
     */
     public SoftwareServerPlatform addSoftwareServerPlatformClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addSoftwareServerPlatformClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         SoftwareServerPlatform softwareServerPlatformClassificationBeans = SoftwareServerPlatformMapper.mapOmrsEntityDetailToSoftwareServerPlatform(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified SoftwareServerPlatform=" +  softwareServerPlatformClassificationBeans);
         }
         return  softwareServerPlatformClassificationBeans;
    }

    /**
     * Updates classifications to an existing softwareServerPlatform represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the softwareServerPlatform
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given softwareServerPlatform guid
     */
    public SoftwareServerPlatform updateSoftwareServerPlatformClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateSoftwareServerPlatformClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           SoftwareServerPlatform  softwareServerPlatformClassificationBeans = SoftwareServerPlatformMapper.mapOmrsEntityDetailToSoftwareServerPlatform(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  softwareServerPlatformClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing softwareServerPlatform represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the softwareServerPlatform
     * @param name name of the classification
     * @return deleted SoftwareServerPlatform  classification
     */
    public SoftwareServerPlatform deleteSoftwareServerPlatformClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteSoftwareServerPlatformClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       SoftwareServerPlatform declassifiedSoftwareServerPlatform =  SoftwareServerPlatformMapper.mapOmrsEntityDetailToSoftwareServerPlatform(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedSoftwareServerPlatform;
    }

    /**
      * Get the relationships associated with entity softwareServerPlatform represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the softwareServerPlatform
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getSoftwareServerPlatformRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getSoftwareServerPlatformRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an openDiscoveryEngine given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the openDiscoveryEngines relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return OpenDiscoveryEngine the OpenDiscoveryEngine entity with the requested GUID
     */
    public OpenDiscoveryEngine getOpenDiscoveryEngine(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getOpenDiscoveryEngine";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        OpenDiscoveryEngine gotopenDiscoveryEngine = OpenDiscoveryEngineMapper.mapOmrsEntityDetailToOpenDiscoveryEngine(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotopenDiscoveryEngine );
        }
        return gotopenDiscoveryEngine;

    }
    /**
     * Create new openDiscoveryEngine.
     * @param userId user identity
     * @param openDiscoveryEngine the input entity with values.
     * @return OpenDiscoveryEngine the created entity.
     */

    public OpenDiscoveryEngine createOpenDiscoveryEngine(String userId,OpenDiscoveryEngine openDiscoveryEngine)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createOpenDiscoveryEngine";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = OpenDiscoveryEngineMapper.mapOpenDiscoveryEngineToOmrsEntityDetail(openDiscoveryEngine);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        OpenDiscoveryEngine createdOpenDiscoveryEngine =  OpenDiscoveryEngineMapper.mapOmrsEntityDetailToOpenDiscoveryEngine(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created OpenDiscoveryEngine="+ createdOpenDiscoveryEngine );
        }
        return createdOpenDiscoveryEngine;
    }
    /**
     * Update openDiscoveryEngine
     * @param userId user identity
     * @param openDiscoveryEngine   openDiscoveryEngine to update
     * @return OpenDiscoveryEngine the updated openDiscoveryEngine entity
     */
    public OpenDiscoveryEngine updateOpenDiscoveryEngine(String userId, OpenDiscoveryEngine openDiscoveryEngine)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateOpenDiscoveryEngine";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = OpenDiscoveryEngineMapper.mapOpenDiscoveryEngineToOmrsEntityDetail(openDiscoveryEngine);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            OpenDiscoveryEngine updatedOpenDiscoveryEngine =  OpenDiscoveryEngineMapper.mapOmrsEntityDetailToOpenDiscoveryEngine(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated OpenDiscoveryEngine="+ updatedOpenDiscoveryEngine );
            }
            return updatedOpenDiscoveryEngine;
        }

    /**
     * Delete an openDiscoveryEngine identified by its GUID. Delete is a soft delete, this means that the openDiscoveryEngine has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the openDiscoveryEngine
     * @return OpenDiscoveryEngine the deleted OpenDiscoveryEngine entity
     */

    public OpenDiscoveryEngine deleteOpenDiscoveryEngine(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteOpenDiscoveryEngine";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the OpenDiscoveryEngine type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("OpenDiscoveryEngine");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"OpenDiscoveryEngine",entityDef.getGUID(),entityGuid);
         OpenDiscoveryEngine deletedOpenDiscoveryEngine = OpenDiscoveryEngineMapper.mapOmrsEntityDetailToOpenDiscoveryEngine(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedOpenDiscoveryEngine;

    }
    /**
     * Purge an openDiscoveryEngine identified by its GUID. Delete is a hard delete, this means that the openDiscoveryEngine is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the openDiscoveryEngine
     */
    public void purgeOpenDiscoveryEngine(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeOpenDiscoveryEngine";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the OpenDiscoveryEngine type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("OpenDiscoveryEngine");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"OpenDiscoveryEngine",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an OpenDiscoveryEngine identified by its GUID. Restore resurrects a soft deleted OpenDiscoveryEngine. When a OpenDiscoveryEngine was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the OpenDiscoveryEngine
     * @return  OpenDiscoveryEngine the restored OpenDiscoveryEngine
     */
    public OpenDiscoveryEngine restoreOpenDiscoveryEngine(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreOpenDiscoveryEngine";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        OpenDiscoveryEngine restoredOpenDiscoveryEngine =  OpenDiscoveryEngineMapper.mapOmrsEntityDetailToOpenDiscoveryEngine(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredOpenDiscoveryEngine;
    }    

    /**
     * Add classifications to the supplied openDiscoveryEngine
     * @param userId user identity
     * @param entityGuid the GUID value for openDiscoveryEngine
     * @param classifications the classifications to apply.
     * @return the openDiscoveryEngine entity that has been classified
     */
     public OpenDiscoveryEngine addOpenDiscoveryEngineClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addOpenDiscoveryEngineClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         OpenDiscoveryEngine openDiscoveryEngineClassificationBeans = OpenDiscoveryEngineMapper.mapOmrsEntityDetailToOpenDiscoveryEngine(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified OpenDiscoveryEngine=" +  openDiscoveryEngineClassificationBeans);
         }
         return  openDiscoveryEngineClassificationBeans;
    }

    /**
     * Updates classifications to an existing openDiscoveryEngine represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the openDiscoveryEngine
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given openDiscoveryEngine guid
     */
    public OpenDiscoveryEngine updateOpenDiscoveryEngineClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateOpenDiscoveryEngineClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           OpenDiscoveryEngine  openDiscoveryEngineClassificationBeans = OpenDiscoveryEngineMapper.mapOmrsEntityDetailToOpenDiscoveryEngine(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  openDiscoveryEngineClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing openDiscoveryEngine represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the openDiscoveryEngine
     * @param name name of the classification
     * @return deleted OpenDiscoveryEngine  classification
     */
    public OpenDiscoveryEngine deleteOpenDiscoveryEngineClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteOpenDiscoveryEngineClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       OpenDiscoveryEngine declassifiedOpenDiscoveryEngine =  OpenDiscoveryEngineMapper.mapOmrsEntityDetailToOpenDiscoveryEngine(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedOpenDiscoveryEngine;
    }

    /**
      * Get the relationships associated with entity openDiscoveryEngine represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the openDiscoveryEngine
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getOpenDiscoveryEngineRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getOpenDiscoveryEngineRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an dataFieldAnnotation given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the dataFieldAnnotations relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return DataFieldAnnotation the DataFieldAnnotation entity with the requested GUID
     */
    public DataFieldAnnotation getDataFieldAnnotation(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getDataFieldAnnotation";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        DataFieldAnnotation gotdataFieldAnnotation = DataFieldAnnotationMapper.mapOmrsEntityDetailToDataFieldAnnotation(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotdataFieldAnnotation );
        }
        return gotdataFieldAnnotation;

    }
    /**
     * Create new dataFieldAnnotation.
     * @param userId user identity
     * @param dataFieldAnnotation the input entity with values.
     * @return DataFieldAnnotation the created entity.
     */

    public DataFieldAnnotation createDataFieldAnnotation(String userId,DataFieldAnnotation dataFieldAnnotation)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createDataFieldAnnotation";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = DataFieldAnnotationMapper.mapDataFieldAnnotationToOmrsEntityDetail(dataFieldAnnotation);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        DataFieldAnnotation createdDataFieldAnnotation =  DataFieldAnnotationMapper.mapOmrsEntityDetailToDataFieldAnnotation(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created DataFieldAnnotation="+ createdDataFieldAnnotation );
        }
        return createdDataFieldAnnotation;
    }
    /**
     * Update dataFieldAnnotation
     * @param userId user identity
     * @param dataFieldAnnotation   dataFieldAnnotation to update
     * @return DataFieldAnnotation the updated dataFieldAnnotation entity
     */
    public DataFieldAnnotation updateDataFieldAnnotation(String userId, DataFieldAnnotation dataFieldAnnotation)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateDataFieldAnnotation";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = DataFieldAnnotationMapper.mapDataFieldAnnotationToOmrsEntityDetail(dataFieldAnnotation);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            DataFieldAnnotation updatedDataFieldAnnotation =  DataFieldAnnotationMapper.mapOmrsEntityDetailToDataFieldAnnotation(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated DataFieldAnnotation="+ updatedDataFieldAnnotation );
            }
            return updatedDataFieldAnnotation;
        }

    /**
     * Delete an dataFieldAnnotation identified by its GUID. Delete is a soft delete, this means that the dataFieldAnnotation has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the dataFieldAnnotation
     * @return DataFieldAnnotation the deleted DataFieldAnnotation entity
     */

    public DataFieldAnnotation deleteDataFieldAnnotation(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteDataFieldAnnotation";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DataFieldAnnotation type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DataFieldAnnotation");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"DataFieldAnnotation",entityDef.getGUID(),entityGuid);
         DataFieldAnnotation deletedDataFieldAnnotation = DataFieldAnnotationMapper.mapOmrsEntityDetailToDataFieldAnnotation(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedDataFieldAnnotation;

    }
    /**
     * Purge an dataFieldAnnotation identified by its GUID. Delete is a hard delete, this means that the dataFieldAnnotation is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the dataFieldAnnotation
     */
    public void purgeDataFieldAnnotation(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeDataFieldAnnotation";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DataFieldAnnotation type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DataFieldAnnotation");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"DataFieldAnnotation",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an DataFieldAnnotation identified by its GUID. Restore resurrects a soft deleted DataFieldAnnotation. When a DataFieldAnnotation was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the DataFieldAnnotation
     * @return  DataFieldAnnotation the restored DataFieldAnnotation
     */
    public DataFieldAnnotation restoreDataFieldAnnotation(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreDataFieldAnnotation";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        DataFieldAnnotation restoredDataFieldAnnotation =  DataFieldAnnotationMapper.mapOmrsEntityDetailToDataFieldAnnotation(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredDataFieldAnnotation;
    }    

    /**
     * Add classifications to the supplied dataFieldAnnotation
     * @param userId user identity
     * @param entityGuid the GUID value for dataFieldAnnotation
     * @param classifications the classifications to apply.
     * @return the dataFieldAnnotation entity that has been classified
     */
     public DataFieldAnnotation addDataFieldAnnotationClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addDataFieldAnnotationClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         DataFieldAnnotation dataFieldAnnotationClassificationBeans = DataFieldAnnotationMapper.mapOmrsEntityDetailToDataFieldAnnotation(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified DataFieldAnnotation=" +  dataFieldAnnotationClassificationBeans);
         }
         return  dataFieldAnnotationClassificationBeans;
    }

    /**
     * Updates classifications to an existing dataFieldAnnotation represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the dataFieldAnnotation
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given dataFieldAnnotation guid
     */
    public DataFieldAnnotation updateDataFieldAnnotationClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateDataFieldAnnotationClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           DataFieldAnnotation  dataFieldAnnotationClassificationBeans = DataFieldAnnotationMapper.mapOmrsEntityDetailToDataFieldAnnotation(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  dataFieldAnnotationClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing dataFieldAnnotation represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the dataFieldAnnotation
     * @param name name of the classification
     * @return deleted DataFieldAnnotation  classification
     */
    public DataFieldAnnotation deleteDataFieldAnnotationClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteDataFieldAnnotationClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       DataFieldAnnotation declassifiedDataFieldAnnotation =  DataFieldAnnotationMapper.mapOmrsEntityDetailToDataFieldAnnotation(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedDataFieldAnnotation;
    }

    /**
      * Get the relationships associated with entity dataFieldAnnotation represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the dataFieldAnnotation
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getDataFieldAnnotationRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getDataFieldAnnotationRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an dataProfileLogAnnotation given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the dataProfileLogAnnotations relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return DataProfileLogAnnotation the DataProfileLogAnnotation entity with the requested GUID
     */
    public DataProfileLogAnnotation getDataProfileLogAnnotation(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getDataProfileLogAnnotation";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        DataProfileLogAnnotation gotdataProfileLogAnnotation = DataProfileLogAnnotationMapper.mapOmrsEntityDetailToDataProfileLogAnnotation(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotdataProfileLogAnnotation );
        }
        return gotdataProfileLogAnnotation;

    }
    /**
     * Create new dataProfileLogAnnotation.
     * @param userId user identity
     * @param dataProfileLogAnnotation the input entity with values.
     * @return DataProfileLogAnnotation the created entity.
     */

    public DataProfileLogAnnotation createDataProfileLogAnnotation(String userId,DataProfileLogAnnotation dataProfileLogAnnotation)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createDataProfileLogAnnotation";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = DataProfileLogAnnotationMapper.mapDataProfileLogAnnotationToOmrsEntityDetail(dataProfileLogAnnotation);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        DataProfileLogAnnotation createdDataProfileLogAnnotation =  DataProfileLogAnnotationMapper.mapOmrsEntityDetailToDataProfileLogAnnotation(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created DataProfileLogAnnotation="+ createdDataProfileLogAnnotation );
        }
        return createdDataProfileLogAnnotation;
    }
    /**
     * Update dataProfileLogAnnotation
     * @param userId user identity
     * @param dataProfileLogAnnotation   dataProfileLogAnnotation to update
     * @return DataProfileLogAnnotation the updated dataProfileLogAnnotation entity
     */
    public DataProfileLogAnnotation updateDataProfileLogAnnotation(String userId, DataProfileLogAnnotation dataProfileLogAnnotation)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateDataProfileLogAnnotation";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = DataProfileLogAnnotationMapper.mapDataProfileLogAnnotationToOmrsEntityDetail(dataProfileLogAnnotation);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            DataProfileLogAnnotation updatedDataProfileLogAnnotation =  DataProfileLogAnnotationMapper.mapOmrsEntityDetailToDataProfileLogAnnotation(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated DataProfileLogAnnotation="+ updatedDataProfileLogAnnotation );
            }
            return updatedDataProfileLogAnnotation;
        }

    /**
     * Delete an dataProfileLogAnnotation identified by its GUID. Delete is a soft delete, this means that the dataProfileLogAnnotation has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the dataProfileLogAnnotation
     * @return DataProfileLogAnnotation the deleted DataProfileLogAnnotation entity
     */

    public DataProfileLogAnnotation deleteDataProfileLogAnnotation(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteDataProfileLogAnnotation";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DataProfileLogAnnotation type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DataProfileLogAnnotation");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"DataProfileLogAnnotation",entityDef.getGUID(),entityGuid);
         DataProfileLogAnnotation deletedDataProfileLogAnnotation = DataProfileLogAnnotationMapper.mapOmrsEntityDetailToDataProfileLogAnnotation(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedDataProfileLogAnnotation;

    }
    /**
     * Purge an dataProfileLogAnnotation identified by its GUID. Delete is a hard delete, this means that the dataProfileLogAnnotation is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the dataProfileLogAnnotation
     */
    public void purgeDataProfileLogAnnotation(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeDataProfileLogAnnotation";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DataProfileLogAnnotation type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DataProfileLogAnnotation");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"DataProfileLogAnnotation",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an DataProfileLogAnnotation identified by its GUID. Restore resurrects a soft deleted DataProfileLogAnnotation. When a DataProfileLogAnnotation was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the DataProfileLogAnnotation
     * @return  DataProfileLogAnnotation the restored DataProfileLogAnnotation
     */
    public DataProfileLogAnnotation restoreDataProfileLogAnnotation(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreDataProfileLogAnnotation";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        DataProfileLogAnnotation restoredDataProfileLogAnnotation =  DataProfileLogAnnotationMapper.mapOmrsEntityDetailToDataProfileLogAnnotation(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredDataProfileLogAnnotation;
    }    

    /**
     * Add classifications to the supplied dataProfileLogAnnotation
     * @param userId user identity
     * @param entityGuid the GUID value for dataProfileLogAnnotation
     * @param classifications the classifications to apply.
     * @return the dataProfileLogAnnotation entity that has been classified
     */
     public DataProfileLogAnnotation addDataProfileLogAnnotationClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addDataProfileLogAnnotationClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         DataProfileLogAnnotation dataProfileLogAnnotationClassificationBeans = DataProfileLogAnnotationMapper.mapOmrsEntityDetailToDataProfileLogAnnotation(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified DataProfileLogAnnotation=" +  dataProfileLogAnnotationClassificationBeans);
         }
         return  dataProfileLogAnnotationClassificationBeans;
    }

    /**
     * Updates classifications to an existing dataProfileLogAnnotation represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the dataProfileLogAnnotation
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given dataProfileLogAnnotation guid
     */
    public DataProfileLogAnnotation updateDataProfileLogAnnotationClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateDataProfileLogAnnotationClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           DataProfileLogAnnotation  dataProfileLogAnnotationClassificationBeans = DataProfileLogAnnotationMapper.mapOmrsEntityDetailToDataProfileLogAnnotation(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  dataProfileLogAnnotationClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing dataProfileLogAnnotation represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the dataProfileLogAnnotation
     * @param name name of the classification
     * @return deleted DataProfileLogAnnotation  classification
     */
    public DataProfileLogAnnotation deleteDataProfileLogAnnotationClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteDataProfileLogAnnotationClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       DataProfileLogAnnotation declassifiedDataProfileLogAnnotation =  DataProfileLogAnnotationMapper.mapOmrsEntityDetailToDataProfileLogAnnotation(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedDataProfileLogAnnotation;
    }

    /**
      * Get the relationships associated with entity dataProfileLogAnnotation represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the dataProfileLogAnnotation
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getDataProfileLogAnnotationRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getDataProfileLogAnnotationRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an noteLogAuthor given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the noteLogAuthors relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return NoteLogAuthor the NoteLogAuthor entity with the requested GUID
     */
    public NoteLogAuthor getNoteLogAuthor(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getNoteLogAuthor";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        NoteLogAuthor gotnoteLogAuthor = NoteLogAuthorMapper.mapOmrsEntityDetailToNoteLogAuthor(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotnoteLogAuthor );
        }
        return gotnoteLogAuthor;

    }
    /**
     * Create new noteLogAuthor.
     * @param userId user identity
     * @param noteLogAuthor the input entity with values.
     * @return NoteLogAuthor the created entity.
     */

    public NoteLogAuthor createNoteLogAuthor(String userId,NoteLogAuthor noteLogAuthor)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createNoteLogAuthor";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = NoteLogAuthorMapper.mapNoteLogAuthorToOmrsEntityDetail(noteLogAuthor);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        NoteLogAuthor createdNoteLogAuthor =  NoteLogAuthorMapper.mapOmrsEntityDetailToNoteLogAuthor(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created NoteLogAuthor="+ createdNoteLogAuthor );
        }
        return createdNoteLogAuthor;
    }
    /**
     * Update noteLogAuthor
     * @param userId user identity
     * @param noteLogAuthor   noteLogAuthor to update
     * @return NoteLogAuthor the updated noteLogAuthor entity
     */
    public NoteLogAuthor updateNoteLogAuthor(String userId, NoteLogAuthor noteLogAuthor)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateNoteLogAuthor";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = NoteLogAuthorMapper.mapNoteLogAuthorToOmrsEntityDetail(noteLogAuthor);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            NoteLogAuthor updatedNoteLogAuthor =  NoteLogAuthorMapper.mapOmrsEntityDetailToNoteLogAuthor(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated NoteLogAuthor="+ updatedNoteLogAuthor );
            }
            return updatedNoteLogAuthor;
        }

    /**
     * Delete an noteLogAuthor identified by its GUID. Delete is a soft delete, this means that the noteLogAuthor has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the noteLogAuthor
     * @return NoteLogAuthor the deleted NoteLogAuthor entity
     */

    public NoteLogAuthor deleteNoteLogAuthor(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteNoteLogAuthor";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the NoteLogAuthor type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("NoteLogAuthor");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"NoteLogAuthor",entityDef.getGUID(),entityGuid);
         NoteLogAuthor deletedNoteLogAuthor = NoteLogAuthorMapper.mapOmrsEntityDetailToNoteLogAuthor(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedNoteLogAuthor;

    }
    /**
     * Purge an noteLogAuthor identified by its GUID. Delete is a hard delete, this means that the noteLogAuthor is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the noteLogAuthor
     */
    public void purgeNoteLogAuthor(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeNoteLogAuthor";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the NoteLogAuthor type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("NoteLogAuthor");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"NoteLogAuthor",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an NoteLogAuthor identified by its GUID. Restore resurrects a soft deleted NoteLogAuthor. When a NoteLogAuthor was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the NoteLogAuthor
     * @return  NoteLogAuthor the restored NoteLogAuthor
     */
    public NoteLogAuthor restoreNoteLogAuthor(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreNoteLogAuthor";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        NoteLogAuthor restoredNoteLogAuthor =  NoteLogAuthorMapper.mapOmrsEntityDetailToNoteLogAuthor(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredNoteLogAuthor;
    }    

    /**
     * Add classifications to the supplied noteLogAuthor
     * @param userId user identity
     * @param entityGuid the GUID value for noteLogAuthor
     * @param classifications the classifications to apply.
     * @return the noteLogAuthor entity that has been classified
     */
     public NoteLogAuthor addNoteLogAuthorClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addNoteLogAuthorClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         NoteLogAuthor noteLogAuthorClassificationBeans = NoteLogAuthorMapper.mapOmrsEntityDetailToNoteLogAuthor(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified NoteLogAuthor=" +  noteLogAuthorClassificationBeans);
         }
         return  noteLogAuthorClassificationBeans;
    }

    /**
     * Updates classifications to an existing noteLogAuthor represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the noteLogAuthor
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given noteLogAuthor guid
     */
    public NoteLogAuthor updateNoteLogAuthorClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateNoteLogAuthorClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           NoteLogAuthor  noteLogAuthorClassificationBeans = NoteLogAuthorMapper.mapOmrsEntityDetailToNoteLogAuthor(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  noteLogAuthorClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing noteLogAuthor represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the noteLogAuthor
     * @param name name of the classification
     * @return deleted NoteLogAuthor  classification
     */
    public NoteLogAuthor deleteNoteLogAuthorClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteNoteLogAuthorClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       NoteLogAuthor declassifiedNoteLogAuthor =  NoteLogAuthorMapper.mapOmrsEntityDetailToNoteLogAuthor(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedNoteLogAuthor;
    }

    /**
      * Get the relationships associated with entity noteLogAuthor represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the noteLogAuthor
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getNoteLogAuthorRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getNoteLogAuthorRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an logFile given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the logFiles relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return LogFile the LogFile entity with the requested GUID
     */
    public LogFile getLogFile(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getLogFile";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        LogFile gotlogFile = LogFileMapper.mapOmrsEntityDetailToLogFile(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotlogFile );
        }
        return gotlogFile;

    }
    /**
     * Create new logFile.
     * @param userId user identity
     * @param logFile the input entity with values.
     * @return LogFile the created entity.
     */

    public LogFile createLogFile(String userId,LogFile logFile)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createLogFile";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = LogFileMapper.mapLogFileToOmrsEntityDetail(logFile);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        LogFile createdLogFile =  LogFileMapper.mapOmrsEntityDetailToLogFile(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created LogFile="+ createdLogFile );
        }
        return createdLogFile;
    }
    /**
     * Update logFile
     * @param userId user identity
     * @param logFile   logFile to update
     * @return LogFile the updated logFile entity
     */
    public LogFile updateLogFile(String userId, LogFile logFile)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateLogFile";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = LogFileMapper.mapLogFileToOmrsEntityDetail(logFile);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            LogFile updatedLogFile =  LogFileMapper.mapOmrsEntityDetailToLogFile(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated LogFile="+ updatedLogFile );
            }
            return updatedLogFile;
        }

    /**
     * Delete an logFile identified by its GUID. Delete is a soft delete, this means that the logFile has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the logFile
     * @return LogFile the deleted LogFile entity
     */

    public LogFile deleteLogFile(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteLogFile";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the LogFile type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("LogFile");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"LogFile",entityDef.getGUID(),entityGuid);
         LogFile deletedLogFile = LogFileMapper.mapOmrsEntityDetailToLogFile(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedLogFile;

    }
    /**
     * Purge an logFile identified by its GUID. Delete is a hard delete, this means that the logFile is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the logFile
     */
    public void purgeLogFile(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeLogFile";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the LogFile type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("LogFile");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"LogFile",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an LogFile identified by its GUID. Restore resurrects a soft deleted LogFile. When a LogFile was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the LogFile
     * @return  LogFile the restored LogFile
     */
    public LogFile restoreLogFile(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreLogFile";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        LogFile restoredLogFile =  LogFileMapper.mapOmrsEntityDetailToLogFile(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredLogFile;
    }    

    /**
     * Add classifications to the supplied logFile
     * @param userId user identity
     * @param entityGuid the GUID value for logFile
     * @param classifications the classifications to apply.
     * @return the logFile entity that has been classified
     */
     public LogFile addLogFileClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addLogFileClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         LogFile logFileClassificationBeans = LogFileMapper.mapOmrsEntityDetailToLogFile(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified LogFile=" +  logFileClassificationBeans);
         }
         return  logFileClassificationBeans;
    }

    /**
     * Updates classifications to an existing logFile represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the logFile
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given logFile guid
     */
    public LogFile updateLogFileClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateLogFileClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           LogFile  logFileClassificationBeans = LogFileMapper.mapOmrsEntityDetailToLogFile(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  logFileClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing logFile represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the logFile
     * @param name name of the classification
     * @return deleted LogFile  classification
     */
    public LogFile deleteLogFileClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteLogFileClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       LogFile declassifiedLogFile =  LogFileMapper.mapOmrsEntityDetailToLogFile(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedLogFile;
    }

    /**
      * Get the relationships associated with entity logFile represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the logFile
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getLogFileRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getLogFileRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an metadataRepository given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the metadataRepositories relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return MetadataRepository the MetadataRepository entity with the requested GUID
     */
    public MetadataRepository getMetadataRepository(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getMetadataRepository";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        MetadataRepository gotmetadataRepository = MetadataRepositoryMapper.mapOmrsEntityDetailToMetadataRepository(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotmetadataRepository );
        }
        return gotmetadataRepository;

    }
    /**
     * Create new metadataRepository.
     * @param userId user identity
     * @param metadataRepository the input entity with values.
     * @return MetadataRepository the created entity.
     */

    public MetadataRepository createMetadataRepository(String userId,MetadataRepository metadataRepository)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createMetadataRepository";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = MetadataRepositoryMapper.mapMetadataRepositoryToOmrsEntityDetail(metadataRepository);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        MetadataRepository createdMetadataRepository =  MetadataRepositoryMapper.mapOmrsEntityDetailToMetadataRepository(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created MetadataRepository="+ createdMetadataRepository );
        }
        return createdMetadataRepository;
    }
    /**
     * Update metadataRepository
     * @param userId user identity
     * @param metadataRepository   metadataRepository to update
     * @return MetadataRepository the updated metadataRepository entity
     */
    public MetadataRepository updateMetadataRepository(String userId, MetadataRepository metadataRepository)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateMetadataRepository";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = MetadataRepositoryMapper.mapMetadataRepositoryToOmrsEntityDetail(metadataRepository);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            MetadataRepository updatedMetadataRepository =  MetadataRepositoryMapper.mapOmrsEntityDetailToMetadataRepository(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated MetadataRepository="+ updatedMetadataRepository );
            }
            return updatedMetadataRepository;
        }

    /**
     * Delete an metadataRepository identified by its GUID. Delete is a soft delete, this means that the metadataRepository has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the metadataRepository
     * @return MetadataRepository the deleted MetadataRepository entity
     */

    public MetadataRepository deleteMetadataRepository(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteMetadataRepository";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the MetadataRepository type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("MetadataRepository");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"MetadataRepository",entityDef.getGUID(),entityGuid);
         MetadataRepository deletedMetadataRepository = MetadataRepositoryMapper.mapOmrsEntityDetailToMetadataRepository(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedMetadataRepository;

    }
    /**
     * Purge an metadataRepository identified by its GUID. Delete is a hard delete, this means that the metadataRepository is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the metadataRepository
     */
    public void purgeMetadataRepository(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeMetadataRepository";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the MetadataRepository type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("MetadataRepository");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"MetadataRepository",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an MetadataRepository identified by its GUID. Restore resurrects a soft deleted MetadataRepository. When a MetadataRepository was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the MetadataRepository
     * @return  MetadataRepository the restored MetadataRepository
     */
    public MetadataRepository restoreMetadataRepository(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreMetadataRepository";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        MetadataRepository restoredMetadataRepository =  MetadataRepositoryMapper.mapOmrsEntityDetailToMetadataRepository(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredMetadataRepository;
    }    

    /**
     * Add classifications to the supplied metadataRepository
     * @param userId user identity
     * @param entityGuid the GUID value for metadataRepository
     * @param classifications the classifications to apply.
     * @return the metadataRepository entity that has been classified
     */
     public MetadataRepository addMetadataRepositoryClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addMetadataRepositoryClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         MetadataRepository metadataRepositoryClassificationBeans = MetadataRepositoryMapper.mapOmrsEntityDetailToMetadataRepository(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified MetadataRepository=" +  metadataRepositoryClassificationBeans);
         }
         return  metadataRepositoryClassificationBeans;
    }

    /**
     * Updates classifications to an existing metadataRepository represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the metadataRepository
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given metadataRepository guid
     */
    public MetadataRepository updateMetadataRepositoryClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateMetadataRepositoryClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           MetadataRepository  metadataRepositoryClassificationBeans = MetadataRepositoryMapper.mapOmrsEntityDetailToMetadataRepository(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  metadataRepositoryClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing metadataRepository represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the metadataRepository
     * @param name name of the classification
     * @return deleted MetadataRepository  classification
     */
    public MetadataRepository deleteMetadataRepositoryClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteMetadataRepositoryClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       MetadataRepository declassifiedMetadataRepository =  MetadataRepositoryMapper.mapOmrsEntityDetailToMetadataRepository(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedMetadataRepository;
    }

    /**
      * Get the relationships associated with entity metadataRepository represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the metadataRepository
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getMetadataRepositoryRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getMetadataRepositoryRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an keystoreFile given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the keystoreFiles relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return KeystoreFile the KeystoreFile entity with the requested GUID
     */
    public KeystoreFile getKeystoreFile(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getKeystoreFile";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        KeystoreFile gotkeystoreFile = KeystoreFileMapper.mapOmrsEntityDetailToKeystoreFile(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotkeystoreFile );
        }
        return gotkeystoreFile;

    }
    /**
     * Create new keystoreFile.
     * @param userId user identity
     * @param keystoreFile the input entity with values.
     * @return KeystoreFile the created entity.
     */

    public KeystoreFile createKeystoreFile(String userId,KeystoreFile keystoreFile)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createKeystoreFile";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = KeystoreFileMapper.mapKeystoreFileToOmrsEntityDetail(keystoreFile);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        KeystoreFile createdKeystoreFile =  KeystoreFileMapper.mapOmrsEntityDetailToKeystoreFile(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created KeystoreFile="+ createdKeystoreFile );
        }
        return createdKeystoreFile;
    }
    /**
     * Update keystoreFile
     * @param userId user identity
     * @param keystoreFile   keystoreFile to update
     * @return KeystoreFile the updated keystoreFile entity
     */
    public KeystoreFile updateKeystoreFile(String userId, KeystoreFile keystoreFile)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateKeystoreFile";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = KeystoreFileMapper.mapKeystoreFileToOmrsEntityDetail(keystoreFile);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            KeystoreFile updatedKeystoreFile =  KeystoreFileMapper.mapOmrsEntityDetailToKeystoreFile(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated KeystoreFile="+ updatedKeystoreFile );
            }
            return updatedKeystoreFile;
        }

    /**
     * Delete an keystoreFile identified by its GUID. Delete is a soft delete, this means that the keystoreFile has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the keystoreFile
     * @return KeystoreFile the deleted KeystoreFile entity
     */

    public KeystoreFile deleteKeystoreFile(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteKeystoreFile";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the KeystoreFile type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("KeystoreFile");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"KeystoreFile",entityDef.getGUID(),entityGuid);
         KeystoreFile deletedKeystoreFile = KeystoreFileMapper.mapOmrsEntityDetailToKeystoreFile(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedKeystoreFile;

    }
    /**
     * Purge an keystoreFile identified by its GUID. Delete is a hard delete, this means that the keystoreFile is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the keystoreFile
     */
    public void purgeKeystoreFile(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeKeystoreFile";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the KeystoreFile type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("KeystoreFile");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"KeystoreFile",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an KeystoreFile identified by its GUID. Restore resurrects a soft deleted KeystoreFile. When a KeystoreFile was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the KeystoreFile
     * @return  KeystoreFile the restored KeystoreFile
     */
    public KeystoreFile restoreKeystoreFile(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreKeystoreFile";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        KeystoreFile restoredKeystoreFile =  KeystoreFileMapper.mapOmrsEntityDetailToKeystoreFile(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredKeystoreFile;
    }    

    /**
     * Add classifications to the supplied keystoreFile
     * @param userId user identity
     * @param entityGuid the GUID value for keystoreFile
     * @param classifications the classifications to apply.
     * @return the keystoreFile entity that has been classified
     */
     public KeystoreFile addKeystoreFileClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addKeystoreFileClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         KeystoreFile keystoreFileClassificationBeans = KeystoreFileMapper.mapOmrsEntityDetailToKeystoreFile(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified KeystoreFile=" +  keystoreFileClassificationBeans);
         }
         return  keystoreFileClassificationBeans;
    }

    /**
     * Updates classifications to an existing keystoreFile represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the keystoreFile
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given keystoreFile guid
     */
    public KeystoreFile updateKeystoreFileClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateKeystoreFileClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           KeystoreFile  keystoreFileClassificationBeans = KeystoreFileMapper.mapOmrsEntityDetailToKeystoreFile(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  keystoreFileClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing keystoreFile represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the keystoreFile
     * @param name name of the classification
     * @return deleted KeystoreFile  classification
     */
    public KeystoreFile deleteKeystoreFileClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteKeystoreFileClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       KeystoreFile declassifiedKeystoreFile =  KeystoreFileMapper.mapOmrsEntityDetailToKeystoreFile(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedKeystoreFile;
    }

    /**
      * Get the relationships associated with entity keystoreFile represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the keystoreFile
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getKeystoreFileRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getKeystoreFileRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an documentSchemaType given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the documentSchemaTypes relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return DocumentSchemaType the DocumentSchemaType entity with the requested GUID
     */
    public DocumentSchemaType getDocumentSchemaType(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getDocumentSchemaType";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        DocumentSchemaType gotdocumentSchemaType = DocumentSchemaTypeMapper.mapOmrsEntityDetailToDocumentSchemaType(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotdocumentSchemaType );
        }
        return gotdocumentSchemaType;

    }
    /**
     * Create new documentSchemaType.
     * @param userId user identity
     * @param documentSchemaType the input entity with values.
     * @return DocumentSchemaType the created entity.
     */

    public DocumentSchemaType createDocumentSchemaType(String userId,DocumentSchemaType documentSchemaType)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createDocumentSchemaType";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = DocumentSchemaTypeMapper.mapDocumentSchemaTypeToOmrsEntityDetail(documentSchemaType);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        DocumentSchemaType createdDocumentSchemaType =  DocumentSchemaTypeMapper.mapOmrsEntityDetailToDocumentSchemaType(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created DocumentSchemaType="+ createdDocumentSchemaType );
        }
        return createdDocumentSchemaType;
    }
    /**
     * Update documentSchemaType
     * @param userId user identity
     * @param documentSchemaType   documentSchemaType to update
     * @return DocumentSchemaType the updated documentSchemaType entity
     */
    public DocumentSchemaType updateDocumentSchemaType(String userId, DocumentSchemaType documentSchemaType)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateDocumentSchemaType";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = DocumentSchemaTypeMapper.mapDocumentSchemaTypeToOmrsEntityDetail(documentSchemaType);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            DocumentSchemaType updatedDocumentSchemaType =  DocumentSchemaTypeMapper.mapOmrsEntityDetailToDocumentSchemaType(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated DocumentSchemaType="+ updatedDocumentSchemaType );
            }
            return updatedDocumentSchemaType;
        }

    /**
     * Delete an documentSchemaType identified by its GUID. Delete is a soft delete, this means that the documentSchemaType has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the documentSchemaType
     * @return DocumentSchemaType the deleted DocumentSchemaType entity
     */

    public DocumentSchemaType deleteDocumentSchemaType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteDocumentSchemaType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DocumentSchemaType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DocumentSchemaType");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"DocumentSchemaType",entityDef.getGUID(),entityGuid);
         DocumentSchemaType deletedDocumentSchemaType = DocumentSchemaTypeMapper.mapOmrsEntityDetailToDocumentSchemaType(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedDocumentSchemaType;

    }
    /**
     * Purge an documentSchemaType identified by its GUID. Delete is a hard delete, this means that the documentSchemaType is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the documentSchemaType
     */
    public void purgeDocumentSchemaType(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeDocumentSchemaType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DocumentSchemaType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DocumentSchemaType");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"DocumentSchemaType",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an DocumentSchemaType identified by its GUID. Restore resurrects a soft deleted DocumentSchemaType. When a DocumentSchemaType was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the DocumentSchemaType
     * @return  DocumentSchemaType the restored DocumentSchemaType
     */
    public DocumentSchemaType restoreDocumentSchemaType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreDocumentSchemaType";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        DocumentSchemaType restoredDocumentSchemaType =  DocumentSchemaTypeMapper.mapOmrsEntityDetailToDocumentSchemaType(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredDocumentSchemaType;
    }    

    /**
     * Add classifications to the supplied documentSchemaType
     * @param userId user identity
     * @param entityGuid the GUID value for documentSchemaType
     * @param classifications the classifications to apply.
     * @return the documentSchemaType entity that has been classified
     */
     public DocumentSchemaType addDocumentSchemaTypeClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addDocumentSchemaTypeClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         DocumentSchemaType documentSchemaTypeClassificationBeans = DocumentSchemaTypeMapper.mapOmrsEntityDetailToDocumentSchemaType(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified DocumentSchemaType=" +  documentSchemaTypeClassificationBeans);
         }
         return  documentSchemaTypeClassificationBeans;
    }

    /**
     * Updates classifications to an existing documentSchemaType represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the documentSchemaType
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given documentSchemaType guid
     */
    public DocumentSchemaType updateDocumentSchemaTypeClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateDocumentSchemaTypeClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           DocumentSchemaType  documentSchemaTypeClassificationBeans = DocumentSchemaTypeMapper.mapOmrsEntityDetailToDocumentSchemaType(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  documentSchemaTypeClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing documentSchemaType represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the documentSchemaType
     * @param name name of the classification
     * @return deleted DocumentSchemaType  classification
     */
    public DocumentSchemaType deleteDocumentSchemaTypeClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteDocumentSchemaTypeClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       DocumentSchemaType declassifiedDocumentSchemaType =  DocumentSchemaTypeMapper.mapOmrsEntityDetailToDocumentSchemaType(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedDocumentSchemaType;
    }

    /**
      * Get the relationships associated with entity documentSchemaType represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the documentSchemaType
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getDocumentSchemaTypeRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getDocumentSchemaTypeRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an infrastructure given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the infrastructures relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return Infrastructure the Infrastructure entity with the requested GUID
     */
    public Infrastructure getInfrastructure(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getInfrastructure";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        Infrastructure gotinfrastructure = InfrastructureMapper.mapOmrsEntityDetailToInfrastructure(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotinfrastructure );
        }
        return gotinfrastructure;

    }
    /**
     * Create new infrastructure.
     * @param userId user identity
     * @param infrastructure the input entity with values.
     * @return Infrastructure the created entity.
     */

    public Infrastructure createInfrastructure(String userId,Infrastructure infrastructure)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createInfrastructure";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = InfrastructureMapper.mapInfrastructureToOmrsEntityDetail(infrastructure);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        Infrastructure createdInfrastructure =  InfrastructureMapper.mapOmrsEntityDetailToInfrastructure(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created Infrastructure="+ createdInfrastructure );
        }
        return createdInfrastructure;
    }
    /**
     * Update infrastructure
     * @param userId user identity
     * @param infrastructure   infrastructure to update
     * @return Infrastructure the updated infrastructure entity
     */
    public Infrastructure updateInfrastructure(String userId, Infrastructure infrastructure)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateInfrastructure";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = InfrastructureMapper.mapInfrastructureToOmrsEntityDetail(infrastructure);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            Infrastructure updatedInfrastructure =  InfrastructureMapper.mapOmrsEntityDetailToInfrastructure(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated Infrastructure="+ updatedInfrastructure );
            }
            return updatedInfrastructure;
        }

    /**
     * Delete an infrastructure identified by its GUID. Delete is a soft delete, this means that the infrastructure has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the infrastructure
     * @return Infrastructure the deleted Infrastructure entity
     */

    public Infrastructure deleteInfrastructure(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteInfrastructure";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Infrastructure type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Infrastructure");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"Infrastructure",entityDef.getGUID(),entityGuid);
         Infrastructure deletedInfrastructure = InfrastructureMapper.mapOmrsEntityDetailToInfrastructure(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedInfrastructure;

    }
    /**
     * Purge an infrastructure identified by its GUID. Delete is a hard delete, this means that the infrastructure is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the infrastructure
     */
    public void purgeInfrastructure(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeInfrastructure";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Infrastructure type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Infrastructure");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"Infrastructure",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an Infrastructure identified by its GUID. Restore resurrects a soft deleted Infrastructure. When a Infrastructure was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the Infrastructure
     * @return  Infrastructure the restored Infrastructure
     */
    public Infrastructure restoreInfrastructure(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreInfrastructure";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        Infrastructure restoredInfrastructure =  InfrastructureMapper.mapOmrsEntityDetailToInfrastructure(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredInfrastructure;
    }    

    /**
     * Add classifications to the supplied infrastructure
     * @param userId user identity
     * @param entityGuid the GUID value for infrastructure
     * @param classifications the classifications to apply.
     * @return the infrastructure entity that has been classified
     */
     public Infrastructure addInfrastructureClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addInfrastructureClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         Infrastructure infrastructureClassificationBeans = InfrastructureMapper.mapOmrsEntityDetailToInfrastructure(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified Infrastructure=" +  infrastructureClassificationBeans);
         }
         return  infrastructureClassificationBeans;
    }

    /**
     * Updates classifications to an existing infrastructure represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the infrastructure
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given infrastructure guid
     */
    public Infrastructure updateInfrastructureClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateInfrastructureClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           Infrastructure  infrastructureClassificationBeans = InfrastructureMapper.mapOmrsEntityDetailToInfrastructure(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  infrastructureClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing infrastructure represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the infrastructure
     * @param name name of the classification
     * @return deleted Infrastructure  classification
     */
    public Infrastructure deleteInfrastructureClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteInfrastructureClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       Infrastructure declassifiedInfrastructure =  InfrastructureMapper.mapOmrsEntityDetailToInfrastructure(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedInfrastructure;
    }

    /**
      * Get the relationships associated with entity infrastructure represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the infrastructure
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getInfrastructureRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getInfrastructureRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an team given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the teams relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return Team the Team entity with the requested GUID
     */
    public Team getTeam(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getTeam";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        Team gotteam = TeamMapper.mapOmrsEntityDetailToTeam(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotteam );
        }
        return gotteam;

    }
    /**
     * Create new team.
     * @param userId user identity
     * @param team the input entity with values.
     * @return Team the created entity.
     */

    public Team createTeam(String userId,Team team)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createTeam";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = TeamMapper.mapTeamToOmrsEntityDetail(team);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        Team createdTeam =  TeamMapper.mapOmrsEntityDetailToTeam(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created Team="+ createdTeam );
        }
        return createdTeam;
    }
    /**
     * Update team
     * @param userId user identity
     * @param team   team to update
     * @return Team the updated team entity
     */
    public Team updateTeam(String userId, Team team)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateTeam";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = TeamMapper.mapTeamToOmrsEntityDetail(team);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            Team updatedTeam =  TeamMapper.mapOmrsEntityDetailToTeam(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated Team="+ updatedTeam );
            }
            return updatedTeam;
        }

    /**
     * Delete an team identified by its GUID. Delete is a soft delete, this means that the team has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the team
     * @return Team the deleted Team entity
     */

    public Team deleteTeam(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteTeam";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Team type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Team");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"Team",entityDef.getGUID(),entityGuid);
         Team deletedTeam = TeamMapper.mapOmrsEntityDetailToTeam(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedTeam;

    }
    /**
     * Purge an team identified by its GUID. Delete is a hard delete, this means that the team is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the team
     */
    public void purgeTeam(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeTeam";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Team type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Team");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"Team",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an Team identified by its GUID. Restore resurrects a soft deleted Team. When a Team was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the Team
     * @return  Team the restored Team
     */
    public Team restoreTeam(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreTeam";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        Team restoredTeam =  TeamMapper.mapOmrsEntityDetailToTeam(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredTeam;
    }    

    /**
     * Add classifications to the supplied team
     * @param userId user identity
     * @param entityGuid the GUID value for team
     * @param classifications the classifications to apply.
     * @return the team entity that has been classified
     */
     public Team addTeamClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addTeamClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         Team teamClassificationBeans = TeamMapper.mapOmrsEntityDetailToTeam(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified Team=" +  teamClassificationBeans);
         }
         return  teamClassificationBeans;
    }

    /**
     * Updates classifications to an existing team represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the team
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given team guid
     */
    public Team updateTeamClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateTeamClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           Team  teamClassificationBeans = TeamMapper.mapOmrsEntityDetailToTeam(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  teamClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing team represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the team
     * @param name name of the classification
     * @return deleted Team  classification
     */
    public Team deleteTeamClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteTeamClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       Team declassifiedTeam =  TeamMapper.mapOmrsEntityDetailToTeam(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedTeam;
    }

    /**
      * Get the relationships associated with entity team represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the team
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getTeamRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getTeamRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an schemaElement given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the schemaElements relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return SchemaElement the SchemaElement entity with the requested GUID
     */
    public SchemaElement getSchemaElement(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getSchemaElement";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        SchemaElement gotschemaElement = SchemaElementMapper.mapOmrsEntityDetailToSchemaElement(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotschemaElement );
        }
        return gotschemaElement;

    }
    /**
     * Create new schemaElement.
     * @param userId user identity
     * @param schemaElement the input entity with values.
     * @return SchemaElement the created entity.
     */

    public SchemaElement createSchemaElement(String userId,SchemaElement schemaElement)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createSchemaElement";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = SchemaElementMapper.mapSchemaElementToOmrsEntityDetail(schemaElement);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        SchemaElement createdSchemaElement =  SchemaElementMapper.mapOmrsEntityDetailToSchemaElement(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created SchemaElement="+ createdSchemaElement );
        }
        return createdSchemaElement;
    }
    /**
     * Update schemaElement
     * @param userId user identity
     * @param schemaElement   schemaElement to update
     * @return SchemaElement the updated schemaElement entity
     */
    public SchemaElement updateSchemaElement(String userId, SchemaElement schemaElement)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateSchemaElement";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = SchemaElementMapper.mapSchemaElementToOmrsEntityDetail(schemaElement);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            SchemaElement updatedSchemaElement =  SchemaElementMapper.mapOmrsEntityDetailToSchemaElement(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated SchemaElement="+ updatedSchemaElement );
            }
            return updatedSchemaElement;
        }

    /**
     * Delete an schemaElement identified by its GUID. Delete is a soft delete, this means that the schemaElement has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the schemaElement
     * @return SchemaElement the deleted SchemaElement entity
     */

    public SchemaElement deleteSchemaElement(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteSchemaElement";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the SchemaElement type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("SchemaElement");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"SchemaElement",entityDef.getGUID(),entityGuid);
         SchemaElement deletedSchemaElement = SchemaElementMapper.mapOmrsEntityDetailToSchemaElement(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedSchemaElement;

    }
    /**
     * Purge an schemaElement identified by its GUID. Delete is a hard delete, this means that the schemaElement is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the schemaElement
     */
    public void purgeSchemaElement(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeSchemaElement";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the SchemaElement type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("SchemaElement");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"SchemaElement",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an SchemaElement identified by its GUID. Restore resurrects a soft deleted SchemaElement. When a SchemaElement was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the SchemaElement
     * @return  SchemaElement the restored SchemaElement
     */
    public SchemaElement restoreSchemaElement(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreSchemaElement";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        SchemaElement restoredSchemaElement =  SchemaElementMapper.mapOmrsEntityDetailToSchemaElement(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredSchemaElement;
    }    

    /**
     * Add classifications to the supplied schemaElement
     * @param userId user identity
     * @param entityGuid the GUID value for schemaElement
     * @param classifications the classifications to apply.
     * @return the schemaElement entity that has been classified
     */
     public SchemaElement addSchemaElementClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addSchemaElementClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         SchemaElement schemaElementClassificationBeans = SchemaElementMapper.mapOmrsEntityDetailToSchemaElement(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified SchemaElement=" +  schemaElementClassificationBeans);
         }
         return  schemaElementClassificationBeans;
    }

    /**
     * Updates classifications to an existing schemaElement represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the schemaElement
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given schemaElement guid
     */
    public SchemaElement updateSchemaElementClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateSchemaElementClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           SchemaElement  schemaElementClassificationBeans = SchemaElementMapper.mapOmrsEntityDetailToSchemaElement(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  schemaElementClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing schemaElement represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the schemaElement
     * @param name name of the classification
     * @return deleted SchemaElement  classification
     */
    public SchemaElement deleteSchemaElementClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteSchemaElementClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       SchemaElement declassifiedSchemaElement =  SchemaElementMapper.mapOmrsEntityDetailToSchemaElement(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedSchemaElement;
    }

    /**
      * Get the relationships associated with entity schemaElement represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the schemaElement
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getSchemaElementRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getSchemaElementRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an documentSchemaAttribute given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the documentSchemaAttributes relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return DocumentSchemaAttribute the DocumentSchemaAttribute entity with the requested GUID
     */
    public DocumentSchemaAttribute getDocumentSchemaAttribute(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getDocumentSchemaAttribute";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        DocumentSchemaAttribute gotdocumentSchemaAttribute = DocumentSchemaAttributeMapper.mapOmrsEntityDetailToDocumentSchemaAttribute(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotdocumentSchemaAttribute );
        }
        return gotdocumentSchemaAttribute;

    }
    /**
     * Create new documentSchemaAttribute.
     * @param userId user identity
     * @param documentSchemaAttribute the input entity with values.
     * @return DocumentSchemaAttribute the created entity.
     */

    public DocumentSchemaAttribute createDocumentSchemaAttribute(String userId,DocumentSchemaAttribute documentSchemaAttribute)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createDocumentSchemaAttribute";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = DocumentSchemaAttributeMapper.mapDocumentSchemaAttributeToOmrsEntityDetail(documentSchemaAttribute);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        DocumentSchemaAttribute createdDocumentSchemaAttribute =  DocumentSchemaAttributeMapper.mapOmrsEntityDetailToDocumentSchemaAttribute(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created DocumentSchemaAttribute="+ createdDocumentSchemaAttribute );
        }
        return createdDocumentSchemaAttribute;
    }
    /**
     * Update documentSchemaAttribute
     * @param userId user identity
     * @param documentSchemaAttribute   documentSchemaAttribute to update
     * @return DocumentSchemaAttribute the updated documentSchemaAttribute entity
     */
    public DocumentSchemaAttribute updateDocumentSchemaAttribute(String userId, DocumentSchemaAttribute documentSchemaAttribute)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateDocumentSchemaAttribute";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = DocumentSchemaAttributeMapper.mapDocumentSchemaAttributeToOmrsEntityDetail(documentSchemaAttribute);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            DocumentSchemaAttribute updatedDocumentSchemaAttribute =  DocumentSchemaAttributeMapper.mapOmrsEntityDetailToDocumentSchemaAttribute(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated DocumentSchemaAttribute="+ updatedDocumentSchemaAttribute );
            }
            return updatedDocumentSchemaAttribute;
        }

    /**
     * Delete an documentSchemaAttribute identified by its GUID. Delete is a soft delete, this means that the documentSchemaAttribute has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the documentSchemaAttribute
     * @return DocumentSchemaAttribute the deleted DocumentSchemaAttribute entity
     */

    public DocumentSchemaAttribute deleteDocumentSchemaAttribute(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteDocumentSchemaAttribute";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DocumentSchemaAttribute type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DocumentSchemaAttribute");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"DocumentSchemaAttribute",entityDef.getGUID(),entityGuid);
         DocumentSchemaAttribute deletedDocumentSchemaAttribute = DocumentSchemaAttributeMapper.mapOmrsEntityDetailToDocumentSchemaAttribute(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedDocumentSchemaAttribute;

    }
    /**
     * Purge an documentSchemaAttribute identified by its GUID. Delete is a hard delete, this means that the documentSchemaAttribute is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the documentSchemaAttribute
     */
    public void purgeDocumentSchemaAttribute(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeDocumentSchemaAttribute";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DocumentSchemaAttribute type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DocumentSchemaAttribute");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"DocumentSchemaAttribute",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an DocumentSchemaAttribute identified by its GUID. Restore resurrects a soft deleted DocumentSchemaAttribute. When a DocumentSchemaAttribute was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the DocumentSchemaAttribute
     * @return  DocumentSchemaAttribute the restored DocumentSchemaAttribute
     */
    public DocumentSchemaAttribute restoreDocumentSchemaAttribute(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreDocumentSchemaAttribute";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        DocumentSchemaAttribute restoredDocumentSchemaAttribute =  DocumentSchemaAttributeMapper.mapOmrsEntityDetailToDocumentSchemaAttribute(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredDocumentSchemaAttribute;
    }    

    /**
     * Add classifications to the supplied documentSchemaAttribute
     * @param userId user identity
     * @param entityGuid the GUID value for documentSchemaAttribute
     * @param classifications the classifications to apply.
     * @return the documentSchemaAttribute entity that has been classified
     */
     public DocumentSchemaAttribute addDocumentSchemaAttributeClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addDocumentSchemaAttributeClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         DocumentSchemaAttribute documentSchemaAttributeClassificationBeans = DocumentSchemaAttributeMapper.mapOmrsEntityDetailToDocumentSchemaAttribute(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified DocumentSchemaAttribute=" +  documentSchemaAttributeClassificationBeans);
         }
         return  documentSchemaAttributeClassificationBeans;
    }

    /**
     * Updates classifications to an existing documentSchemaAttribute represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the documentSchemaAttribute
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given documentSchemaAttribute guid
     */
    public DocumentSchemaAttribute updateDocumentSchemaAttributeClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateDocumentSchemaAttributeClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           DocumentSchemaAttribute  documentSchemaAttributeClassificationBeans = DocumentSchemaAttributeMapper.mapOmrsEntityDetailToDocumentSchemaAttribute(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  documentSchemaAttributeClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing documentSchemaAttribute represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the documentSchemaAttribute
     * @param name name of the classification
     * @return deleted DocumentSchemaAttribute  classification
     */
    public DocumentSchemaAttribute deleteDocumentSchemaAttributeClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteDocumentSchemaAttributeClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       DocumentSchemaAttribute declassifiedDocumentSchemaAttribute =  DocumentSchemaAttributeMapper.mapOmrsEntityDetailToDocumentSchemaAttribute(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedDocumentSchemaAttribute;
    }

    /**
      * Get the relationships associated with entity documentSchemaAttribute represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the documentSchemaAttribute
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getDocumentSchemaAttributeRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getDocumentSchemaAttributeRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an relationalColumn given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the relationalColumns relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return RelationalColumn the RelationalColumn entity with the requested GUID
     */
    public RelationalColumn getRelationalColumn(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getRelationalColumn";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        RelationalColumn gotrelationalColumn = RelationalColumnMapper.mapOmrsEntityDetailToRelationalColumn(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotrelationalColumn );
        }
        return gotrelationalColumn;

    }
    /**
     * Create new relationalColumn.
     * @param userId user identity
     * @param relationalColumn the input entity with values.
     * @return RelationalColumn the created entity.
     */

    public RelationalColumn createRelationalColumn(String userId,RelationalColumn relationalColumn)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createRelationalColumn";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = RelationalColumnMapper.mapRelationalColumnToOmrsEntityDetail(relationalColumn);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        RelationalColumn createdRelationalColumn =  RelationalColumnMapper.mapOmrsEntityDetailToRelationalColumn(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created RelationalColumn="+ createdRelationalColumn );
        }
        return createdRelationalColumn;
    }
    /**
     * Update relationalColumn
     * @param userId user identity
     * @param relationalColumn   relationalColumn to update
     * @return RelationalColumn the updated relationalColumn entity
     */
    public RelationalColumn updateRelationalColumn(String userId, RelationalColumn relationalColumn)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateRelationalColumn";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = RelationalColumnMapper.mapRelationalColumnToOmrsEntityDetail(relationalColumn);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            RelationalColumn updatedRelationalColumn =  RelationalColumnMapper.mapOmrsEntityDetailToRelationalColumn(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated RelationalColumn="+ updatedRelationalColumn );
            }
            return updatedRelationalColumn;
        }

    /**
     * Delete an relationalColumn identified by its GUID. Delete is a soft delete, this means that the relationalColumn has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the relationalColumn
     * @return RelationalColumn the deleted RelationalColumn entity
     */

    public RelationalColumn deleteRelationalColumn(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteRelationalColumn";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the RelationalColumn type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("RelationalColumn");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"RelationalColumn",entityDef.getGUID(),entityGuid);
         RelationalColumn deletedRelationalColumn = RelationalColumnMapper.mapOmrsEntityDetailToRelationalColumn(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedRelationalColumn;

    }
    /**
     * Purge an relationalColumn identified by its GUID. Delete is a hard delete, this means that the relationalColumn is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the relationalColumn
     */
    public void purgeRelationalColumn(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeRelationalColumn";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the RelationalColumn type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("RelationalColumn");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"RelationalColumn",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an RelationalColumn identified by its GUID. Restore resurrects a soft deleted RelationalColumn. When a RelationalColumn was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the RelationalColumn
     * @return  RelationalColumn the restored RelationalColumn
     */
    public RelationalColumn restoreRelationalColumn(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreRelationalColumn";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        RelationalColumn restoredRelationalColumn =  RelationalColumnMapper.mapOmrsEntityDetailToRelationalColumn(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredRelationalColumn;
    }    

    /**
     * Add classifications to the supplied relationalColumn
     * @param userId user identity
     * @param entityGuid the GUID value for relationalColumn
     * @param classifications the classifications to apply.
     * @return the relationalColumn entity that has been classified
     */
     public RelationalColumn addRelationalColumnClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addRelationalColumnClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         RelationalColumn relationalColumnClassificationBeans = RelationalColumnMapper.mapOmrsEntityDetailToRelationalColumn(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified RelationalColumn=" +  relationalColumnClassificationBeans);
         }
         return  relationalColumnClassificationBeans;
    }

    /**
     * Updates classifications to an existing relationalColumn represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the relationalColumn
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given relationalColumn guid
     */
    public RelationalColumn updateRelationalColumnClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateRelationalColumnClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           RelationalColumn  relationalColumnClassificationBeans = RelationalColumnMapper.mapOmrsEntityDetailToRelationalColumn(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  relationalColumnClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing relationalColumn represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the relationalColumn
     * @param name name of the classification
     * @return deleted RelationalColumn  classification
     */
    public RelationalColumn deleteRelationalColumnClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteRelationalColumnClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       RelationalColumn declassifiedRelationalColumn =  RelationalColumnMapper.mapOmrsEntityDetailToRelationalColumn(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedRelationalColumn;
    }

    /**
      * Get the relationships associated with entity relationalColumn represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the relationalColumn
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getRelationalColumnRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getRelationalColumnRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an softwareServer given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the softwareServers relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return SoftwareServer the SoftwareServer entity with the requested GUID
     */
    public SoftwareServer getSoftwareServer(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getSoftwareServer";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        SoftwareServer gotsoftwareServer = SoftwareServerMapper.mapOmrsEntityDetailToSoftwareServer(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotsoftwareServer );
        }
        return gotsoftwareServer;

    }
    /**
     * Create new softwareServer.
     * @param userId user identity
     * @param softwareServer the input entity with values.
     * @return SoftwareServer the created entity.
     */

    public SoftwareServer createSoftwareServer(String userId,SoftwareServer softwareServer)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createSoftwareServer";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = SoftwareServerMapper.mapSoftwareServerToOmrsEntityDetail(softwareServer);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        SoftwareServer createdSoftwareServer =  SoftwareServerMapper.mapOmrsEntityDetailToSoftwareServer(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created SoftwareServer="+ createdSoftwareServer );
        }
        return createdSoftwareServer;
    }
    /**
     * Update softwareServer
     * @param userId user identity
     * @param softwareServer   softwareServer to update
     * @return SoftwareServer the updated softwareServer entity
     */
    public SoftwareServer updateSoftwareServer(String userId, SoftwareServer softwareServer)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateSoftwareServer";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = SoftwareServerMapper.mapSoftwareServerToOmrsEntityDetail(softwareServer);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            SoftwareServer updatedSoftwareServer =  SoftwareServerMapper.mapOmrsEntityDetailToSoftwareServer(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated SoftwareServer="+ updatedSoftwareServer );
            }
            return updatedSoftwareServer;
        }

    /**
     * Delete an softwareServer identified by its GUID. Delete is a soft delete, this means that the softwareServer has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the softwareServer
     * @return SoftwareServer the deleted SoftwareServer entity
     */

    public SoftwareServer deleteSoftwareServer(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteSoftwareServer";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the SoftwareServer type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("SoftwareServer");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"SoftwareServer",entityDef.getGUID(),entityGuid);
         SoftwareServer deletedSoftwareServer = SoftwareServerMapper.mapOmrsEntityDetailToSoftwareServer(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedSoftwareServer;

    }
    /**
     * Purge an softwareServer identified by its GUID. Delete is a hard delete, this means that the softwareServer is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the softwareServer
     */
    public void purgeSoftwareServer(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeSoftwareServer";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the SoftwareServer type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("SoftwareServer");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"SoftwareServer",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an SoftwareServer identified by its GUID. Restore resurrects a soft deleted SoftwareServer. When a SoftwareServer was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the SoftwareServer
     * @return  SoftwareServer the restored SoftwareServer
     */
    public SoftwareServer restoreSoftwareServer(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreSoftwareServer";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        SoftwareServer restoredSoftwareServer =  SoftwareServerMapper.mapOmrsEntityDetailToSoftwareServer(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredSoftwareServer;
    }    

    /**
     * Add classifications to the supplied softwareServer
     * @param userId user identity
     * @param entityGuid the GUID value for softwareServer
     * @param classifications the classifications to apply.
     * @return the softwareServer entity that has been classified
     */
     public SoftwareServer addSoftwareServerClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addSoftwareServerClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         SoftwareServer softwareServerClassificationBeans = SoftwareServerMapper.mapOmrsEntityDetailToSoftwareServer(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified SoftwareServer=" +  softwareServerClassificationBeans);
         }
         return  softwareServerClassificationBeans;
    }

    /**
     * Updates classifications to an existing softwareServer represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the softwareServer
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given softwareServer guid
     */
    public SoftwareServer updateSoftwareServerClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateSoftwareServerClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           SoftwareServer  softwareServerClassificationBeans = SoftwareServerMapper.mapOmrsEntityDetailToSoftwareServer(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  softwareServerClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing softwareServer represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the softwareServer
     * @param name name of the classification
     * @return deleted SoftwareServer  classification
     */
    public SoftwareServer deleteSoftwareServerClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteSoftwareServerClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       SoftwareServer declassifiedSoftwareServer =  SoftwareServerMapper.mapOmrsEntityDetailToSoftwareServer(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedSoftwareServer;
    }

    /**
      * Get the relationships associated with entity softwareServer represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the softwareServer
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getSoftwareServerRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getSoftwareServerRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an mediaFile given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the mediaFiles relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return MediaFile the MediaFile entity with the requested GUID
     */
    public MediaFile getMediaFile(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getMediaFile";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        MediaFile gotmediaFile = MediaFileMapper.mapOmrsEntityDetailToMediaFile(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotmediaFile );
        }
        return gotmediaFile;

    }
    /**
     * Create new mediaFile.
     * @param userId user identity
     * @param mediaFile the input entity with values.
     * @return MediaFile the created entity.
     */

    public MediaFile createMediaFile(String userId,MediaFile mediaFile)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createMediaFile";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = MediaFileMapper.mapMediaFileToOmrsEntityDetail(mediaFile);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        MediaFile createdMediaFile =  MediaFileMapper.mapOmrsEntityDetailToMediaFile(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created MediaFile="+ createdMediaFile );
        }
        return createdMediaFile;
    }
    /**
     * Update mediaFile
     * @param userId user identity
     * @param mediaFile   mediaFile to update
     * @return MediaFile the updated mediaFile entity
     */
    public MediaFile updateMediaFile(String userId, MediaFile mediaFile)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateMediaFile";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = MediaFileMapper.mapMediaFileToOmrsEntityDetail(mediaFile);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            MediaFile updatedMediaFile =  MediaFileMapper.mapOmrsEntityDetailToMediaFile(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated MediaFile="+ updatedMediaFile );
            }
            return updatedMediaFile;
        }

    /**
     * Delete an mediaFile identified by its GUID. Delete is a soft delete, this means that the mediaFile has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the mediaFile
     * @return MediaFile the deleted MediaFile entity
     */

    public MediaFile deleteMediaFile(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteMediaFile";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the MediaFile type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("MediaFile");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"MediaFile",entityDef.getGUID(),entityGuid);
         MediaFile deletedMediaFile = MediaFileMapper.mapOmrsEntityDetailToMediaFile(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedMediaFile;

    }
    /**
     * Purge an mediaFile identified by its GUID. Delete is a hard delete, this means that the mediaFile is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the mediaFile
     */
    public void purgeMediaFile(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeMediaFile";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the MediaFile type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("MediaFile");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"MediaFile",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an MediaFile identified by its GUID. Restore resurrects a soft deleted MediaFile. When a MediaFile was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the MediaFile
     * @return  MediaFile the restored MediaFile
     */
    public MediaFile restoreMediaFile(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreMediaFile";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        MediaFile restoredMediaFile =  MediaFileMapper.mapOmrsEntityDetailToMediaFile(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredMediaFile;
    }    

    /**
     * Add classifications to the supplied mediaFile
     * @param userId user identity
     * @param entityGuid the GUID value for mediaFile
     * @param classifications the classifications to apply.
     * @return the mediaFile entity that has been classified
     */
     public MediaFile addMediaFileClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addMediaFileClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         MediaFile mediaFileClassificationBeans = MediaFileMapper.mapOmrsEntityDetailToMediaFile(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified MediaFile=" +  mediaFileClassificationBeans);
         }
         return  mediaFileClassificationBeans;
    }

    /**
     * Updates classifications to an existing mediaFile represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the mediaFile
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given mediaFile guid
     */
    public MediaFile updateMediaFileClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateMediaFileClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           MediaFile  mediaFileClassificationBeans = MediaFileMapper.mapOmrsEntityDetailToMediaFile(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  mediaFileClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing mediaFile represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the mediaFile
     * @param name name of the classification
     * @return deleted MediaFile  classification
     */
    public MediaFile deleteMediaFileClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteMediaFileClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       MediaFile declassifiedMediaFile =  MediaFileMapper.mapOmrsEntityDetailToMediaFile(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedMediaFile;
    }

    /**
      * Get the relationships associated with entity mediaFile represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the mediaFile
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getMediaFileRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getMediaFileRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an relatedMedia given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the relatedMedias relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return RelatedMedia the RelatedMedia entity with the requested GUID
     */
    public RelatedMedia getRelatedMedia(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getRelatedMedia";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        RelatedMedia gotrelatedMedia = RelatedMediaMapper.mapOmrsEntityDetailToRelatedMedia(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotrelatedMedia );
        }
        return gotrelatedMedia;

    }
    /**
     * Create new relatedMedia.
     * @param userId user identity
     * @param relatedMedia the input entity with values.
     * @return RelatedMedia the created entity.
     */

    public RelatedMedia createRelatedMedia(String userId,RelatedMedia relatedMedia)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createRelatedMedia";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = RelatedMediaMapper.mapRelatedMediaToOmrsEntityDetail(relatedMedia);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        RelatedMedia createdRelatedMedia =  RelatedMediaMapper.mapOmrsEntityDetailToRelatedMedia(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created RelatedMedia="+ createdRelatedMedia );
        }
        return createdRelatedMedia;
    }
    /**
     * Update relatedMedia
     * @param userId user identity
     * @param relatedMedia   relatedMedia to update
     * @return RelatedMedia the updated relatedMedia entity
     */
    public RelatedMedia updateRelatedMedia(String userId, RelatedMedia relatedMedia)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateRelatedMedia";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = RelatedMediaMapper.mapRelatedMediaToOmrsEntityDetail(relatedMedia);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            RelatedMedia updatedRelatedMedia =  RelatedMediaMapper.mapOmrsEntityDetailToRelatedMedia(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated RelatedMedia="+ updatedRelatedMedia );
            }
            return updatedRelatedMedia;
        }

    /**
     * Delete an relatedMedia identified by its GUID. Delete is a soft delete, this means that the relatedMedia has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the relatedMedia
     * @return RelatedMedia the deleted RelatedMedia entity
     */

    public RelatedMedia deleteRelatedMedia(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteRelatedMedia";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the RelatedMedia type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("RelatedMedia");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"RelatedMedia",entityDef.getGUID(),entityGuid);
         RelatedMedia deletedRelatedMedia = RelatedMediaMapper.mapOmrsEntityDetailToRelatedMedia(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedRelatedMedia;

    }
    /**
     * Purge an relatedMedia identified by its GUID. Delete is a hard delete, this means that the relatedMedia is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the relatedMedia
     */
    public void purgeRelatedMedia(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeRelatedMedia";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the RelatedMedia type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("RelatedMedia");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"RelatedMedia",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an RelatedMedia identified by its GUID. Restore resurrects a soft deleted RelatedMedia. When a RelatedMedia was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the RelatedMedia
     * @return  RelatedMedia the restored RelatedMedia
     */
    public RelatedMedia restoreRelatedMedia(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreRelatedMedia";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        RelatedMedia restoredRelatedMedia =  RelatedMediaMapper.mapOmrsEntityDetailToRelatedMedia(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredRelatedMedia;
    }    

    /**
     * Add classifications to the supplied relatedMedia
     * @param userId user identity
     * @param entityGuid the GUID value for relatedMedia
     * @param classifications the classifications to apply.
     * @return the relatedMedia entity that has been classified
     */
     public RelatedMedia addRelatedMediaClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addRelatedMediaClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         RelatedMedia relatedMediaClassificationBeans = RelatedMediaMapper.mapOmrsEntityDetailToRelatedMedia(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified RelatedMedia=" +  relatedMediaClassificationBeans);
         }
         return  relatedMediaClassificationBeans;
    }

    /**
     * Updates classifications to an existing relatedMedia represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the relatedMedia
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given relatedMedia guid
     */
    public RelatedMedia updateRelatedMediaClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateRelatedMediaClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           RelatedMedia  relatedMediaClassificationBeans = RelatedMediaMapper.mapOmrsEntityDetailToRelatedMedia(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  relatedMediaClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing relatedMedia represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the relatedMedia
     * @param name name of the classification
     * @return deleted RelatedMedia  classification
     */
    public RelatedMedia deleteRelatedMediaClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteRelatedMediaClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       RelatedMedia declassifiedRelatedMedia =  RelatedMediaMapper.mapOmrsEntityDetailToRelatedMedia(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedRelatedMedia;
    }

    /**
      * Get the relationships associated with entity relatedMedia represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the relatedMedia
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getRelatedMediaRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getRelatedMediaRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an connectorType given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the connectorTypes relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return ConnectorType the ConnectorType entity with the requested GUID
     */
    public ConnectorType getConnectorType(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getConnectorType";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        ConnectorType gotconnectorType = ConnectorTypeMapper.mapOmrsEntityDetailToConnectorType(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotconnectorType );
        }
        return gotconnectorType;

    }
    /**
     * Create new connectorType.
     * @param userId user identity
     * @param connectorType the input entity with values.
     * @return ConnectorType the created entity.
     */

    public ConnectorType createConnectorType(String userId,ConnectorType connectorType)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createConnectorType";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = ConnectorTypeMapper.mapConnectorTypeToOmrsEntityDetail(connectorType);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        ConnectorType createdConnectorType =  ConnectorTypeMapper.mapOmrsEntityDetailToConnectorType(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created ConnectorType="+ createdConnectorType );
        }
        return createdConnectorType;
    }
    /**
     * Update connectorType
     * @param userId user identity
     * @param connectorType   connectorType to update
     * @return ConnectorType the updated connectorType entity
     */
    public ConnectorType updateConnectorType(String userId, ConnectorType connectorType)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateConnectorType";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = ConnectorTypeMapper.mapConnectorTypeToOmrsEntityDetail(connectorType);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            ConnectorType updatedConnectorType =  ConnectorTypeMapper.mapOmrsEntityDetailToConnectorType(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated ConnectorType="+ updatedConnectorType );
            }
            return updatedConnectorType;
        }

    /**
     * Delete an connectorType identified by its GUID. Delete is a soft delete, this means that the connectorType has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the connectorType
     * @return ConnectorType the deleted ConnectorType entity
     */

    public ConnectorType deleteConnectorType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteConnectorType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ConnectorType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ConnectorType");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"ConnectorType",entityDef.getGUID(),entityGuid);
         ConnectorType deletedConnectorType = ConnectorTypeMapper.mapOmrsEntityDetailToConnectorType(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedConnectorType;

    }
    /**
     * Purge an connectorType identified by its GUID. Delete is a hard delete, this means that the connectorType is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the connectorType
     */
    public void purgeConnectorType(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeConnectorType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ConnectorType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ConnectorType");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"ConnectorType",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an ConnectorType identified by its GUID. Restore resurrects a soft deleted ConnectorType. When a ConnectorType was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the ConnectorType
     * @return  ConnectorType the restored ConnectorType
     */
    public ConnectorType restoreConnectorType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreConnectorType";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        ConnectorType restoredConnectorType =  ConnectorTypeMapper.mapOmrsEntityDetailToConnectorType(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredConnectorType;
    }    

    /**
     * Add classifications to the supplied connectorType
     * @param userId user identity
     * @param entityGuid the GUID value for connectorType
     * @param classifications the classifications to apply.
     * @return the connectorType entity that has been classified
     */
     public ConnectorType addConnectorTypeClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addConnectorTypeClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         ConnectorType connectorTypeClassificationBeans = ConnectorTypeMapper.mapOmrsEntityDetailToConnectorType(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified ConnectorType=" +  connectorTypeClassificationBeans);
         }
         return  connectorTypeClassificationBeans;
    }

    /**
     * Updates classifications to an existing connectorType represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the connectorType
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given connectorType guid
     */
    public ConnectorType updateConnectorTypeClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateConnectorTypeClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           ConnectorType  connectorTypeClassificationBeans = ConnectorTypeMapper.mapOmrsEntityDetailToConnectorType(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  connectorTypeClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing connectorType represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the connectorType
     * @param name name of the classification
     * @return deleted ConnectorType  classification
     */
    public ConnectorType deleteConnectorTypeClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteConnectorTypeClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       ConnectorType declassifiedConnectorType =  ConnectorTypeMapper.mapOmrsEntityDetailToConnectorType(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedConnectorType;
    }

    /**
      * Get the relationships associated with entity connectorType represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the connectorType
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getConnectorTypeRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getConnectorTypeRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an enterpriseAccessLayer given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the enterpriseAccessLayers relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return EnterpriseAccessLayer the EnterpriseAccessLayer entity with the requested GUID
     */
    public EnterpriseAccessLayer getEnterpriseAccessLayer(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getEnterpriseAccessLayer";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        EnterpriseAccessLayer gotenterpriseAccessLayer = EnterpriseAccessLayerMapper.mapOmrsEntityDetailToEnterpriseAccessLayer(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotenterpriseAccessLayer );
        }
        return gotenterpriseAccessLayer;

    }
    /**
     * Create new enterpriseAccessLayer.
     * @param userId user identity
     * @param enterpriseAccessLayer the input entity with values.
     * @return EnterpriseAccessLayer the created entity.
     */

    public EnterpriseAccessLayer createEnterpriseAccessLayer(String userId,EnterpriseAccessLayer enterpriseAccessLayer)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createEnterpriseAccessLayer";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = EnterpriseAccessLayerMapper.mapEnterpriseAccessLayerToOmrsEntityDetail(enterpriseAccessLayer);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        EnterpriseAccessLayer createdEnterpriseAccessLayer =  EnterpriseAccessLayerMapper.mapOmrsEntityDetailToEnterpriseAccessLayer(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created EnterpriseAccessLayer="+ createdEnterpriseAccessLayer );
        }
        return createdEnterpriseAccessLayer;
    }
    /**
     * Update enterpriseAccessLayer
     * @param userId user identity
     * @param enterpriseAccessLayer   enterpriseAccessLayer to update
     * @return EnterpriseAccessLayer the updated enterpriseAccessLayer entity
     */
    public EnterpriseAccessLayer updateEnterpriseAccessLayer(String userId, EnterpriseAccessLayer enterpriseAccessLayer)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateEnterpriseAccessLayer";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = EnterpriseAccessLayerMapper.mapEnterpriseAccessLayerToOmrsEntityDetail(enterpriseAccessLayer);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            EnterpriseAccessLayer updatedEnterpriseAccessLayer =  EnterpriseAccessLayerMapper.mapOmrsEntityDetailToEnterpriseAccessLayer(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated EnterpriseAccessLayer="+ updatedEnterpriseAccessLayer );
            }
            return updatedEnterpriseAccessLayer;
        }

    /**
     * Delete an enterpriseAccessLayer identified by its GUID. Delete is a soft delete, this means that the enterpriseAccessLayer has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the enterpriseAccessLayer
     * @return EnterpriseAccessLayer the deleted EnterpriseAccessLayer entity
     */

    public EnterpriseAccessLayer deleteEnterpriseAccessLayer(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteEnterpriseAccessLayer";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the EnterpriseAccessLayer type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("EnterpriseAccessLayer");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"EnterpriseAccessLayer",entityDef.getGUID(),entityGuid);
         EnterpriseAccessLayer deletedEnterpriseAccessLayer = EnterpriseAccessLayerMapper.mapOmrsEntityDetailToEnterpriseAccessLayer(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedEnterpriseAccessLayer;

    }
    /**
     * Purge an enterpriseAccessLayer identified by its GUID. Delete is a hard delete, this means that the enterpriseAccessLayer is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the enterpriseAccessLayer
     */
    public void purgeEnterpriseAccessLayer(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeEnterpriseAccessLayer";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the EnterpriseAccessLayer type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("EnterpriseAccessLayer");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"EnterpriseAccessLayer",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an EnterpriseAccessLayer identified by its GUID. Restore resurrects a soft deleted EnterpriseAccessLayer. When a EnterpriseAccessLayer was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the EnterpriseAccessLayer
     * @return  EnterpriseAccessLayer the restored EnterpriseAccessLayer
     */
    public EnterpriseAccessLayer restoreEnterpriseAccessLayer(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreEnterpriseAccessLayer";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        EnterpriseAccessLayer restoredEnterpriseAccessLayer =  EnterpriseAccessLayerMapper.mapOmrsEntityDetailToEnterpriseAccessLayer(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredEnterpriseAccessLayer;
    }    

    /**
     * Add classifications to the supplied enterpriseAccessLayer
     * @param userId user identity
     * @param entityGuid the GUID value for enterpriseAccessLayer
     * @param classifications the classifications to apply.
     * @return the enterpriseAccessLayer entity that has been classified
     */
     public EnterpriseAccessLayer addEnterpriseAccessLayerClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addEnterpriseAccessLayerClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         EnterpriseAccessLayer enterpriseAccessLayerClassificationBeans = EnterpriseAccessLayerMapper.mapOmrsEntityDetailToEnterpriseAccessLayer(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified EnterpriseAccessLayer=" +  enterpriseAccessLayerClassificationBeans);
         }
         return  enterpriseAccessLayerClassificationBeans;
    }

    /**
     * Updates classifications to an existing enterpriseAccessLayer represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the enterpriseAccessLayer
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given enterpriseAccessLayer guid
     */
    public EnterpriseAccessLayer updateEnterpriseAccessLayerClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateEnterpriseAccessLayerClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           EnterpriseAccessLayer  enterpriseAccessLayerClassificationBeans = EnterpriseAccessLayerMapper.mapOmrsEntityDetailToEnterpriseAccessLayer(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  enterpriseAccessLayerClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing enterpriseAccessLayer represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the enterpriseAccessLayer
     * @param name name of the classification
     * @return deleted EnterpriseAccessLayer  classification
     */
    public EnterpriseAccessLayer deleteEnterpriseAccessLayerClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteEnterpriseAccessLayerClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       EnterpriseAccessLayer declassifiedEnterpriseAccessLayer =  EnterpriseAccessLayerMapper.mapOmrsEntityDetailToEnterpriseAccessLayer(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedEnterpriseAccessLayer;
    }

    /**
      * Get the relationships associated with entity enterpriseAccessLayer represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the enterpriseAccessLayer
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getEnterpriseAccessLayerRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getEnterpriseAccessLayerRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an governanceMetric given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the governanceMetrics relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return GovernanceMetric the GovernanceMetric entity with the requested GUID
     */
    public GovernanceMetric getGovernanceMetric(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getGovernanceMetric";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        GovernanceMetric gotgovernanceMetric = GovernanceMetricMapper.mapOmrsEntityDetailToGovernanceMetric(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotgovernanceMetric );
        }
        return gotgovernanceMetric;

    }
    /**
     * Create new governanceMetric.
     * @param userId user identity
     * @param governanceMetric the input entity with values.
     * @return GovernanceMetric the created entity.
     */

    public GovernanceMetric createGovernanceMetric(String userId,GovernanceMetric governanceMetric)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createGovernanceMetric";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = GovernanceMetricMapper.mapGovernanceMetricToOmrsEntityDetail(governanceMetric);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        GovernanceMetric createdGovernanceMetric =  GovernanceMetricMapper.mapOmrsEntityDetailToGovernanceMetric(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created GovernanceMetric="+ createdGovernanceMetric );
        }
        return createdGovernanceMetric;
    }
    /**
     * Update governanceMetric
     * @param userId user identity
     * @param governanceMetric   governanceMetric to update
     * @return GovernanceMetric the updated governanceMetric entity
     */
    public GovernanceMetric updateGovernanceMetric(String userId, GovernanceMetric governanceMetric)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateGovernanceMetric";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = GovernanceMetricMapper.mapGovernanceMetricToOmrsEntityDetail(governanceMetric);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            GovernanceMetric updatedGovernanceMetric =  GovernanceMetricMapper.mapOmrsEntityDetailToGovernanceMetric(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated GovernanceMetric="+ updatedGovernanceMetric );
            }
            return updatedGovernanceMetric;
        }

    /**
     * Delete an governanceMetric identified by its GUID. Delete is a soft delete, this means that the governanceMetric has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the governanceMetric
     * @return GovernanceMetric the deleted GovernanceMetric entity
     */

    public GovernanceMetric deleteGovernanceMetric(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteGovernanceMetric";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GovernanceMetric type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GovernanceMetric");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"GovernanceMetric",entityDef.getGUID(),entityGuid);
         GovernanceMetric deletedGovernanceMetric = GovernanceMetricMapper.mapOmrsEntityDetailToGovernanceMetric(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedGovernanceMetric;

    }
    /**
     * Purge an governanceMetric identified by its GUID. Delete is a hard delete, this means that the governanceMetric is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the governanceMetric
     */
    public void purgeGovernanceMetric(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeGovernanceMetric";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GovernanceMetric type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GovernanceMetric");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"GovernanceMetric",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an GovernanceMetric identified by its GUID. Restore resurrects a soft deleted GovernanceMetric. When a GovernanceMetric was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the GovernanceMetric
     * @return  GovernanceMetric the restored GovernanceMetric
     */
    public GovernanceMetric restoreGovernanceMetric(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreGovernanceMetric";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        GovernanceMetric restoredGovernanceMetric =  GovernanceMetricMapper.mapOmrsEntityDetailToGovernanceMetric(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredGovernanceMetric;
    }    

    /**
     * Add classifications to the supplied governanceMetric
     * @param userId user identity
     * @param entityGuid the GUID value for governanceMetric
     * @param classifications the classifications to apply.
     * @return the governanceMetric entity that has been classified
     */
     public GovernanceMetric addGovernanceMetricClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addGovernanceMetricClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         GovernanceMetric governanceMetricClassificationBeans = GovernanceMetricMapper.mapOmrsEntityDetailToGovernanceMetric(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified GovernanceMetric=" +  governanceMetricClassificationBeans);
         }
         return  governanceMetricClassificationBeans;
    }

    /**
     * Updates classifications to an existing governanceMetric represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the governanceMetric
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given governanceMetric guid
     */
    public GovernanceMetric updateGovernanceMetricClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateGovernanceMetricClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           GovernanceMetric  governanceMetricClassificationBeans = GovernanceMetricMapper.mapOmrsEntityDetailToGovernanceMetric(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  governanceMetricClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing governanceMetric represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the governanceMetric
     * @param name name of the classification
     * @return deleted GovernanceMetric  classification
     */
    public GovernanceMetric deleteGovernanceMetricClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteGovernanceMetricClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       GovernanceMetric declassifiedGovernanceMetric =  GovernanceMetricMapper.mapOmrsEntityDetailToGovernanceMetric(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedGovernanceMetric;
    }

    /**
      * Get the relationships associated with entity governanceMetric represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the governanceMetric
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getGovernanceMetricRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getGovernanceMetricRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an connection given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the connections relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return Connection the Connection entity with the requested GUID
     */
    public Connection getConnection(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getConnection";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        Connection gotconnection = ConnectionMapper.mapOmrsEntityDetailToConnection(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotconnection );
        }
        return gotconnection;

    }
    /**
     * Create new connection.
     * @param userId user identity
     * @param connection the input entity with values.
     * @return Connection the created entity.
     */

    public Connection createConnection(String userId,Connection connection)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createConnection";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = ConnectionMapper.mapConnectionToOmrsEntityDetail(connection);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        Connection createdConnection =  ConnectionMapper.mapOmrsEntityDetailToConnection(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created Connection="+ createdConnection );
        }
        return createdConnection;
    }
    /**
     * Update connection
     * @param userId user identity
     * @param connection   connection to update
     * @return Connection the updated connection entity
     */
    public Connection updateConnection(String userId, Connection connection)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateConnection";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = ConnectionMapper.mapConnectionToOmrsEntityDetail(connection);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            Connection updatedConnection =  ConnectionMapper.mapOmrsEntityDetailToConnection(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated Connection="+ updatedConnection );
            }
            return updatedConnection;
        }

    /**
     * Delete an connection identified by its GUID. Delete is a soft delete, this means that the connection has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the connection
     * @return Connection the deleted Connection entity
     */

    public Connection deleteConnection(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteConnection";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Connection type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Connection");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"Connection",entityDef.getGUID(),entityGuid);
         Connection deletedConnection = ConnectionMapper.mapOmrsEntityDetailToConnection(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedConnection;

    }
    /**
     * Purge an connection identified by its GUID. Delete is a hard delete, this means that the connection is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the connection
     */
    public void purgeConnection(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeConnection";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Connection type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Connection");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"Connection",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an Connection identified by its GUID. Restore resurrects a soft deleted Connection. When a Connection was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the Connection
     * @return  Connection the restored Connection
     */
    public Connection restoreConnection(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreConnection";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        Connection restoredConnection =  ConnectionMapper.mapOmrsEntityDetailToConnection(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredConnection;
    }    

    /**
     * Add classifications to the supplied connection
     * @param userId user identity
     * @param entityGuid the GUID value for connection
     * @param classifications the classifications to apply.
     * @return the connection entity that has been classified
     */
     public Connection addConnectionClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addConnectionClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         Connection connectionClassificationBeans = ConnectionMapper.mapOmrsEntityDetailToConnection(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified Connection=" +  connectionClassificationBeans);
         }
         return  connectionClassificationBeans;
    }

    /**
     * Updates classifications to an existing connection represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the connection
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given connection guid
     */
    public Connection updateConnectionClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateConnectionClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           Connection  connectionClassificationBeans = ConnectionMapper.mapOmrsEntityDetailToConnection(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  connectionClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing connection represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the connection
     * @param name name of the classification
     * @return deleted Connection  classification
     */
    public Connection deleteConnectionClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteConnectionClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       Connection declassifiedConnection =  ConnectionMapper.mapOmrsEntityDetailToConnection(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedConnection;
    }

    /**
      * Get the relationships associated with entity connection represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the connection
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getConnectionRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getConnectionRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an annotation given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the annotations relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return Annotation the Annotation entity with the requested GUID
     */
    public Annotation getAnnotation(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getAnnotation";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        Annotation gotannotation = AnnotationMapper.mapOmrsEntityDetailToAnnotation(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotannotation );
        }
        return gotannotation;

    }
    /**
     * Create new annotation.
     * @param userId user identity
     * @param annotation the input entity with values.
     * @return Annotation the created entity.
     */

    public Annotation createAnnotation(String userId,Annotation annotation)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createAnnotation";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = AnnotationMapper.mapAnnotationToOmrsEntityDetail(annotation);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        Annotation createdAnnotation =  AnnotationMapper.mapOmrsEntityDetailToAnnotation(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created Annotation="+ createdAnnotation );
        }
        return createdAnnotation;
    }
    /**
     * Update annotation
     * @param userId user identity
     * @param annotation   annotation to update
     * @return Annotation the updated annotation entity
     */
    public Annotation updateAnnotation(String userId, Annotation annotation)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateAnnotation";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = AnnotationMapper.mapAnnotationToOmrsEntityDetail(annotation);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            Annotation updatedAnnotation =  AnnotationMapper.mapOmrsEntityDetailToAnnotation(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated Annotation="+ updatedAnnotation );
            }
            return updatedAnnotation;
        }

    /**
     * Delete an annotation identified by its GUID. Delete is a soft delete, this means that the annotation has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the annotation
     * @return Annotation the deleted Annotation entity
     */

    public Annotation deleteAnnotation(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteAnnotation";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Annotation type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Annotation");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"Annotation",entityDef.getGUID(),entityGuid);
         Annotation deletedAnnotation = AnnotationMapper.mapOmrsEntityDetailToAnnotation(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedAnnotation;

    }
    /**
     * Purge an annotation identified by its GUID. Delete is a hard delete, this means that the annotation is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the annotation
     */
    public void purgeAnnotation(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeAnnotation";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Annotation type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Annotation");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"Annotation",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an Annotation identified by its GUID. Restore resurrects a soft deleted Annotation. When a Annotation was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the Annotation
     * @return  Annotation the restored Annotation
     */
    public Annotation restoreAnnotation(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreAnnotation";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        Annotation restoredAnnotation =  AnnotationMapper.mapOmrsEntityDetailToAnnotation(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredAnnotation;
    }    

    /**
     * Add classifications to the supplied annotation
     * @param userId user identity
     * @param entityGuid the GUID value for annotation
     * @param classifications the classifications to apply.
     * @return the annotation entity that has been classified
     */
     public Annotation addAnnotationClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addAnnotationClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         Annotation annotationClassificationBeans = AnnotationMapper.mapOmrsEntityDetailToAnnotation(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified Annotation=" +  annotationClassificationBeans);
         }
         return  annotationClassificationBeans;
    }

    /**
     * Updates classifications to an existing annotation represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the annotation
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given annotation guid
     */
    public Annotation updateAnnotationClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateAnnotationClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           Annotation  annotationClassificationBeans = AnnotationMapper.mapOmrsEntityDetailToAnnotation(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  annotationClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing annotation represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the annotation
     * @param name name of the classification
     * @return deleted Annotation  classification
     */
    public Annotation deleteAnnotationClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteAnnotationClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       Annotation declassifiedAnnotation =  AnnotationMapper.mapOmrsEntityDetailToAnnotation(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedAnnotation;
    }

    /**
      * Get the relationships associated with entity annotation represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the annotation
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getAnnotationRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getAnnotationRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an governanceRule given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the governanceRules relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return GovernanceRule the GovernanceRule entity with the requested GUID
     */
    public GovernanceRule getGovernanceRule(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getGovernanceRule";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        GovernanceRule gotgovernanceRule = GovernanceRuleMapper.mapOmrsEntityDetailToGovernanceRule(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotgovernanceRule );
        }
        return gotgovernanceRule;

    }
    /**
     * Create new governanceRule.
     * @param userId user identity
     * @param governanceRule the input entity with values.
     * @return GovernanceRule the created entity.
     */

    public GovernanceRule createGovernanceRule(String userId,GovernanceRule governanceRule)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createGovernanceRule";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = GovernanceRuleMapper.mapGovernanceRuleToOmrsEntityDetail(governanceRule);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        GovernanceRule createdGovernanceRule =  GovernanceRuleMapper.mapOmrsEntityDetailToGovernanceRule(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created GovernanceRule="+ createdGovernanceRule );
        }
        return createdGovernanceRule;
    }
    /**
     * Update governanceRule
     * @param userId user identity
     * @param governanceRule   governanceRule to update
     * @return GovernanceRule the updated governanceRule entity
     */
    public GovernanceRule updateGovernanceRule(String userId, GovernanceRule governanceRule)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateGovernanceRule";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = GovernanceRuleMapper.mapGovernanceRuleToOmrsEntityDetail(governanceRule);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            GovernanceRule updatedGovernanceRule =  GovernanceRuleMapper.mapOmrsEntityDetailToGovernanceRule(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated GovernanceRule="+ updatedGovernanceRule );
            }
            return updatedGovernanceRule;
        }

    /**
     * Delete an governanceRule identified by its GUID. Delete is a soft delete, this means that the governanceRule has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the governanceRule
     * @return GovernanceRule the deleted GovernanceRule entity
     */

    public GovernanceRule deleteGovernanceRule(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteGovernanceRule";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GovernanceRule type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GovernanceRule");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"GovernanceRule",entityDef.getGUID(),entityGuid);
         GovernanceRule deletedGovernanceRule = GovernanceRuleMapper.mapOmrsEntityDetailToGovernanceRule(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedGovernanceRule;

    }
    /**
     * Purge an governanceRule identified by its GUID. Delete is a hard delete, this means that the governanceRule is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the governanceRule
     */
    public void purgeGovernanceRule(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeGovernanceRule";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GovernanceRule type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GovernanceRule");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"GovernanceRule",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an GovernanceRule identified by its GUID. Restore resurrects a soft deleted GovernanceRule. When a GovernanceRule was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the GovernanceRule
     * @return  GovernanceRule the restored GovernanceRule
     */
    public GovernanceRule restoreGovernanceRule(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreGovernanceRule";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        GovernanceRule restoredGovernanceRule =  GovernanceRuleMapper.mapOmrsEntityDetailToGovernanceRule(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredGovernanceRule;
    }    

    /**
     * Add classifications to the supplied governanceRule
     * @param userId user identity
     * @param entityGuid the GUID value for governanceRule
     * @param classifications the classifications to apply.
     * @return the governanceRule entity that has been classified
     */
     public GovernanceRule addGovernanceRuleClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addGovernanceRuleClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         GovernanceRule governanceRuleClassificationBeans = GovernanceRuleMapper.mapOmrsEntityDetailToGovernanceRule(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified GovernanceRule=" +  governanceRuleClassificationBeans);
         }
         return  governanceRuleClassificationBeans;
    }

    /**
     * Updates classifications to an existing governanceRule represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the governanceRule
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given governanceRule guid
     */
    public GovernanceRule updateGovernanceRuleClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateGovernanceRuleClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           GovernanceRule  governanceRuleClassificationBeans = GovernanceRuleMapper.mapOmrsEntityDetailToGovernanceRule(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  governanceRuleClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing governanceRule represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the governanceRule
     * @param name name of the classification
     * @return deleted GovernanceRule  classification
     */
    public GovernanceRule deleteGovernanceRuleClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteGovernanceRuleClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       GovernanceRule declassifiedGovernanceRule =  GovernanceRuleMapper.mapOmrsEntityDetailToGovernanceRule(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedGovernanceRule;
    }

    /**
      * Get the relationships associated with entity governanceRule represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the governanceRule
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getGovernanceRuleRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getGovernanceRuleRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an graphStore given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the graphStores relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return GraphStore the GraphStore entity with the requested GUID
     */
    public GraphStore getGraphStore(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getGraphStore";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        GraphStore gotgraphStore = GraphStoreMapper.mapOmrsEntityDetailToGraphStore(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotgraphStore );
        }
        return gotgraphStore;

    }
    /**
     * Create new graphStore.
     * @param userId user identity
     * @param graphStore the input entity with values.
     * @return GraphStore the created entity.
     */

    public GraphStore createGraphStore(String userId,GraphStore graphStore)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createGraphStore";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = GraphStoreMapper.mapGraphStoreToOmrsEntityDetail(graphStore);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        GraphStore createdGraphStore =  GraphStoreMapper.mapOmrsEntityDetailToGraphStore(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created GraphStore="+ createdGraphStore );
        }
        return createdGraphStore;
    }
    /**
     * Update graphStore
     * @param userId user identity
     * @param graphStore   graphStore to update
     * @return GraphStore the updated graphStore entity
     */
    public GraphStore updateGraphStore(String userId, GraphStore graphStore)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateGraphStore";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = GraphStoreMapper.mapGraphStoreToOmrsEntityDetail(graphStore);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            GraphStore updatedGraphStore =  GraphStoreMapper.mapOmrsEntityDetailToGraphStore(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated GraphStore="+ updatedGraphStore );
            }
            return updatedGraphStore;
        }

    /**
     * Delete an graphStore identified by its GUID. Delete is a soft delete, this means that the graphStore has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the graphStore
     * @return GraphStore the deleted GraphStore entity
     */

    public GraphStore deleteGraphStore(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteGraphStore";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GraphStore type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GraphStore");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"GraphStore",entityDef.getGUID(),entityGuid);
         GraphStore deletedGraphStore = GraphStoreMapper.mapOmrsEntityDetailToGraphStore(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedGraphStore;

    }
    /**
     * Purge an graphStore identified by its GUID. Delete is a hard delete, this means that the graphStore is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the graphStore
     */
    public void purgeGraphStore(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeGraphStore";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GraphStore type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GraphStore");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"GraphStore",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an GraphStore identified by its GUID. Restore resurrects a soft deleted GraphStore. When a GraphStore was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the GraphStore
     * @return  GraphStore the restored GraphStore
     */
    public GraphStore restoreGraphStore(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreGraphStore";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        GraphStore restoredGraphStore =  GraphStoreMapper.mapOmrsEntityDetailToGraphStore(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredGraphStore;
    }    

    /**
     * Add classifications to the supplied graphStore
     * @param userId user identity
     * @param entityGuid the GUID value for graphStore
     * @param classifications the classifications to apply.
     * @return the graphStore entity that has been classified
     */
     public GraphStore addGraphStoreClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addGraphStoreClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         GraphStore graphStoreClassificationBeans = GraphStoreMapper.mapOmrsEntityDetailToGraphStore(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified GraphStore=" +  graphStoreClassificationBeans);
         }
         return  graphStoreClassificationBeans;
    }

    /**
     * Updates classifications to an existing graphStore represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the graphStore
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given graphStore guid
     */
    public GraphStore updateGraphStoreClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateGraphStoreClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           GraphStore  graphStoreClassificationBeans = GraphStoreMapper.mapOmrsEntityDetailToGraphStore(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  graphStoreClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing graphStore represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the graphStore
     * @param name name of the classification
     * @return deleted GraphStore  classification
     */
    public GraphStore deleteGraphStoreClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteGraphStoreClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       GraphStore declassifiedGraphStore =  GraphStoreMapper.mapOmrsEntityDetailToGraphStore(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedGraphStore;
    }

    /**
      * Get the relationships associated with entity graphStore represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the graphStore
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getGraphStoreRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getGraphStoreRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an metadataRepositoryCohort given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the metadataRepositoryCohorts relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return MetadataRepositoryCohort the MetadataRepositoryCohort entity with the requested GUID
     */
    public MetadataRepositoryCohort getMetadataRepositoryCohort(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getMetadataRepositoryCohort";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        MetadataRepositoryCohort gotmetadataRepositoryCohort = MetadataRepositoryCohortMapper.mapOmrsEntityDetailToMetadataRepositoryCohort(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotmetadataRepositoryCohort );
        }
        return gotmetadataRepositoryCohort;

    }
    /**
     * Create new metadataRepositoryCohort.
     * @param userId user identity
     * @param metadataRepositoryCohort the input entity with values.
     * @return MetadataRepositoryCohort the created entity.
     */

    public MetadataRepositoryCohort createMetadataRepositoryCohort(String userId,MetadataRepositoryCohort metadataRepositoryCohort)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createMetadataRepositoryCohort";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = MetadataRepositoryCohortMapper.mapMetadataRepositoryCohortToOmrsEntityDetail(metadataRepositoryCohort);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        MetadataRepositoryCohort createdMetadataRepositoryCohort =  MetadataRepositoryCohortMapper.mapOmrsEntityDetailToMetadataRepositoryCohort(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created MetadataRepositoryCohort="+ createdMetadataRepositoryCohort );
        }
        return createdMetadataRepositoryCohort;
    }
    /**
     * Update metadataRepositoryCohort
     * @param userId user identity
     * @param metadataRepositoryCohort   metadataRepositoryCohort to update
     * @return MetadataRepositoryCohort the updated metadataRepositoryCohort entity
     */
    public MetadataRepositoryCohort updateMetadataRepositoryCohort(String userId, MetadataRepositoryCohort metadataRepositoryCohort)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateMetadataRepositoryCohort";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = MetadataRepositoryCohortMapper.mapMetadataRepositoryCohortToOmrsEntityDetail(metadataRepositoryCohort);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            MetadataRepositoryCohort updatedMetadataRepositoryCohort =  MetadataRepositoryCohortMapper.mapOmrsEntityDetailToMetadataRepositoryCohort(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated MetadataRepositoryCohort="+ updatedMetadataRepositoryCohort );
            }
            return updatedMetadataRepositoryCohort;
        }

    /**
     * Delete an metadataRepositoryCohort identified by its GUID. Delete is a soft delete, this means that the metadataRepositoryCohort has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the metadataRepositoryCohort
     * @return MetadataRepositoryCohort the deleted MetadataRepositoryCohort entity
     */

    public MetadataRepositoryCohort deleteMetadataRepositoryCohort(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteMetadataRepositoryCohort";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the MetadataRepositoryCohort type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("MetadataRepositoryCohort");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"MetadataRepositoryCohort",entityDef.getGUID(),entityGuid);
         MetadataRepositoryCohort deletedMetadataRepositoryCohort = MetadataRepositoryCohortMapper.mapOmrsEntityDetailToMetadataRepositoryCohort(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedMetadataRepositoryCohort;

    }
    /**
     * Purge an metadataRepositoryCohort identified by its GUID. Delete is a hard delete, this means that the metadataRepositoryCohort is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the metadataRepositoryCohort
     */
    public void purgeMetadataRepositoryCohort(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeMetadataRepositoryCohort";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the MetadataRepositoryCohort type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("MetadataRepositoryCohort");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"MetadataRepositoryCohort",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an MetadataRepositoryCohort identified by its GUID. Restore resurrects a soft deleted MetadataRepositoryCohort. When a MetadataRepositoryCohort was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the MetadataRepositoryCohort
     * @return  MetadataRepositoryCohort the restored MetadataRepositoryCohort
     */
    public MetadataRepositoryCohort restoreMetadataRepositoryCohort(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreMetadataRepositoryCohort";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        MetadataRepositoryCohort restoredMetadataRepositoryCohort =  MetadataRepositoryCohortMapper.mapOmrsEntityDetailToMetadataRepositoryCohort(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredMetadataRepositoryCohort;
    }    

    /**
     * Add classifications to the supplied metadataRepositoryCohort
     * @param userId user identity
     * @param entityGuid the GUID value for metadataRepositoryCohort
     * @param classifications the classifications to apply.
     * @return the metadataRepositoryCohort entity that has been classified
     */
     public MetadataRepositoryCohort addMetadataRepositoryCohortClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addMetadataRepositoryCohortClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         MetadataRepositoryCohort metadataRepositoryCohortClassificationBeans = MetadataRepositoryCohortMapper.mapOmrsEntityDetailToMetadataRepositoryCohort(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified MetadataRepositoryCohort=" +  metadataRepositoryCohortClassificationBeans);
         }
         return  metadataRepositoryCohortClassificationBeans;
    }

    /**
     * Updates classifications to an existing metadataRepositoryCohort represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the metadataRepositoryCohort
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given metadataRepositoryCohort guid
     */
    public MetadataRepositoryCohort updateMetadataRepositoryCohortClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateMetadataRepositoryCohortClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           MetadataRepositoryCohort  metadataRepositoryCohortClassificationBeans = MetadataRepositoryCohortMapper.mapOmrsEntityDetailToMetadataRepositoryCohort(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  metadataRepositoryCohortClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing metadataRepositoryCohort represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the metadataRepositoryCohort
     * @param name name of the classification
     * @return deleted MetadataRepositoryCohort  classification
     */
    public MetadataRepositoryCohort deleteMetadataRepositoryCohortClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteMetadataRepositoryCohortClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       MetadataRepositoryCohort declassifiedMetadataRepositoryCohort =  MetadataRepositoryCohortMapper.mapOmrsEntityDetailToMetadataRepositoryCohort(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedMetadataRepositoryCohort;
    }

    /**
      * Get the relationships associated with entity metadataRepositoryCohort represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the metadataRepositoryCohort
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getMetadataRepositoryCohortRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getMetadataRepositoryCohortRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an arrayDocumentType given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the arrayDocumentTypes relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return ArrayDocumentType the ArrayDocumentType entity with the requested GUID
     */
    public ArrayDocumentType getArrayDocumentType(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getArrayDocumentType";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        ArrayDocumentType gotarrayDocumentType = ArrayDocumentTypeMapper.mapOmrsEntityDetailToArrayDocumentType(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotarrayDocumentType );
        }
        return gotarrayDocumentType;

    }
    /**
     * Create new arrayDocumentType.
     * @param userId user identity
     * @param arrayDocumentType the input entity with values.
     * @return ArrayDocumentType the created entity.
     */

    public ArrayDocumentType createArrayDocumentType(String userId,ArrayDocumentType arrayDocumentType)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createArrayDocumentType";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = ArrayDocumentTypeMapper.mapArrayDocumentTypeToOmrsEntityDetail(arrayDocumentType);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        ArrayDocumentType createdArrayDocumentType =  ArrayDocumentTypeMapper.mapOmrsEntityDetailToArrayDocumentType(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created ArrayDocumentType="+ createdArrayDocumentType );
        }
        return createdArrayDocumentType;
    }
    /**
     * Update arrayDocumentType
     * @param userId user identity
     * @param arrayDocumentType   arrayDocumentType to update
     * @return ArrayDocumentType the updated arrayDocumentType entity
     */
    public ArrayDocumentType updateArrayDocumentType(String userId, ArrayDocumentType arrayDocumentType)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateArrayDocumentType";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = ArrayDocumentTypeMapper.mapArrayDocumentTypeToOmrsEntityDetail(arrayDocumentType);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            ArrayDocumentType updatedArrayDocumentType =  ArrayDocumentTypeMapper.mapOmrsEntityDetailToArrayDocumentType(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated ArrayDocumentType="+ updatedArrayDocumentType );
            }
            return updatedArrayDocumentType;
        }

    /**
     * Delete an arrayDocumentType identified by its GUID. Delete is a soft delete, this means that the arrayDocumentType has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the arrayDocumentType
     * @return ArrayDocumentType the deleted ArrayDocumentType entity
     */

    public ArrayDocumentType deleteArrayDocumentType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteArrayDocumentType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ArrayDocumentType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ArrayDocumentType");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"ArrayDocumentType",entityDef.getGUID(),entityGuid);
         ArrayDocumentType deletedArrayDocumentType = ArrayDocumentTypeMapper.mapOmrsEntityDetailToArrayDocumentType(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedArrayDocumentType;

    }
    /**
     * Purge an arrayDocumentType identified by its GUID. Delete is a hard delete, this means that the arrayDocumentType is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the arrayDocumentType
     */
    public void purgeArrayDocumentType(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeArrayDocumentType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ArrayDocumentType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ArrayDocumentType");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"ArrayDocumentType",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an ArrayDocumentType identified by its GUID. Restore resurrects a soft deleted ArrayDocumentType. When a ArrayDocumentType was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the ArrayDocumentType
     * @return  ArrayDocumentType the restored ArrayDocumentType
     */
    public ArrayDocumentType restoreArrayDocumentType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreArrayDocumentType";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        ArrayDocumentType restoredArrayDocumentType =  ArrayDocumentTypeMapper.mapOmrsEntityDetailToArrayDocumentType(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredArrayDocumentType;
    }    

    /**
     * Add classifications to the supplied arrayDocumentType
     * @param userId user identity
     * @param entityGuid the GUID value for arrayDocumentType
     * @param classifications the classifications to apply.
     * @return the arrayDocumentType entity that has been classified
     */
     public ArrayDocumentType addArrayDocumentTypeClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addArrayDocumentTypeClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         ArrayDocumentType arrayDocumentTypeClassificationBeans = ArrayDocumentTypeMapper.mapOmrsEntityDetailToArrayDocumentType(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified ArrayDocumentType=" +  arrayDocumentTypeClassificationBeans);
         }
         return  arrayDocumentTypeClassificationBeans;
    }

    /**
     * Updates classifications to an existing arrayDocumentType represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the arrayDocumentType
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given arrayDocumentType guid
     */
    public ArrayDocumentType updateArrayDocumentTypeClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateArrayDocumentTypeClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           ArrayDocumentType  arrayDocumentTypeClassificationBeans = ArrayDocumentTypeMapper.mapOmrsEntityDetailToArrayDocumentType(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  arrayDocumentTypeClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing arrayDocumentType represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the arrayDocumentType
     * @param name name of the classification
     * @return deleted ArrayDocumentType  classification
     */
    public ArrayDocumentType deleteArrayDocumentTypeClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteArrayDocumentTypeClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       ArrayDocumentType declassifiedArrayDocumentType =  ArrayDocumentTypeMapper.mapOmrsEntityDetailToArrayDocumentType(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedArrayDocumentType;
    }

    /**
      * Get the relationships associated with entity arrayDocumentType represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the arrayDocumentType
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getArrayDocumentTypeRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getArrayDocumentTypeRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an openDiscoveryAnalysisReport given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the openDiscoveryAnalysisReports relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return OpenDiscoveryAnalysisReport the OpenDiscoveryAnalysisReport entity with the requested GUID
     */
    public OpenDiscoveryAnalysisReport getOpenDiscoveryAnalysisReport(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getOpenDiscoveryAnalysisReport";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        OpenDiscoveryAnalysisReport gotopenDiscoveryAnalysisReport = OpenDiscoveryAnalysisReportMapper.mapOmrsEntityDetailToOpenDiscoveryAnalysisReport(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotopenDiscoveryAnalysisReport );
        }
        return gotopenDiscoveryAnalysisReport;

    }
    /**
     * Create new openDiscoveryAnalysisReport.
     * @param userId user identity
     * @param openDiscoveryAnalysisReport the input entity with values.
     * @return OpenDiscoveryAnalysisReport the created entity.
     */

    public OpenDiscoveryAnalysisReport createOpenDiscoveryAnalysisReport(String userId,OpenDiscoveryAnalysisReport openDiscoveryAnalysisReport)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createOpenDiscoveryAnalysisReport";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = OpenDiscoveryAnalysisReportMapper.mapOpenDiscoveryAnalysisReportToOmrsEntityDetail(openDiscoveryAnalysisReport);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        OpenDiscoveryAnalysisReport createdOpenDiscoveryAnalysisReport =  OpenDiscoveryAnalysisReportMapper.mapOmrsEntityDetailToOpenDiscoveryAnalysisReport(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created OpenDiscoveryAnalysisReport="+ createdOpenDiscoveryAnalysisReport );
        }
        return createdOpenDiscoveryAnalysisReport;
    }
    /**
     * Update openDiscoveryAnalysisReport
     * @param userId user identity
     * @param openDiscoveryAnalysisReport   openDiscoveryAnalysisReport to update
     * @return OpenDiscoveryAnalysisReport the updated openDiscoveryAnalysisReport entity
     */
    public OpenDiscoveryAnalysisReport updateOpenDiscoveryAnalysisReport(String userId, OpenDiscoveryAnalysisReport openDiscoveryAnalysisReport)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateOpenDiscoveryAnalysisReport";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = OpenDiscoveryAnalysisReportMapper.mapOpenDiscoveryAnalysisReportToOmrsEntityDetail(openDiscoveryAnalysisReport);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            OpenDiscoveryAnalysisReport updatedOpenDiscoveryAnalysisReport =  OpenDiscoveryAnalysisReportMapper.mapOmrsEntityDetailToOpenDiscoveryAnalysisReport(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated OpenDiscoveryAnalysisReport="+ updatedOpenDiscoveryAnalysisReport );
            }
            return updatedOpenDiscoveryAnalysisReport;
        }

    /**
     * Delete an openDiscoveryAnalysisReport identified by its GUID. Delete is a soft delete, this means that the openDiscoveryAnalysisReport has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the openDiscoveryAnalysisReport
     * @return OpenDiscoveryAnalysisReport the deleted OpenDiscoveryAnalysisReport entity
     */

    public OpenDiscoveryAnalysisReport deleteOpenDiscoveryAnalysisReport(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteOpenDiscoveryAnalysisReport";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the OpenDiscoveryAnalysisReport type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("OpenDiscoveryAnalysisReport");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"OpenDiscoveryAnalysisReport",entityDef.getGUID(),entityGuid);
         OpenDiscoveryAnalysisReport deletedOpenDiscoveryAnalysisReport = OpenDiscoveryAnalysisReportMapper.mapOmrsEntityDetailToOpenDiscoveryAnalysisReport(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedOpenDiscoveryAnalysisReport;

    }
    /**
     * Purge an openDiscoveryAnalysisReport identified by its GUID. Delete is a hard delete, this means that the openDiscoveryAnalysisReport is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the openDiscoveryAnalysisReport
     */
    public void purgeOpenDiscoveryAnalysisReport(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeOpenDiscoveryAnalysisReport";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the OpenDiscoveryAnalysisReport type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("OpenDiscoveryAnalysisReport");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"OpenDiscoveryAnalysisReport",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an OpenDiscoveryAnalysisReport identified by its GUID. Restore resurrects a soft deleted OpenDiscoveryAnalysisReport. When a OpenDiscoveryAnalysisReport was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the OpenDiscoveryAnalysisReport
     * @return  OpenDiscoveryAnalysisReport the restored OpenDiscoveryAnalysisReport
     */
    public OpenDiscoveryAnalysisReport restoreOpenDiscoveryAnalysisReport(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreOpenDiscoveryAnalysisReport";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        OpenDiscoveryAnalysisReport restoredOpenDiscoveryAnalysisReport =  OpenDiscoveryAnalysisReportMapper.mapOmrsEntityDetailToOpenDiscoveryAnalysisReport(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredOpenDiscoveryAnalysisReport;
    }    

    /**
     * Add classifications to the supplied openDiscoveryAnalysisReport
     * @param userId user identity
     * @param entityGuid the GUID value for openDiscoveryAnalysisReport
     * @param classifications the classifications to apply.
     * @return the openDiscoveryAnalysisReport entity that has been classified
     */
     public OpenDiscoveryAnalysisReport addOpenDiscoveryAnalysisReportClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addOpenDiscoveryAnalysisReportClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         OpenDiscoveryAnalysisReport openDiscoveryAnalysisReportClassificationBeans = OpenDiscoveryAnalysisReportMapper.mapOmrsEntityDetailToOpenDiscoveryAnalysisReport(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified OpenDiscoveryAnalysisReport=" +  openDiscoveryAnalysisReportClassificationBeans);
         }
         return  openDiscoveryAnalysisReportClassificationBeans;
    }

    /**
     * Updates classifications to an existing openDiscoveryAnalysisReport represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the openDiscoveryAnalysisReport
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given openDiscoveryAnalysisReport guid
     */
    public OpenDiscoveryAnalysisReport updateOpenDiscoveryAnalysisReportClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateOpenDiscoveryAnalysisReportClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           OpenDiscoveryAnalysisReport  openDiscoveryAnalysisReportClassificationBeans = OpenDiscoveryAnalysisReportMapper.mapOmrsEntityDetailToOpenDiscoveryAnalysisReport(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  openDiscoveryAnalysisReportClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing openDiscoveryAnalysisReport represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the openDiscoveryAnalysisReport
     * @param name name of the classification
     * @return deleted OpenDiscoveryAnalysisReport  classification
     */
    public OpenDiscoveryAnalysisReport deleteOpenDiscoveryAnalysisReportClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteOpenDiscoveryAnalysisReportClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       OpenDiscoveryAnalysisReport declassifiedOpenDiscoveryAnalysisReport =  OpenDiscoveryAnalysisReportMapper.mapOmrsEntityDetailToOpenDiscoveryAnalysisReport(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedOpenDiscoveryAnalysisReport;
    }

    /**
      * Get the relationships associated with entity openDiscoveryAnalysisReport represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the openDiscoveryAnalysisReport
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getOpenDiscoveryAnalysisReportRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getOpenDiscoveryAnalysisReportRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an virtualConnection given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the virtualConnections relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return VirtualConnection the VirtualConnection entity with the requested GUID
     */
    public VirtualConnection getVirtualConnection(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getVirtualConnection";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        VirtualConnection gotvirtualConnection = VirtualConnectionMapper.mapOmrsEntityDetailToVirtualConnection(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotvirtualConnection );
        }
        return gotvirtualConnection;

    }
    /**
     * Create new virtualConnection.
     * @param userId user identity
     * @param virtualConnection the input entity with values.
     * @return VirtualConnection the created entity.
     */

    public VirtualConnection createVirtualConnection(String userId,VirtualConnection virtualConnection)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createVirtualConnection";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = VirtualConnectionMapper.mapVirtualConnectionToOmrsEntityDetail(virtualConnection);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        VirtualConnection createdVirtualConnection =  VirtualConnectionMapper.mapOmrsEntityDetailToVirtualConnection(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created VirtualConnection="+ createdVirtualConnection );
        }
        return createdVirtualConnection;
    }
    /**
     * Update virtualConnection
     * @param userId user identity
     * @param virtualConnection   virtualConnection to update
     * @return VirtualConnection the updated virtualConnection entity
     */
    public VirtualConnection updateVirtualConnection(String userId, VirtualConnection virtualConnection)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateVirtualConnection";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = VirtualConnectionMapper.mapVirtualConnectionToOmrsEntityDetail(virtualConnection);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            VirtualConnection updatedVirtualConnection =  VirtualConnectionMapper.mapOmrsEntityDetailToVirtualConnection(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated VirtualConnection="+ updatedVirtualConnection );
            }
            return updatedVirtualConnection;
        }

    /**
     * Delete an virtualConnection identified by its GUID. Delete is a soft delete, this means that the virtualConnection has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the virtualConnection
     * @return VirtualConnection the deleted VirtualConnection entity
     */

    public VirtualConnection deleteVirtualConnection(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteVirtualConnection";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the VirtualConnection type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("VirtualConnection");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"VirtualConnection",entityDef.getGUID(),entityGuid);
         VirtualConnection deletedVirtualConnection = VirtualConnectionMapper.mapOmrsEntityDetailToVirtualConnection(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedVirtualConnection;

    }
    /**
     * Purge an virtualConnection identified by its GUID. Delete is a hard delete, this means that the virtualConnection is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the virtualConnection
     */
    public void purgeVirtualConnection(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeVirtualConnection";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the VirtualConnection type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("VirtualConnection");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"VirtualConnection",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an VirtualConnection identified by its GUID. Restore resurrects a soft deleted VirtualConnection. When a VirtualConnection was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the VirtualConnection
     * @return  VirtualConnection the restored VirtualConnection
     */
    public VirtualConnection restoreVirtualConnection(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreVirtualConnection";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        VirtualConnection restoredVirtualConnection =  VirtualConnectionMapper.mapOmrsEntityDetailToVirtualConnection(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredVirtualConnection;
    }    

    /**
     * Add classifications to the supplied virtualConnection
     * @param userId user identity
     * @param entityGuid the GUID value for virtualConnection
     * @param classifications the classifications to apply.
     * @return the virtualConnection entity that has been classified
     */
     public VirtualConnection addVirtualConnectionClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addVirtualConnectionClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         VirtualConnection virtualConnectionClassificationBeans = VirtualConnectionMapper.mapOmrsEntityDetailToVirtualConnection(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified VirtualConnection=" +  virtualConnectionClassificationBeans);
         }
         return  virtualConnectionClassificationBeans;
    }

    /**
     * Updates classifications to an existing virtualConnection represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the virtualConnection
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given virtualConnection guid
     */
    public VirtualConnection updateVirtualConnectionClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateVirtualConnectionClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           VirtualConnection  virtualConnectionClassificationBeans = VirtualConnectionMapper.mapOmrsEntityDetailToVirtualConnection(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  virtualConnectionClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing virtualConnection represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the virtualConnection
     * @param name name of the classification
     * @return deleted VirtualConnection  classification
     */
    public VirtualConnection deleteVirtualConnectionClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteVirtualConnectionClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       VirtualConnection declassifiedVirtualConnection =  VirtualConnectionMapper.mapOmrsEntityDetailToVirtualConnection(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedVirtualConnection;
    }

    /**
      * Get the relationships associated with entity virtualConnection represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the virtualConnection
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getVirtualConnectionRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getVirtualConnectionRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an tabularColumn given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the tabularColumns relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return TabularColumn the TabularColumn entity with the requested GUID
     */
    public TabularColumn getTabularColumn(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getTabularColumn";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        TabularColumn gottabularColumn = TabularColumnMapper.mapOmrsEntityDetailToTabularColumn(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gottabularColumn );
        }
        return gottabularColumn;

    }
    /**
     * Create new tabularColumn.
     * @param userId user identity
     * @param tabularColumn the input entity with values.
     * @return TabularColumn the created entity.
     */

    public TabularColumn createTabularColumn(String userId,TabularColumn tabularColumn)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createTabularColumn";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = TabularColumnMapper.mapTabularColumnToOmrsEntityDetail(tabularColumn);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        TabularColumn createdTabularColumn =  TabularColumnMapper.mapOmrsEntityDetailToTabularColumn(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created TabularColumn="+ createdTabularColumn );
        }
        return createdTabularColumn;
    }
    /**
     * Update tabularColumn
     * @param userId user identity
     * @param tabularColumn   tabularColumn to update
     * @return TabularColumn the updated tabularColumn entity
     */
    public TabularColumn updateTabularColumn(String userId, TabularColumn tabularColumn)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateTabularColumn";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = TabularColumnMapper.mapTabularColumnToOmrsEntityDetail(tabularColumn);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            TabularColumn updatedTabularColumn =  TabularColumnMapper.mapOmrsEntityDetailToTabularColumn(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated TabularColumn="+ updatedTabularColumn );
            }
            return updatedTabularColumn;
        }

    /**
     * Delete an tabularColumn identified by its GUID. Delete is a soft delete, this means that the tabularColumn has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the tabularColumn
     * @return TabularColumn the deleted TabularColumn entity
     */

    public TabularColumn deleteTabularColumn(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteTabularColumn";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the TabularColumn type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("TabularColumn");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"TabularColumn",entityDef.getGUID(),entityGuid);
         TabularColumn deletedTabularColumn = TabularColumnMapper.mapOmrsEntityDetailToTabularColumn(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedTabularColumn;

    }
    /**
     * Purge an tabularColumn identified by its GUID. Delete is a hard delete, this means that the tabularColumn is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the tabularColumn
     */
    public void purgeTabularColumn(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeTabularColumn";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the TabularColumn type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("TabularColumn");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"TabularColumn",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an TabularColumn identified by its GUID. Restore resurrects a soft deleted TabularColumn. When a TabularColumn was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the TabularColumn
     * @return  TabularColumn the restored TabularColumn
     */
    public TabularColumn restoreTabularColumn(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreTabularColumn";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        TabularColumn restoredTabularColumn =  TabularColumnMapper.mapOmrsEntityDetailToTabularColumn(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredTabularColumn;
    }    

    /**
     * Add classifications to the supplied tabularColumn
     * @param userId user identity
     * @param entityGuid the GUID value for tabularColumn
     * @param classifications the classifications to apply.
     * @return the tabularColumn entity that has been classified
     */
     public TabularColumn addTabularColumnClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addTabularColumnClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         TabularColumn tabularColumnClassificationBeans = TabularColumnMapper.mapOmrsEntityDetailToTabularColumn(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified TabularColumn=" +  tabularColumnClassificationBeans);
         }
         return  tabularColumnClassificationBeans;
    }

    /**
     * Updates classifications to an existing tabularColumn represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the tabularColumn
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given tabularColumn guid
     */
    public TabularColumn updateTabularColumnClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateTabularColumnClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           TabularColumn  tabularColumnClassificationBeans = TabularColumnMapper.mapOmrsEntityDetailToTabularColumn(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  tabularColumnClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing tabularColumn represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the tabularColumn
     * @param name name of the classification
     * @return deleted TabularColumn  classification
     */
    public TabularColumn deleteTabularColumnClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteTabularColumnClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       TabularColumn declassifiedTabularColumn =  TabularColumnMapper.mapOmrsEntityDetailToTabularColumn(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedTabularColumn;
    }

    /**
      * Get the relationships associated with entity tabularColumn represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the tabularColumn
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getTabularColumnRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getTabularColumnRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an derivedRelationalColumn given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the derivedRelationalColumns relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return DerivedRelationalColumn the DerivedRelationalColumn entity with the requested GUID
     */
    public DerivedRelationalColumn getDerivedRelationalColumn(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getDerivedRelationalColumn";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        DerivedRelationalColumn gotderivedRelationalColumn = DerivedRelationalColumnMapper.mapOmrsEntityDetailToDerivedRelationalColumn(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotderivedRelationalColumn );
        }
        return gotderivedRelationalColumn;

    }
    /**
     * Create new derivedRelationalColumn.
     * @param userId user identity
     * @param derivedRelationalColumn the input entity with values.
     * @return DerivedRelationalColumn the created entity.
     */

    public DerivedRelationalColumn createDerivedRelationalColumn(String userId,DerivedRelationalColumn derivedRelationalColumn)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createDerivedRelationalColumn";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = DerivedRelationalColumnMapper.mapDerivedRelationalColumnToOmrsEntityDetail(derivedRelationalColumn);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        DerivedRelationalColumn createdDerivedRelationalColumn =  DerivedRelationalColumnMapper.mapOmrsEntityDetailToDerivedRelationalColumn(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created DerivedRelationalColumn="+ createdDerivedRelationalColumn );
        }
        return createdDerivedRelationalColumn;
    }
    /**
     * Update derivedRelationalColumn
     * @param userId user identity
     * @param derivedRelationalColumn   derivedRelationalColumn to update
     * @return DerivedRelationalColumn the updated derivedRelationalColumn entity
     */
    public DerivedRelationalColumn updateDerivedRelationalColumn(String userId, DerivedRelationalColumn derivedRelationalColumn)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateDerivedRelationalColumn";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = DerivedRelationalColumnMapper.mapDerivedRelationalColumnToOmrsEntityDetail(derivedRelationalColumn);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            DerivedRelationalColumn updatedDerivedRelationalColumn =  DerivedRelationalColumnMapper.mapOmrsEntityDetailToDerivedRelationalColumn(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated DerivedRelationalColumn="+ updatedDerivedRelationalColumn );
            }
            return updatedDerivedRelationalColumn;
        }

    /**
     * Delete an derivedRelationalColumn identified by its GUID. Delete is a soft delete, this means that the derivedRelationalColumn has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the derivedRelationalColumn
     * @return DerivedRelationalColumn the deleted DerivedRelationalColumn entity
     */

    public DerivedRelationalColumn deleteDerivedRelationalColumn(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteDerivedRelationalColumn";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DerivedRelationalColumn type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DerivedRelationalColumn");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"DerivedRelationalColumn",entityDef.getGUID(),entityGuid);
         DerivedRelationalColumn deletedDerivedRelationalColumn = DerivedRelationalColumnMapper.mapOmrsEntityDetailToDerivedRelationalColumn(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedDerivedRelationalColumn;

    }
    /**
     * Purge an derivedRelationalColumn identified by its GUID. Delete is a hard delete, this means that the derivedRelationalColumn is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the derivedRelationalColumn
     */
    public void purgeDerivedRelationalColumn(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeDerivedRelationalColumn";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DerivedRelationalColumn type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DerivedRelationalColumn");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"DerivedRelationalColumn",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an DerivedRelationalColumn identified by its GUID. Restore resurrects a soft deleted DerivedRelationalColumn. When a DerivedRelationalColumn was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the DerivedRelationalColumn
     * @return  DerivedRelationalColumn the restored DerivedRelationalColumn
     */
    public DerivedRelationalColumn restoreDerivedRelationalColumn(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreDerivedRelationalColumn";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        DerivedRelationalColumn restoredDerivedRelationalColumn =  DerivedRelationalColumnMapper.mapOmrsEntityDetailToDerivedRelationalColumn(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredDerivedRelationalColumn;
    }    

    /**
     * Add classifications to the supplied derivedRelationalColumn
     * @param userId user identity
     * @param entityGuid the GUID value for derivedRelationalColumn
     * @param classifications the classifications to apply.
     * @return the derivedRelationalColumn entity that has been classified
     */
     public DerivedRelationalColumn addDerivedRelationalColumnClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addDerivedRelationalColumnClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         DerivedRelationalColumn derivedRelationalColumnClassificationBeans = DerivedRelationalColumnMapper.mapOmrsEntityDetailToDerivedRelationalColumn(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified DerivedRelationalColumn=" +  derivedRelationalColumnClassificationBeans);
         }
         return  derivedRelationalColumnClassificationBeans;
    }

    /**
     * Updates classifications to an existing derivedRelationalColumn represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the derivedRelationalColumn
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given derivedRelationalColumn guid
     */
    public DerivedRelationalColumn updateDerivedRelationalColumnClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateDerivedRelationalColumnClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           DerivedRelationalColumn  derivedRelationalColumnClassificationBeans = DerivedRelationalColumnMapper.mapOmrsEntityDetailToDerivedRelationalColumn(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  derivedRelationalColumnClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing derivedRelationalColumn represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the derivedRelationalColumn
     * @param name name of the classification
     * @return deleted DerivedRelationalColumn  classification
     */
    public DerivedRelationalColumn deleteDerivedRelationalColumnClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteDerivedRelationalColumnClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       DerivedRelationalColumn declassifiedDerivedRelationalColumn =  DerivedRelationalColumnMapper.mapOmrsEntityDetailToDerivedRelationalColumn(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedDerivedRelationalColumn;
    }

    /**
      * Get the relationships associated with entity derivedRelationalColumn represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the derivedRelationalColumn
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getDerivedRelationalColumnRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getDerivedRelationalColumnRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an schemaAttribute given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the schemaAttributes relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return SchemaAttribute the SchemaAttribute entity with the requested GUID
     */
    public SchemaAttribute getSchemaAttribute(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getSchemaAttribute";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        SchemaAttribute gotschemaAttribute = SchemaAttributeMapper.mapOmrsEntityDetailToSchemaAttribute(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotschemaAttribute );
        }
        return gotschemaAttribute;

    }
    /**
     * Create new schemaAttribute.
     * @param userId user identity
     * @param schemaAttribute the input entity with values.
     * @return SchemaAttribute the created entity.
     */

    public SchemaAttribute createSchemaAttribute(String userId,SchemaAttribute schemaAttribute)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createSchemaAttribute";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = SchemaAttributeMapper.mapSchemaAttributeToOmrsEntityDetail(schemaAttribute);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        SchemaAttribute createdSchemaAttribute =  SchemaAttributeMapper.mapOmrsEntityDetailToSchemaAttribute(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created SchemaAttribute="+ createdSchemaAttribute );
        }
        return createdSchemaAttribute;
    }
    /**
     * Update schemaAttribute
     * @param userId user identity
     * @param schemaAttribute   schemaAttribute to update
     * @return SchemaAttribute the updated schemaAttribute entity
     */
    public SchemaAttribute updateSchemaAttribute(String userId, SchemaAttribute schemaAttribute)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateSchemaAttribute";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = SchemaAttributeMapper.mapSchemaAttributeToOmrsEntityDetail(schemaAttribute);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            SchemaAttribute updatedSchemaAttribute =  SchemaAttributeMapper.mapOmrsEntityDetailToSchemaAttribute(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated SchemaAttribute="+ updatedSchemaAttribute );
            }
            return updatedSchemaAttribute;
        }

    /**
     * Delete an schemaAttribute identified by its GUID. Delete is a soft delete, this means that the schemaAttribute has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the schemaAttribute
     * @return SchemaAttribute the deleted SchemaAttribute entity
     */

    public SchemaAttribute deleteSchemaAttribute(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteSchemaAttribute";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the SchemaAttribute type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("SchemaAttribute");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"SchemaAttribute",entityDef.getGUID(),entityGuid);
         SchemaAttribute deletedSchemaAttribute = SchemaAttributeMapper.mapOmrsEntityDetailToSchemaAttribute(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedSchemaAttribute;

    }
    /**
     * Purge an schemaAttribute identified by its GUID. Delete is a hard delete, this means that the schemaAttribute is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the schemaAttribute
     */
    public void purgeSchemaAttribute(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeSchemaAttribute";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the SchemaAttribute type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("SchemaAttribute");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"SchemaAttribute",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an SchemaAttribute identified by its GUID. Restore resurrects a soft deleted SchemaAttribute. When a SchemaAttribute was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the SchemaAttribute
     * @return  SchemaAttribute the restored SchemaAttribute
     */
    public SchemaAttribute restoreSchemaAttribute(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreSchemaAttribute";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        SchemaAttribute restoredSchemaAttribute =  SchemaAttributeMapper.mapOmrsEntityDetailToSchemaAttribute(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredSchemaAttribute;
    }    

    /**
     * Add classifications to the supplied schemaAttribute
     * @param userId user identity
     * @param entityGuid the GUID value for schemaAttribute
     * @param classifications the classifications to apply.
     * @return the schemaAttribute entity that has been classified
     */
     public SchemaAttribute addSchemaAttributeClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addSchemaAttributeClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         SchemaAttribute schemaAttributeClassificationBeans = SchemaAttributeMapper.mapOmrsEntityDetailToSchemaAttribute(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified SchemaAttribute=" +  schemaAttributeClassificationBeans);
         }
         return  schemaAttributeClassificationBeans;
    }

    /**
     * Updates classifications to an existing schemaAttribute represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the schemaAttribute
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given schemaAttribute guid
     */
    public SchemaAttribute updateSchemaAttributeClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateSchemaAttributeClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           SchemaAttribute  schemaAttributeClassificationBeans = SchemaAttributeMapper.mapOmrsEntityDetailToSchemaAttribute(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  schemaAttributeClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing schemaAttribute represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the schemaAttribute
     * @param name name of the classification
     * @return deleted SchemaAttribute  classification
     */
    public SchemaAttribute deleteSchemaAttributeClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteSchemaAttributeClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       SchemaAttribute declassifiedSchemaAttribute =  SchemaAttributeMapper.mapOmrsEntityDetailToSchemaAttribute(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedSchemaAttribute;
    }

    /**
      * Get the relationships associated with entity schemaAttribute represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the schemaAttribute
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getSchemaAttributeRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getSchemaAttributeRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an graphEdge given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the graphEdges relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return GraphEdge the GraphEdge entity with the requested GUID
     */
    public GraphEdge getGraphEdge(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getGraphEdge";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        GraphEdge gotgraphEdge = GraphEdgeMapper.mapOmrsEntityDetailToGraphEdge(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotgraphEdge );
        }
        return gotgraphEdge;

    }
    /**
     * Create new graphEdge.
     * @param userId user identity
     * @param graphEdge the input entity with values.
     * @return GraphEdge the created entity.
     */

    public GraphEdge createGraphEdge(String userId,GraphEdge graphEdge)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createGraphEdge";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = GraphEdgeMapper.mapGraphEdgeToOmrsEntityDetail(graphEdge);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        GraphEdge createdGraphEdge =  GraphEdgeMapper.mapOmrsEntityDetailToGraphEdge(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created GraphEdge="+ createdGraphEdge );
        }
        return createdGraphEdge;
    }
    /**
     * Update graphEdge
     * @param userId user identity
     * @param graphEdge   graphEdge to update
     * @return GraphEdge the updated graphEdge entity
     */
    public GraphEdge updateGraphEdge(String userId, GraphEdge graphEdge)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateGraphEdge";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = GraphEdgeMapper.mapGraphEdgeToOmrsEntityDetail(graphEdge);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            GraphEdge updatedGraphEdge =  GraphEdgeMapper.mapOmrsEntityDetailToGraphEdge(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated GraphEdge="+ updatedGraphEdge );
            }
            return updatedGraphEdge;
        }

    /**
     * Delete an graphEdge identified by its GUID. Delete is a soft delete, this means that the graphEdge has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the graphEdge
     * @return GraphEdge the deleted GraphEdge entity
     */

    public GraphEdge deleteGraphEdge(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteGraphEdge";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GraphEdge type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GraphEdge");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"GraphEdge",entityDef.getGUID(),entityGuid);
         GraphEdge deletedGraphEdge = GraphEdgeMapper.mapOmrsEntityDetailToGraphEdge(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedGraphEdge;

    }
    /**
     * Purge an graphEdge identified by its GUID. Delete is a hard delete, this means that the graphEdge is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the graphEdge
     */
    public void purgeGraphEdge(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeGraphEdge";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GraphEdge type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GraphEdge");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"GraphEdge",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an GraphEdge identified by its GUID. Restore resurrects a soft deleted GraphEdge. When a GraphEdge was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the GraphEdge
     * @return  GraphEdge the restored GraphEdge
     */
    public GraphEdge restoreGraphEdge(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreGraphEdge";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        GraphEdge restoredGraphEdge =  GraphEdgeMapper.mapOmrsEntityDetailToGraphEdge(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredGraphEdge;
    }    

    /**
     * Add classifications to the supplied graphEdge
     * @param userId user identity
     * @param entityGuid the GUID value for graphEdge
     * @param classifications the classifications to apply.
     * @return the graphEdge entity that has been classified
     */
     public GraphEdge addGraphEdgeClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addGraphEdgeClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         GraphEdge graphEdgeClassificationBeans = GraphEdgeMapper.mapOmrsEntityDetailToGraphEdge(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified GraphEdge=" +  graphEdgeClassificationBeans);
         }
         return  graphEdgeClassificationBeans;
    }

    /**
     * Updates classifications to an existing graphEdge represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the graphEdge
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given graphEdge guid
     */
    public GraphEdge updateGraphEdgeClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateGraphEdgeClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           GraphEdge  graphEdgeClassificationBeans = GraphEdgeMapper.mapOmrsEntityDetailToGraphEdge(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  graphEdgeClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing graphEdge represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the graphEdge
     * @param name name of the classification
     * @return deleted GraphEdge  classification
     */
    public GraphEdge deleteGraphEdgeClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteGraphEdgeClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       GraphEdge declassifiedGraphEdge =  GraphEdgeMapper.mapOmrsEntityDetailToGraphEdge(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedGraphEdge;
    }

    /**
      * Get the relationships associated with entity graphEdge represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the graphEdge
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getGraphEdgeRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getGraphEdgeRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an businessCapability given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the businessCapabilities relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return BusinessCapability the BusinessCapability entity with the requested GUID
     */
    public BusinessCapability getBusinessCapability(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getBusinessCapability";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        BusinessCapability gotbusinessCapability = BusinessCapabilityMapper.mapOmrsEntityDetailToBusinessCapability(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotbusinessCapability );
        }
        return gotbusinessCapability;

    }
    /**
     * Create new businessCapability.
     * @param userId user identity
     * @param businessCapability the input entity with values.
     * @return BusinessCapability the created entity.
     */

    public BusinessCapability createBusinessCapability(String userId,BusinessCapability businessCapability)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createBusinessCapability";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = BusinessCapabilityMapper.mapBusinessCapabilityToOmrsEntityDetail(businessCapability);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        BusinessCapability createdBusinessCapability =  BusinessCapabilityMapper.mapOmrsEntityDetailToBusinessCapability(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created BusinessCapability="+ createdBusinessCapability );
        }
        return createdBusinessCapability;
    }
    /**
     * Update businessCapability
     * @param userId user identity
     * @param businessCapability   businessCapability to update
     * @return BusinessCapability the updated businessCapability entity
     */
    public BusinessCapability updateBusinessCapability(String userId, BusinessCapability businessCapability)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateBusinessCapability";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = BusinessCapabilityMapper.mapBusinessCapabilityToOmrsEntityDetail(businessCapability);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            BusinessCapability updatedBusinessCapability =  BusinessCapabilityMapper.mapOmrsEntityDetailToBusinessCapability(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated BusinessCapability="+ updatedBusinessCapability );
            }
            return updatedBusinessCapability;
        }

    /**
     * Delete an businessCapability identified by its GUID. Delete is a soft delete, this means that the businessCapability has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the businessCapability
     * @return BusinessCapability the deleted BusinessCapability entity
     */

    public BusinessCapability deleteBusinessCapability(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteBusinessCapability";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the BusinessCapability type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("BusinessCapability");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"BusinessCapability",entityDef.getGUID(),entityGuid);
         BusinessCapability deletedBusinessCapability = BusinessCapabilityMapper.mapOmrsEntityDetailToBusinessCapability(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedBusinessCapability;

    }
    /**
     * Purge an businessCapability identified by its GUID. Delete is a hard delete, this means that the businessCapability is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the businessCapability
     */
    public void purgeBusinessCapability(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeBusinessCapability";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the BusinessCapability type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("BusinessCapability");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"BusinessCapability",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an BusinessCapability identified by its GUID. Restore resurrects a soft deleted BusinessCapability. When a BusinessCapability was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the BusinessCapability
     * @return  BusinessCapability the restored BusinessCapability
     */
    public BusinessCapability restoreBusinessCapability(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreBusinessCapability";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        BusinessCapability restoredBusinessCapability =  BusinessCapabilityMapper.mapOmrsEntityDetailToBusinessCapability(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredBusinessCapability;
    }    

    /**
     * Add classifications to the supplied businessCapability
     * @param userId user identity
     * @param entityGuid the GUID value for businessCapability
     * @param classifications the classifications to apply.
     * @return the businessCapability entity that has been classified
     */
     public BusinessCapability addBusinessCapabilityClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addBusinessCapabilityClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         BusinessCapability businessCapabilityClassificationBeans = BusinessCapabilityMapper.mapOmrsEntityDetailToBusinessCapability(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified BusinessCapability=" +  businessCapabilityClassificationBeans);
         }
         return  businessCapabilityClassificationBeans;
    }

    /**
     * Updates classifications to an existing businessCapability represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the businessCapability
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given businessCapability guid
     */
    public BusinessCapability updateBusinessCapabilityClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateBusinessCapabilityClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           BusinessCapability  businessCapabilityClassificationBeans = BusinessCapabilityMapper.mapOmrsEntityDetailToBusinessCapability(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  businessCapabilityClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing businessCapability represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the businessCapability
     * @param name name of the classification
     * @return deleted BusinessCapability  classification
     */
    public BusinessCapability deleteBusinessCapabilityClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteBusinessCapabilityClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       BusinessCapability declassifiedBusinessCapability =  BusinessCapabilityMapper.mapOmrsEntityDetailToBusinessCapability(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedBusinessCapability;
    }

    /**
      * Get the relationships associated with entity businessCapability represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the businessCapability
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getBusinessCapabilityRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getBusinessCapabilityRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an cohortRegistryStore given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the cohortRegistryStores relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return CohortRegistryStore the CohortRegistryStore entity with the requested GUID
     */
    public CohortRegistryStore getCohortRegistryStore(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getCohortRegistryStore";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        CohortRegistryStore gotcohortRegistryStore = CohortRegistryStoreMapper.mapOmrsEntityDetailToCohortRegistryStore(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotcohortRegistryStore );
        }
        return gotcohortRegistryStore;

    }
    /**
     * Create new cohortRegistryStore.
     * @param userId user identity
     * @param cohortRegistryStore the input entity with values.
     * @return CohortRegistryStore the created entity.
     */

    public CohortRegistryStore createCohortRegistryStore(String userId,CohortRegistryStore cohortRegistryStore)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createCohortRegistryStore";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = CohortRegistryStoreMapper.mapCohortRegistryStoreToOmrsEntityDetail(cohortRegistryStore);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        CohortRegistryStore createdCohortRegistryStore =  CohortRegistryStoreMapper.mapOmrsEntityDetailToCohortRegistryStore(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created CohortRegistryStore="+ createdCohortRegistryStore );
        }
        return createdCohortRegistryStore;
    }
    /**
     * Update cohortRegistryStore
     * @param userId user identity
     * @param cohortRegistryStore   cohortRegistryStore to update
     * @return CohortRegistryStore the updated cohortRegistryStore entity
     */
    public CohortRegistryStore updateCohortRegistryStore(String userId, CohortRegistryStore cohortRegistryStore)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateCohortRegistryStore";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = CohortRegistryStoreMapper.mapCohortRegistryStoreToOmrsEntityDetail(cohortRegistryStore);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            CohortRegistryStore updatedCohortRegistryStore =  CohortRegistryStoreMapper.mapOmrsEntityDetailToCohortRegistryStore(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated CohortRegistryStore="+ updatedCohortRegistryStore );
            }
            return updatedCohortRegistryStore;
        }

    /**
     * Delete an cohortRegistryStore identified by its GUID. Delete is a soft delete, this means that the cohortRegistryStore has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the cohortRegistryStore
     * @return CohortRegistryStore the deleted CohortRegistryStore entity
     */

    public CohortRegistryStore deleteCohortRegistryStore(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteCohortRegistryStore";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the CohortRegistryStore type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("CohortRegistryStore");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"CohortRegistryStore",entityDef.getGUID(),entityGuid);
         CohortRegistryStore deletedCohortRegistryStore = CohortRegistryStoreMapper.mapOmrsEntityDetailToCohortRegistryStore(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedCohortRegistryStore;

    }
    /**
     * Purge an cohortRegistryStore identified by its GUID. Delete is a hard delete, this means that the cohortRegistryStore is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the cohortRegistryStore
     */
    public void purgeCohortRegistryStore(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeCohortRegistryStore";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the CohortRegistryStore type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("CohortRegistryStore");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"CohortRegistryStore",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an CohortRegistryStore identified by its GUID. Restore resurrects a soft deleted CohortRegistryStore. When a CohortRegistryStore was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the CohortRegistryStore
     * @return  CohortRegistryStore the restored CohortRegistryStore
     */
    public CohortRegistryStore restoreCohortRegistryStore(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreCohortRegistryStore";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        CohortRegistryStore restoredCohortRegistryStore =  CohortRegistryStoreMapper.mapOmrsEntityDetailToCohortRegistryStore(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredCohortRegistryStore;
    }    

    /**
     * Add classifications to the supplied cohortRegistryStore
     * @param userId user identity
     * @param entityGuid the GUID value for cohortRegistryStore
     * @param classifications the classifications to apply.
     * @return the cohortRegistryStore entity that has been classified
     */
     public CohortRegistryStore addCohortRegistryStoreClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addCohortRegistryStoreClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         CohortRegistryStore cohortRegistryStoreClassificationBeans = CohortRegistryStoreMapper.mapOmrsEntityDetailToCohortRegistryStore(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified CohortRegistryStore=" +  cohortRegistryStoreClassificationBeans);
         }
         return  cohortRegistryStoreClassificationBeans;
    }

    /**
     * Updates classifications to an existing cohortRegistryStore represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the cohortRegistryStore
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given cohortRegistryStore guid
     */
    public CohortRegistryStore updateCohortRegistryStoreClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateCohortRegistryStoreClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           CohortRegistryStore  cohortRegistryStoreClassificationBeans = CohortRegistryStoreMapper.mapOmrsEntityDetailToCohortRegistryStore(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  cohortRegistryStoreClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing cohortRegistryStore represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the cohortRegistryStore
     * @param name name of the classification
     * @return deleted CohortRegistryStore  classification
     */
    public CohortRegistryStore deleteCohortRegistryStoreClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteCohortRegistryStoreClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       CohortRegistryStore declassifiedCohortRegistryStore =  CohortRegistryStoreMapper.mapOmrsEntityDetailToCohortRegistryStore(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedCohortRegistryStore;
    }

    /**
      * Get the relationships associated with entity cohortRegistryStore represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the cohortRegistryStore
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getCohortRegistryStoreRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getCohortRegistryStoreRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an eventType given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the eventTypes relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return EventType the EventType entity with the requested GUID
     */
    public EventType getEventType(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getEventType";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        EventType goteventType = EventTypeMapper.mapOmrsEntityDetailToEventType(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ goteventType );
        }
        return goteventType;

    }
    /**
     * Create new eventType.
     * @param userId user identity
     * @param eventType the input entity with values.
     * @return EventType the created entity.
     */

    public EventType createEventType(String userId,EventType eventType)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createEventType";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = EventTypeMapper.mapEventTypeToOmrsEntityDetail(eventType);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        EventType createdEventType =  EventTypeMapper.mapOmrsEntityDetailToEventType(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created EventType="+ createdEventType );
        }
        return createdEventType;
    }
    /**
     * Update eventType
     * @param userId user identity
     * @param eventType   eventType to update
     * @return EventType the updated eventType entity
     */
    public EventType updateEventType(String userId, EventType eventType)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateEventType";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = EventTypeMapper.mapEventTypeToOmrsEntityDetail(eventType);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            EventType updatedEventType =  EventTypeMapper.mapOmrsEntityDetailToEventType(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated EventType="+ updatedEventType );
            }
            return updatedEventType;
        }

    /**
     * Delete an eventType identified by its GUID. Delete is a soft delete, this means that the eventType has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the eventType
     * @return EventType the deleted EventType entity
     */

    public EventType deleteEventType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteEventType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the EventType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("EventType");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"EventType",entityDef.getGUID(),entityGuid);
         EventType deletedEventType = EventTypeMapper.mapOmrsEntityDetailToEventType(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedEventType;

    }
    /**
     * Purge an eventType identified by its GUID. Delete is a hard delete, this means that the eventType is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the eventType
     */
    public void purgeEventType(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeEventType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the EventType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("EventType");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"EventType",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an EventType identified by its GUID. Restore resurrects a soft deleted EventType. When a EventType was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the EventType
     * @return  EventType the restored EventType
     */
    public EventType restoreEventType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreEventType";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        EventType restoredEventType =  EventTypeMapper.mapOmrsEntityDetailToEventType(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredEventType;
    }    

    /**
     * Add classifications to the supplied eventType
     * @param userId user identity
     * @param entityGuid the GUID value for eventType
     * @param classifications the classifications to apply.
     * @return the eventType entity that has been classified
     */
     public EventType addEventTypeClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addEventTypeClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         EventType eventTypeClassificationBeans = EventTypeMapper.mapOmrsEntityDetailToEventType(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified EventType=" +  eventTypeClassificationBeans);
         }
         return  eventTypeClassificationBeans;
    }

    /**
     * Updates classifications to an existing eventType represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the eventType
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given eventType guid
     */
    public EventType updateEventTypeClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateEventTypeClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           EventType  eventTypeClassificationBeans = EventTypeMapper.mapOmrsEntityDetailToEventType(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  eventTypeClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing eventType represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the eventType
     * @param name name of the classification
     * @return deleted EventType  classification
     */
    public EventType deleteEventTypeClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteEventTypeClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       EventType declassifiedEventType =  EventTypeMapper.mapOmrsEntityDetailToEventType(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedEventType;
    }

    /**
      * Get the relationships associated with entity eventType represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the eventType
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getEventTypeRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getEventTypeRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an operatingPlatform given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the operatingPlatforms relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return OperatingPlatform the OperatingPlatform entity with the requested GUID
     */
    public OperatingPlatform getOperatingPlatform(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getOperatingPlatform";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        OperatingPlatform gotoperatingPlatform = OperatingPlatformMapper.mapOmrsEntityDetailToOperatingPlatform(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotoperatingPlatform );
        }
        return gotoperatingPlatform;

    }
    /**
     * Create new operatingPlatform.
     * @param userId user identity
     * @param operatingPlatform the input entity with values.
     * @return OperatingPlatform the created entity.
     */

    public OperatingPlatform createOperatingPlatform(String userId,OperatingPlatform operatingPlatform)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createOperatingPlatform";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = OperatingPlatformMapper.mapOperatingPlatformToOmrsEntityDetail(operatingPlatform);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        OperatingPlatform createdOperatingPlatform =  OperatingPlatformMapper.mapOmrsEntityDetailToOperatingPlatform(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created OperatingPlatform="+ createdOperatingPlatform );
        }
        return createdOperatingPlatform;
    }
    /**
     * Update operatingPlatform
     * @param userId user identity
     * @param operatingPlatform   operatingPlatform to update
     * @return OperatingPlatform the updated operatingPlatform entity
     */
    public OperatingPlatform updateOperatingPlatform(String userId, OperatingPlatform operatingPlatform)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateOperatingPlatform";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = OperatingPlatformMapper.mapOperatingPlatformToOmrsEntityDetail(operatingPlatform);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            OperatingPlatform updatedOperatingPlatform =  OperatingPlatformMapper.mapOmrsEntityDetailToOperatingPlatform(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated OperatingPlatform="+ updatedOperatingPlatform );
            }
            return updatedOperatingPlatform;
        }

    /**
     * Delete an operatingPlatform identified by its GUID. Delete is a soft delete, this means that the operatingPlatform has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the operatingPlatform
     * @return OperatingPlatform the deleted OperatingPlatform entity
     */

    public OperatingPlatform deleteOperatingPlatform(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteOperatingPlatform";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the OperatingPlatform type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("OperatingPlatform");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"OperatingPlatform",entityDef.getGUID(),entityGuid);
         OperatingPlatform deletedOperatingPlatform = OperatingPlatformMapper.mapOmrsEntityDetailToOperatingPlatform(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedOperatingPlatform;

    }
    /**
     * Purge an operatingPlatform identified by its GUID. Delete is a hard delete, this means that the operatingPlatform is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the operatingPlatform
     */
    public void purgeOperatingPlatform(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeOperatingPlatform";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the OperatingPlatform type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("OperatingPlatform");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"OperatingPlatform",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an OperatingPlatform identified by its GUID. Restore resurrects a soft deleted OperatingPlatform. When a OperatingPlatform was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the OperatingPlatform
     * @return  OperatingPlatform the restored OperatingPlatform
     */
    public OperatingPlatform restoreOperatingPlatform(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreOperatingPlatform";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        OperatingPlatform restoredOperatingPlatform =  OperatingPlatformMapper.mapOmrsEntityDetailToOperatingPlatform(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredOperatingPlatform;
    }    

    /**
     * Add classifications to the supplied operatingPlatform
     * @param userId user identity
     * @param entityGuid the GUID value for operatingPlatform
     * @param classifications the classifications to apply.
     * @return the operatingPlatform entity that has been classified
     */
     public OperatingPlatform addOperatingPlatformClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addOperatingPlatformClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         OperatingPlatform operatingPlatformClassificationBeans = OperatingPlatformMapper.mapOmrsEntityDetailToOperatingPlatform(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified OperatingPlatform=" +  operatingPlatformClassificationBeans);
         }
         return  operatingPlatformClassificationBeans;
    }

    /**
     * Updates classifications to an existing operatingPlatform represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the operatingPlatform
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given operatingPlatform guid
     */
    public OperatingPlatform updateOperatingPlatformClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateOperatingPlatformClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           OperatingPlatform  operatingPlatformClassificationBeans = OperatingPlatformMapper.mapOmrsEntityDetailToOperatingPlatform(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  operatingPlatformClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing operatingPlatform represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the operatingPlatform
     * @param name name of the classification
     * @return deleted OperatingPlatform  classification
     */
    public OperatingPlatform deleteOperatingPlatformClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteOperatingPlatformClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       OperatingPlatform declassifiedOperatingPlatform =  OperatingPlatformMapper.mapOmrsEntityDetailToOperatingPlatform(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedOperatingPlatform;
    }

    /**
      * Get the relationships associated with entity operatingPlatform represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the operatingPlatform
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getOperatingPlatformRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getOperatingPlatformRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an port given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the ports relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return Port the Port entity with the requested GUID
     */
    public Port getPort(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getPort";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        Port gotport = PortMapper.mapOmrsEntityDetailToPort(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotport );
        }
        return gotport;

    }
    /**
     * Create new port.
     * @param userId user identity
     * @param port the input entity with values.
     * @return Port the created entity.
     */

    public Port createPort(String userId,Port port)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createPort";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = PortMapper.mapPortToOmrsEntityDetail(port);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        Port createdPort =  PortMapper.mapOmrsEntityDetailToPort(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created Port="+ createdPort );
        }
        return createdPort;
    }
    /**
     * Update port
     * @param userId user identity
     * @param port   port to update
     * @return Port the updated port entity
     */
    public Port updatePort(String userId, Port port)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updatePort";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = PortMapper.mapPortToOmrsEntityDetail(port);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            Port updatedPort =  PortMapper.mapOmrsEntityDetailToPort(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated Port="+ updatedPort );
            }
            return updatedPort;
        }

    /**
     * Delete an port identified by its GUID. Delete is a soft delete, this means that the port has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the port
     * @return Port the deleted Port entity
     */

    public Port deletePort(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deletePort";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Port type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Port");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"Port",entityDef.getGUID(),entityGuid);
         Port deletedPort = PortMapper.mapOmrsEntityDetailToPort(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedPort;

    }
    /**
     * Purge an port identified by its GUID. Delete is a hard delete, this means that the port is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the port
     */
    public void purgePort(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgePort";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Port type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Port");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"Port",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an Port identified by its GUID. Restore resurrects a soft deleted Port. When a Port was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the Port
     * @return  Port the restored Port
     */
    public Port restorePort(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restorePort";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        Port restoredPort =  PortMapper.mapOmrsEntityDetailToPort(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredPort;
    }    

    /**
     * Add classifications to the supplied port
     * @param userId user identity
     * @param entityGuid the GUID value for port
     * @param classifications the classifications to apply.
     * @return the port entity that has been classified
     */
     public Port addPortClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addPortClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         Port portClassificationBeans = PortMapper.mapOmrsEntityDetailToPort(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified Port=" +  portClassificationBeans);
         }
         return  portClassificationBeans;
    }

    /**
     * Updates classifications to an existing port represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the port
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given port guid
     */
    public Port updatePortClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updatePortClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           Port  portClassificationBeans = PortMapper.mapOmrsEntityDetailToPort(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  portClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing port represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the port
     * @param name name of the classification
     * @return deleted Port  classification
     */
    public Port deletePortClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deletePortClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       Port declassifiedPort =  PortMapper.mapOmrsEntityDetailToPort(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedPort;
    }

    /**
      * Get the relationships associated with entity port represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the port
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getPortRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getPortRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an derivedSchemaAttribute given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the derivedSchemaAttributes relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return DerivedSchemaAttribute the DerivedSchemaAttribute entity with the requested GUID
     */
    public DerivedSchemaAttribute getDerivedSchemaAttribute(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getDerivedSchemaAttribute";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        DerivedSchemaAttribute gotderivedSchemaAttribute = DerivedSchemaAttributeMapper.mapOmrsEntityDetailToDerivedSchemaAttribute(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotderivedSchemaAttribute );
        }
        return gotderivedSchemaAttribute;

    }
    /**
     * Create new derivedSchemaAttribute.
     * @param userId user identity
     * @param derivedSchemaAttribute the input entity with values.
     * @return DerivedSchemaAttribute the created entity.
     */

    public DerivedSchemaAttribute createDerivedSchemaAttribute(String userId,DerivedSchemaAttribute derivedSchemaAttribute)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createDerivedSchemaAttribute";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = DerivedSchemaAttributeMapper.mapDerivedSchemaAttributeToOmrsEntityDetail(derivedSchemaAttribute);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        DerivedSchemaAttribute createdDerivedSchemaAttribute =  DerivedSchemaAttributeMapper.mapOmrsEntityDetailToDerivedSchemaAttribute(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created DerivedSchemaAttribute="+ createdDerivedSchemaAttribute );
        }
        return createdDerivedSchemaAttribute;
    }
    /**
     * Update derivedSchemaAttribute
     * @param userId user identity
     * @param derivedSchemaAttribute   derivedSchemaAttribute to update
     * @return DerivedSchemaAttribute the updated derivedSchemaAttribute entity
     */
    public DerivedSchemaAttribute updateDerivedSchemaAttribute(String userId, DerivedSchemaAttribute derivedSchemaAttribute)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateDerivedSchemaAttribute";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = DerivedSchemaAttributeMapper.mapDerivedSchemaAttributeToOmrsEntityDetail(derivedSchemaAttribute);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            DerivedSchemaAttribute updatedDerivedSchemaAttribute =  DerivedSchemaAttributeMapper.mapOmrsEntityDetailToDerivedSchemaAttribute(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated DerivedSchemaAttribute="+ updatedDerivedSchemaAttribute );
            }
            return updatedDerivedSchemaAttribute;
        }

    /**
     * Delete an derivedSchemaAttribute identified by its GUID. Delete is a soft delete, this means that the derivedSchemaAttribute has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the derivedSchemaAttribute
     * @return DerivedSchemaAttribute the deleted DerivedSchemaAttribute entity
     */

    public DerivedSchemaAttribute deleteDerivedSchemaAttribute(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteDerivedSchemaAttribute";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DerivedSchemaAttribute type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DerivedSchemaAttribute");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"DerivedSchemaAttribute",entityDef.getGUID(),entityGuid);
         DerivedSchemaAttribute deletedDerivedSchemaAttribute = DerivedSchemaAttributeMapper.mapOmrsEntityDetailToDerivedSchemaAttribute(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedDerivedSchemaAttribute;

    }
    /**
     * Purge an derivedSchemaAttribute identified by its GUID. Delete is a hard delete, this means that the derivedSchemaAttribute is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the derivedSchemaAttribute
     */
    public void purgeDerivedSchemaAttribute(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeDerivedSchemaAttribute";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DerivedSchemaAttribute type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DerivedSchemaAttribute");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"DerivedSchemaAttribute",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an DerivedSchemaAttribute identified by its GUID. Restore resurrects a soft deleted DerivedSchemaAttribute. When a DerivedSchemaAttribute was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the DerivedSchemaAttribute
     * @return  DerivedSchemaAttribute the restored DerivedSchemaAttribute
     */
    public DerivedSchemaAttribute restoreDerivedSchemaAttribute(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreDerivedSchemaAttribute";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        DerivedSchemaAttribute restoredDerivedSchemaAttribute =  DerivedSchemaAttributeMapper.mapOmrsEntityDetailToDerivedSchemaAttribute(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredDerivedSchemaAttribute;
    }    

    /**
     * Add classifications to the supplied derivedSchemaAttribute
     * @param userId user identity
     * @param entityGuid the GUID value for derivedSchemaAttribute
     * @param classifications the classifications to apply.
     * @return the derivedSchemaAttribute entity that has been classified
     */
     public DerivedSchemaAttribute addDerivedSchemaAttributeClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addDerivedSchemaAttributeClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         DerivedSchemaAttribute derivedSchemaAttributeClassificationBeans = DerivedSchemaAttributeMapper.mapOmrsEntityDetailToDerivedSchemaAttribute(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified DerivedSchemaAttribute=" +  derivedSchemaAttributeClassificationBeans);
         }
         return  derivedSchemaAttributeClassificationBeans;
    }

    /**
     * Updates classifications to an existing derivedSchemaAttribute represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the derivedSchemaAttribute
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given derivedSchemaAttribute guid
     */
    public DerivedSchemaAttribute updateDerivedSchemaAttributeClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateDerivedSchemaAttributeClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           DerivedSchemaAttribute  derivedSchemaAttributeClassificationBeans = DerivedSchemaAttributeMapper.mapOmrsEntityDetailToDerivedSchemaAttribute(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  derivedSchemaAttributeClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing derivedSchemaAttribute represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the derivedSchemaAttribute
     * @param name name of the classification
     * @return deleted DerivedSchemaAttribute  classification
     */
    public DerivedSchemaAttribute deleteDerivedSchemaAttributeClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteDerivedSchemaAttributeClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       DerivedSchemaAttribute declassifiedDerivedSchemaAttribute =  DerivedSchemaAttributeMapper.mapOmrsEntityDetailToDerivedSchemaAttribute(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedDerivedSchemaAttribute;
    }

    /**
      * Get the relationships associated with entity derivedSchemaAttribute represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the derivedSchemaAttribute
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getDerivedSchemaAttributeRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getDerivedSchemaAttributeRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an dataClassAnnotation given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the dataClassAnnotations relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return DataClassAnnotation the DataClassAnnotation entity with the requested GUID
     */
    public DataClassAnnotation getDataClassAnnotation(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getDataClassAnnotation";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        DataClassAnnotation gotdataClassAnnotation = DataClassAnnotationMapper.mapOmrsEntityDetailToDataClassAnnotation(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotdataClassAnnotation );
        }
        return gotdataClassAnnotation;

    }
    /**
     * Create new dataClassAnnotation.
     * @param userId user identity
     * @param dataClassAnnotation the input entity with values.
     * @return DataClassAnnotation the created entity.
     */

    public DataClassAnnotation createDataClassAnnotation(String userId,DataClassAnnotation dataClassAnnotation)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createDataClassAnnotation";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = DataClassAnnotationMapper.mapDataClassAnnotationToOmrsEntityDetail(dataClassAnnotation);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        DataClassAnnotation createdDataClassAnnotation =  DataClassAnnotationMapper.mapOmrsEntityDetailToDataClassAnnotation(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created DataClassAnnotation="+ createdDataClassAnnotation );
        }
        return createdDataClassAnnotation;
    }
    /**
     * Update dataClassAnnotation
     * @param userId user identity
     * @param dataClassAnnotation   dataClassAnnotation to update
     * @return DataClassAnnotation the updated dataClassAnnotation entity
     */
    public DataClassAnnotation updateDataClassAnnotation(String userId, DataClassAnnotation dataClassAnnotation)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateDataClassAnnotation";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = DataClassAnnotationMapper.mapDataClassAnnotationToOmrsEntityDetail(dataClassAnnotation);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            DataClassAnnotation updatedDataClassAnnotation =  DataClassAnnotationMapper.mapOmrsEntityDetailToDataClassAnnotation(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated DataClassAnnotation="+ updatedDataClassAnnotation );
            }
            return updatedDataClassAnnotation;
        }

    /**
     * Delete an dataClassAnnotation identified by its GUID. Delete is a soft delete, this means that the dataClassAnnotation has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the dataClassAnnotation
     * @return DataClassAnnotation the deleted DataClassAnnotation entity
     */

    public DataClassAnnotation deleteDataClassAnnotation(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteDataClassAnnotation";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DataClassAnnotation type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DataClassAnnotation");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"DataClassAnnotation",entityDef.getGUID(),entityGuid);
         DataClassAnnotation deletedDataClassAnnotation = DataClassAnnotationMapper.mapOmrsEntityDetailToDataClassAnnotation(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedDataClassAnnotation;

    }
    /**
     * Purge an dataClassAnnotation identified by its GUID. Delete is a hard delete, this means that the dataClassAnnotation is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the dataClassAnnotation
     */
    public void purgeDataClassAnnotation(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeDataClassAnnotation";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DataClassAnnotation type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DataClassAnnotation");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"DataClassAnnotation",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an DataClassAnnotation identified by its GUID. Restore resurrects a soft deleted DataClassAnnotation. When a DataClassAnnotation was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the DataClassAnnotation
     * @return  DataClassAnnotation the restored DataClassAnnotation
     */
    public DataClassAnnotation restoreDataClassAnnotation(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreDataClassAnnotation";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        DataClassAnnotation restoredDataClassAnnotation =  DataClassAnnotationMapper.mapOmrsEntityDetailToDataClassAnnotation(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredDataClassAnnotation;
    }    

    /**
     * Add classifications to the supplied dataClassAnnotation
     * @param userId user identity
     * @param entityGuid the GUID value for dataClassAnnotation
     * @param classifications the classifications to apply.
     * @return the dataClassAnnotation entity that has been classified
     */
     public DataClassAnnotation addDataClassAnnotationClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addDataClassAnnotationClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         DataClassAnnotation dataClassAnnotationClassificationBeans = DataClassAnnotationMapper.mapOmrsEntityDetailToDataClassAnnotation(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified DataClassAnnotation=" +  dataClassAnnotationClassificationBeans);
         }
         return  dataClassAnnotationClassificationBeans;
    }

    /**
     * Updates classifications to an existing dataClassAnnotation represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the dataClassAnnotation
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given dataClassAnnotation guid
     */
    public DataClassAnnotation updateDataClassAnnotationClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateDataClassAnnotationClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           DataClassAnnotation  dataClassAnnotationClassificationBeans = DataClassAnnotationMapper.mapOmrsEntityDetailToDataClassAnnotation(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  dataClassAnnotationClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing dataClassAnnotation represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the dataClassAnnotation
     * @param name name of the classification
     * @return deleted DataClassAnnotation  classification
     */
    public DataClassAnnotation deleteDataClassAnnotationClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteDataClassAnnotationClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       DataClassAnnotation declassifiedDataClassAnnotation =  DataClassAnnotationMapper.mapOmrsEntityDetailToDataClassAnnotation(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedDataClassAnnotation;
    }

    /**
      * Get the relationships associated with entity dataClassAnnotation represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the dataClassAnnotation
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getDataClassAnnotationRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getDataClassAnnotationRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an relationalTableType given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the relationalTableTypes relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return RelationalTableType the RelationalTableType entity with the requested GUID
     */
    public RelationalTableType getRelationalTableType(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getRelationalTableType";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        RelationalTableType gotrelationalTableType = RelationalTableTypeMapper.mapOmrsEntityDetailToRelationalTableType(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotrelationalTableType );
        }
        return gotrelationalTableType;

    }
    /**
     * Create new relationalTableType.
     * @param userId user identity
     * @param relationalTableType the input entity with values.
     * @return RelationalTableType the created entity.
     */

    public RelationalTableType createRelationalTableType(String userId,RelationalTableType relationalTableType)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createRelationalTableType";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = RelationalTableTypeMapper.mapRelationalTableTypeToOmrsEntityDetail(relationalTableType);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        RelationalTableType createdRelationalTableType =  RelationalTableTypeMapper.mapOmrsEntityDetailToRelationalTableType(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created RelationalTableType="+ createdRelationalTableType );
        }
        return createdRelationalTableType;
    }
    /**
     * Update relationalTableType
     * @param userId user identity
     * @param relationalTableType   relationalTableType to update
     * @return RelationalTableType the updated relationalTableType entity
     */
    public RelationalTableType updateRelationalTableType(String userId, RelationalTableType relationalTableType)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateRelationalTableType";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = RelationalTableTypeMapper.mapRelationalTableTypeToOmrsEntityDetail(relationalTableType);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            RelationalTableType updatedRelationalTableType =  RelationalTableTypeMapper.mapOmrsEntityDetailToRelationalTableType(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated RelationalTableType="+ updatedRelationalTableType );
            }
            return updatedRelationalTableType;
        }

    /**
     * Delete an relationalTableType identified by its GUID. Delete is a soft delete, this means that the relationalTableType has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the relationalTableType
     * @return RelationalTableType the deleted RelationalTableType entity
     */

    public RelationalTableType deleteRelationalTableType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteRelationalTableType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the RelationalTableType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("RelationalTableType");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"RelationalTableType",entityDef.getGUID(),entityGuid);
         RelationalTableType deletedRelationalTableType = RelationalTableTypeMapper.mapOmrsEntityDetailToRelationalTableType(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedRelationalTableType;

    }
    /**
     * Purge an relationalTableType identified by its GUID. Delete is a hard delete, this means that the relationalTableType is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the relationalTableType
     */
    public void purgeRelationalTableType(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeRelationalTableType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the RelationalTableType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("RelationalTableType");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"RelationalTableType",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an RelationalTableType identified by its GUID. Restore resurrects a soft deleted RelationalTableType. When a RelationalTableType was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the RelationalTableType
     * @return  RelationalTableType the restored RelationalTableType
     */
    public RelationalTableType restoreRelationalTableType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreRelationalTableType";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        RelationalTableType restoredRelationalTableType =  RelationalTableTypeMapper.mapOmrsEntityDetailToRelationalTableType(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredRelationalTableType;
    }    

    /**
     * Add classifications to the supplied relationalTableType
     * @param userId user identity
     * @param entityGuid the GUID value for relationalTableType
     * @param classifications the classifications to apply.
     * @return the relationalTableType entity that has been classified
     */
     public RelationalTableType addRelationalTableTypeClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addRelationalTableTypeClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         RelationalTableType relationalTableTypeClassificationBeans = RelationalTableTypeMapper.mapOmrsEntityDetailToRelationalTableType(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified RelationalTableType=" +  relationalTableTypeClassificationBeans);
         }
         return  relationalTableTypeClassificationBeans;
    }

    /**
     * Updates classifications to an existing relationalTableType represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the relationalTableType
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given relationalTableType guid
     */
    public RelationalTableType updateRelationalTableTypeClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateRelationalTableTypeClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           RelationalTableType  relationalTableTypeClassificationBeans = RelationalTableTypeMapper.mapOmrsEntityDetailToRelationalTableType(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  relationalTableTypeClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing relationalTableType represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the relationalTableType
     * @param name name of the classification
     * @return deleted RelationalTableType  classification
     */
    public RelationalTableType deleteRelationalTableTypeClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteRelationalTableTypeClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       RelationalTableType declassifiedRelationalTableType =  RelationalTableTypeMapper.mapOmrsEntityDetailToRelationalTableType(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedRelationalTableType;
    }

    /**
      * Get the relationships associated with entity relationalTableType represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the relationalTableType
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getRelationalTableTypeRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getRelationalTableTypeRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an process given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the processes relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return Process the Process entity with the requested GUID
     */
    public Process getProcess(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getProcess";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        Process gotprocess = ProcessMapper.mapOmrsEntityDetailToProcess(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotprocess );
        }
        return gotprocess;

    }
    /**
     * Create new process.
     * @param userId user identity
     * @param process the input entity with values.
     * @return Process the created entity.
     */

    public Process createProcess(String userId,Process process)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createProcess";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = ProcessMapper.mapProcessToOmrsEntityDetail(process);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        Process createdProcess =  ProcessMapper.mapOmrsEntityDetailToProcess(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created Process="+ createdProcess );
        }
        return createdProcess;
    }
    /**
     * Update process
     * @param userId user identity
     * @param process   process to update
     * @return Process the updated process entity
     */
    public Process updateProcess(String userId, Process process)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateProcess";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = ProcessMapper.mapProcessToOmrsEntityDetail(process);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            Process updatedProcess =  ProcessMapper.mapOmrsEntityDetailToProcess(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated Process="+ updatedProcess );
            }
            return updatedProcess;
        }

    /**
     * Delete an process identified by its GUID. Delete is a soft delete, this means that the process has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the process
     * @return Process the deleted Process entity
     */

    public Process deleteProcess(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteProcess";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Process type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Process");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"Process",entityDef.getGUID(),entityGuid);
         Process deletedProcess = ProcessMapper.mapOmrsEntityDetailToProcess(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedProcess;

    }
    /**
     * Purge an process identified by its GUID. Delete is a hard delete, this means that the process is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the process
     */
    public void purgeProcess(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeProcess";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Process type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Process");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"Process",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an Process identified by its GUID. Restore resurrects a soft deleted Process. When a Process was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the Process
     * @return  Process the restored Process
     */
    public Process restoreProcess(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreProcess";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        Process restoredProcess =  ProcessMapper.mapOmrsEntityDetailToProcess(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredProcess;
    }    

    /**
     * Add classifications to the supplied process
     * @param userId user identity
     * @param entityGuid the GUID value for process
     * @param classifications the classifications to apply.
     * @return the process entity that has been classified
     */
     public Process addProcessClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addProcessClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         Process processClassificationBeans = ProcessMapper.mapOmrsEntityDetailToProcess(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified Process=" +  processClassificationBeans);
         }
         return  processClassificationBeans;
    }

    /**
     * Updates classifications to an existing process represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the process
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given process guid
     */
    public Process updateProcessClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateProcessClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           Process  processClassificationBeans = ProcessMapper.mapOmrsEntityDetailToProcess(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  processClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing process represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the process
     * @param name name of the classification
     * @return deleted Process  classification
     */
    public Process deleteProcessClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteProcessClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       Process declassifiedProcess =  ProcessMapper.mapOmrsEntityDetailToProcess(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedProcess;
    }

    /**
      * Get the relationships associated with entity process represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the process
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getProcessRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getProcessRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an schemaType given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the schemaTypes relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return SchemaType the SchemaType entity with the requested GUID
     */
    public SchemaType getSchemaType(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getSchemaType";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        SchemaType gotschemaType = SchemaTypeMapper.mapOmrsEntityDetailToSchemaType(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotschemaType );
        }
        return gotschemaType;

    }
    /**
     * Create new schemaType.
     * @param userId user identity
     * @param schemaType the input entity with values.
     * @return SchemaType the created entity.
     */

    public SchemaType createSchemaType(String userId,SchemaType schemaType)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createSchemaType";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = SchemaTypeMapper.mapSchemaTypeToOmrsEntityDetail(schemaType);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        SchemaType createdSchemaType =  SchemaTypeMapper.mapOmrsEntityDetailToSchemaType(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created SchemaType="+ createdSchemaType );
        }
        return createdSchemaType;
    }
    /**
     * Update schemaType
     * @param userId user identity
     * @param schemaType   schemaType to update
     * @return SchemaType the updated schemaType entity
     */
    public SchemaType updateSchemaType(String userId, SchemaType schemaType)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateSchemaType";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = SchemaTypeMapper.mapSchemaTypeToOmrsEntityDetail(schemaType);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            SchemaType updatedSchemaType =  SchemaTypeMapper.mapOmrsEntityDetailToSchemaType(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated SchemaType="+ updatedSchemaType );
            }
            return updatedSchemaType;
        }

    /**
     * Delete an schemaType identified by its GUID. Delete is a soft delete, this means that the schemaType has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the schemaType
     * @return SchemaType the deleted SchemaType entity
     */

    public SchemaType deleteSchemaType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteSchemaType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the SchemaType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("SchemaType");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"SchemaType",entityDef.getGUID(),entityGuid);
         SchemaType deletedSchemaType = SchemaTypeMapper.mapOmrsEntityDetailToSchemaType(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedSchemaType;

    }
    /**
     * Purge an schemaType identified by its GUID. Delete is a hard delete, this means that the schemaType is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the schemaType
     */
    public void purgeSchemaType(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeSchemaType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the SchemaType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("SchemaType");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"SchemaType",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an SchemaType identified by its GUID. Restore resurrects a soft deleted SchemaType. When a SchemaType was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the SchemaType
     * @return  SchemaType the restored SchemaType
     */
    public SchemaType restoreSchemaType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreSchemaType";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        SchemaType restoredSchemaType =  SchemaTypeMapper.mapOmrsEntityDetailToSchemaType(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredSchemaType;
    }    

    /**
     * Add classifications to the supplied schemaType
     * @param userId user identity
     * @param entityGuid the GUID value for schemaType
     * @param classifications the classifications to apply.
     * @return the schemaType entity that has been classified
     */
     public SchemaType addSchemaTypeClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addSchemaTypeClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         SchemaType schemaTypeClassificationBeans = SchemaTypeMapper.mapOmrsEntityDetailToSchemaType(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified SchemaType=" +  schemaTypeClassificationBeans);
         }
         return  schemaTypeClassificationBeans;
    }

    /**
     * Updates classifications to an existing schemaType represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the schemaType
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given schemaType guid
     */
    public SchemaType updateSchemaTypeClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateSchemaTypeClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           SchemaType  schemaTypeClassificationBeans = SchemaTypeMapper.mapOmrsEntityDetailToSchemaType(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  schemaTypeClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing schemaType represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the schemaType
     * @param name name of the classification
     * @return deleted SchemaType  classification
     */
    public SchemaType deleteSchemaTypeClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteSchemaTypeClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       SchemaType declassifiedSchemaType =  SchemaTypeMapper.mapOmrsEntityDetailToSchemaType(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedSchemaType;
    }

    /**
      * Get the relationships associated with entity schemaType represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the schemaType
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getSchemaTypeRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getSchemaTypeRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an openDiscoveryService given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the openDiscoveryServices relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return OpenDiscoveryService the OpenDiscoveryService entity with the requested GUID
     */
    public OpenDiscoveryService getOpenDiscoveryService(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getOpenDiscoveryService";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        OpenDiscoveryService gotopenDiscoveryService = OpenDiscoveryServiceMapper.mapOmrsEntityDetailToOpenDiscoveryService(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotopenDiscoveryService );
        }
        return gotopenDiscoveryService;

    }
    /**
     * Create new openDiscoveryService.
     * @param userId user identity
     * @param openDiscoveryService the input entity with values.
     * @return OpenDiscoveryService the created entity.
     */

    public OpenDiscoveryService createOpenDiscoveryService(String userId,OpenDiscoveryService openDiscoveryService)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createOpenDiscoveryService";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = OpenDiscoveryServiceMapper.mapOpenDiscoveryServiceToOmrsEntityDetail(openDiscoveryService);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        OpenDiscoveryService createdOpenDiscoveryService =  OpenDiscoveryServiceMapper.mapOmrsEntityDetailToOpenDiscoveryService(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created OpenDiscoveryService="+ createdOpenDiscoveryService );
        }
        return createdOpenDiscoveryService;
    }
    /**
     * Update openDiscoveryService
     * @param userId user identity
     * @param openDiscoveryService   openDiscoveryService to update
     * @return OpenDiscoveryService the updated openDiscoveryService entity
     */
    public OpenDiscoveryService updateOpenDiscoveryService(String userId, OpenDiscoveryService openDiscoveryService)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateOpenDiscoveryService";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = OpenDiscoveryServiceMapper.mapOpenDiscoveryServiceToOmrsEntityDetail(openDiscoveryService);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            OpenDiscoveryService updatedOpenDiscoveryService =  OpenDiscoveryServiceMapper.mapOmrsEntityDetailToOpenDiscoveryService(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated OpenDiscoveryService="+ updatedOpenDiscoveryService );
            }
            return updatedOpenDiscoveryService;
        }

    /**
     * Delete an openDiscoveryService identified by its GUID. Delete is a soft delete, this means that the openDiscoveryService has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the openDiscoveryService
     * @return OpenDiscoveryService the deleted OpenDiscoveryService entity
     */

    public OpenDiscoveryService deleteOpenDiscoveryService(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteOpenDiscoveryService";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the OpenDiscoveryService type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("OpenDiscoveryService");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"OpenDiscoveryService",entityDef.getGUID(),entityGuid);
         OpenDiscoveryService deletedOpenDiscoveryService = OpenDiscoveryServiceMapper.mapOmrsEntityDetailToOpenDiscoveryService(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedOpenDiscoveryService;

    }
    /**
     * Purge an openDiscoveryService identified by its GUID. Delete is a hard delete, this means that the openDiscoveryService is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the openDiscoveryService
     */
    public void purgeOpenDiscoveryService(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeOpenDiscoveryService";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the OpenDiscoveryService type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("OpenDiscoveryService");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"OpenDiscoveryService",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an OpenDiscoveryService identified by its GUID. Restore resurrects a soft deleted OpenDiscoveryService. When a OpenDiscoveryService was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the OpenDiscoveryService
     * @return  OpenDiscoveryService the restored OpenDiscoveryService
     */
    public OpenDiscoveryService restoreOpenDiscoveryService(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreOpenDiscoveryService";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        OpenDiscoveryService restoredOpenDiscoveryService =  OpenDiscoveryServiceMapper.mapOmrsEntityDetailToOpenDiscoveryService(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredOpenDiscoveryService;
    }    

    /**
     * Add classifications to the supplied openDiscoveryService
     * @param userId user identity
     * @param entityGuid the GUID value for openDiscoveryService
     * @param classifications the classifications to apply.
     * @return the openDiscoveryService entity that has been classified
     */
     public OpenDiscoveryService addOpenDiscoveryServiceClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addOpenDiscoveryServiceClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         OpenDiscoveryService openDiscoveryServiceClassificationBeans = OpenDiscoveryServiceMapper.mapOmrsEntityDetailToOpenDiscoveryService(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified OpenDiscoveryService=" +  openDiscoveryServiceClassificationBeans);
         }
         return  openDiscoveryServiceClassificationBeans;
    }

    /**
     * Updates classifications to an existing openDiscoveryService represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the openDiscoveryService
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given openDiscoveryService guid
     */
    public OpenDiscoveryService updateOpenDiscoveryServiceClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateOpenDiscoveryServiceClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           OpenDiscoveryService  openDiscoveryServiceClassificationBeans = OpenDiscoveryServiceMapper.mapOmrsEntityDetailToOpenDiscoveryService(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  openDiscoveryServiceClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing openDiscoveryService represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the openDiscoveryService
     * @param name name of the classification
     * @return deleted OpenDiscoveryService  classification
     */
    public OpenDiscoveryService deleteOpenDiscoveryServiceClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteOpenDiscoveryServiceClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       OpenDiscoveryService declassifiedOpenDiscoveryService =  OpenDiscoveryServiceMapper.mapOmrsEntityDetailToOpenDiscoveryService(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedOpenDiscoveryService;
    }

    /**
      * Get the relationships associated with entity openDiscoveryService represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the openDiscoveryService
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getOpenDiscoveryServiceRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getOpenDiscoveryServiceRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an like given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the likes relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return Like the Like entity with the requested GUID
     */
    public Like getLike(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getLike";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        Like gotlike = LikeMapper.mapOmrsEntityDetailToLike(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotlike );
        }
        return gotlike;

    }
    /**
     * Create new like.
     * @param userId user identity
     * @param like the input entity with values.
     * @return Like the created entity.
     */

    public Like createLike(String userId,Like like)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createLike";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = LikeMapper.mapLikeToOmrsEntityDetail(like);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        Like createdLike =  LikeMapper.mapOmrsEntityDetailToLike(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created Like="+ createdLike );
        }
        return createdLike;
    }
    /**
     * Update like
     * @param userId user identity
     * @param like   like to update
     * @return Like the updated like entity
     */
    public Like updateLike(String userId, Like like)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateLike";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = LikeMapper.mapLikeToOmrsEntityDetail(like);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            Like updatedLike =  LikeMapper.mapOmrsEntityDetailToLike(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated Like="+ updatedLike );
            }
            return updatedLike;
        }

    /**
     * Delete an like identified by its GUID. Delete is a soft delete, this means that the like has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the like
     * @return Like the deleted Like entity
     */

    public Like deleteLike(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteLike";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Like type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Like");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"Like",entityDef.getGUID(),entityGuid);
         Like deletedLike = LikeMapper.mapOmrsEntityDetailToLike(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedLike;

    }
    /**
     * Purge an like identified by its GUID. Delete is a hard delete, this means that the like is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the like
     */
    public void purgeLike(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeLike";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Like type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Like");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"Like",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an Like identified by its GUID. Restore resurrects a soft deleted Like. When a Like was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the Like
     * @return  Like the restored Like
     */
    public Like restoreLike(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreLike";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        Like restoredLike =  LikeMapper.mapOmrsEntityDetailToLike(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredLike;
    }    

    /**
     * Add classifications to the supplied like
     * @param userId user identity
     * @param entityGuid the GUID value for like
     * @param classifications the classifications to apply.
     * @return the like entity that has been classified
     */
     public Like addLikeClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addLikeClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         Like likeClassificationBeans = LikeMapper.mapOmrsEntityDetailToLike(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified Like=" +  likeClassificationBeans);
         }
         return  likeClassificationBeans;
    }

    /**
     * Updates classifications to an existing like represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the like
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given like guid
     */
    public Like updateLikeClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateLikeClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           Like  likeClassificationBeans = LikeMapper.mapOmrsEntityDetailToLike(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  likeClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing like represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the like
     * @param name name of the classification
     * @return deleted Like  classification
     */
    public Like deleteLikeClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteLikeClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       Like declassifiedLike =  LikeMapper.mapOmrsEntityDetailToLike(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedLike;
    }

    /**
      * Get the relationships associated with entity like represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the like
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getLikeRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getLikeRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an tabularColumnType given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the tabularColumnTypes relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return TabularColumnType the TabularColumnType entity with the requested GUID
     */
    public TabularColumnType getTabularColumnType(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getTabularColumnType";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        TabularColumnType gottabularColumnType = TabularColumnTypeMapper.mapOmrsEntityDetailToTabularColumnType(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gottabularColumnType );
        }
        return gottabularColumnType;

    }
    /**
     * Create new tabularColumnType.
     * @param userId user identity
     * @param tabularColumnType the input entity with values.
     * @return TabularColumnType the created entity.
     */

    public TabularColumnType createTabularColumnType(String userId,TabularColumnType tabularColumnType)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createTabularColumnType";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = TabularColumnTypeMapper.mapTabularColumnTypeToOmrsEntityDetail(tabularColumnType);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        TabularColumnType createdTabularColumnType =  TabularColumnTypeMapper.mapOmrsEntityDetailToTabularColumnType(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created TabularColumnType="+ createdTabularColumnType );
        }
        return createdTabularColumnType;
    }
    /**
     * Update tabularColumnType
     * @param userId user identity
     * @param tabularColumnType   tabularColumnType to update
     * @return TabularColumnType the updated tabularColumnType entity
     */
    public TabularColumnType updateTabularColumnType(String userId, TabularColumnType tabularColumnType)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateTabularColumnType";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = TabularColumnTypeMapper.mapTabularColumnTypeToOmrsEntityDetail(tabularColumnType);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            TabularColumnType updatedTabularColumnType =  TabularColumnTypeMapper.mapOmrsEntityDetailToTabularColumnType(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated TabularColumnType="+ updatedTabularColumnType );
            }
            return updatedTabularColumnType;
        }

    /**
     * Delete an tabularColumnType identified by its GUID. Delete is a soft delete, this means that the tabularColumnType has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the tabularColumnType
     * @return TabularColumnType the deleted TabularColumnType entity
     */

    public TabularColumnType deleteTabularColumnType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteTabularColumnType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the TabularColumnType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("TabularColumnType");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"TabularColumnType",entityDef.getGUID(),entityGuid);
         TabularColumnType deletedTabularColumnType = TabularColumnTypeMapper.mapOmrsEntityDetailToTabularColumnType(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedTabularColumnType;

    }
    /**
     * Purge an tabularColumnType identified by its GUID. Delete is a hard delete, this means that the tabularColumnType is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the tabularColumnType
     */
    public void purgeTabularColumnType(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeTabularColumnType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the TabularColumnType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("TabularColumnType");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"TabularColumnType",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an TabularColumnType identified by its GUID. Restore resurrects a soft deleted TabularColumnType. When a TabularColumnType was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the TabularColumnType
     * @return  TabularColumnType the restored TabularColumnType
     */
    public TabularColumnType restoreTabularColumnType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreTabularColumnType";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        TabularColumnType restoredTabularColumnType =  TabularColumnTypeMapper.mapOmrsEntityDetailToTabularColumnType(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredTabularColumnType;
    }    

    /**
     * Add classifications to the supplied tabularColumnType
     * @param userId user identity
     * @param entityGuid the GUID value for tabularColumnType
     * @param classifications the classifications to apply.
     * @return the tabularColumnType entity that has been classified
     */
     public TabularColumnType addTabularColumnTypeClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addTabularColumnTypeClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         TabularColumnType tabularColumnTypeClassificationBeans = TabularColumnTypeMapper.mapOmrsEntityDetailToTabularColumnType(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified TabularColumnType=" +  tabularColumnTypeClassificationBeans);
         }
         return  tabularColumnTypeClassificationBeans;
    }

    /**
     * Updates classifications to an existing tabularColumnType represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the tabularColumnType
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given tabularColumnType guid
     */
    public TabularColumnType updateTabularColumnTypeClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateTabularColumnTypeClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           TabularColumnType  tabularColumnTypeClassificationBeans = TabularColumnTypeMapper.mapOmrsEntityDetailToTabularColumnType(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  tabularColumnTypeClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing tabularColumnType represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the tabularColumnType
     * @param name name of the classification
     * @return deleted TabularColumnType  classification
     */
    public TabularColumnType deleteTabularColumnTypeClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteTabularColumnTypeClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       TabularColumnType declassifiedTabularColumnType =  TabularColumnTypeMapper.mapOmrsEntityDetailToTabularColumnType(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedTabularColumnType;
    }

    /**
      * Get the relationships associated with entity tabularColumnType represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the tabularColumnType
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getTabularColumnTypeRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getTabularColumnTypeRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an fileFolder given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the fileFolders relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return FileFolder the FileFolder entity with the requested GUID
     */
    public FileFolder getFileFolder(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getFileFolder";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        FileFolder gotfileFolder = FileFolderMapper.mapOmrsEntityDetailToFileFolder(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotfileFolder );
        }
        return gotfileFolder;

    }
    /**
     * Create new fileFolder.
     * @param userId user identity
     * @param fileFolder the input entity with values.
     * @return FileFolder the created entity.
     */

    public FileFolder createFileFolder(String userId,FileFolder fileFolder)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createFileFolder";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = FileFolderMapper.mapFileFolderToOmrsEntityDetail(fileFolder);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        FileFolder createdFileFolder =  FileFolderMapper.mapOmrsEntityDetailToFileFolder(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created FileFolder="+ createdFileFolder );
        }
        return createdFileFolder;
    }
    /**
     * Update fileFolder
     * @param userId user identity
     * @param fileFolder   fileFolder to update
     * @return FileFolder the updated fileFolder entity
     */
    public FileFolder updateFileFolder(String userId, FileFolder fileFolder)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateFileFolder";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = FileFolderMapper.mapFileFolderToOmrsEntityDetail(fileFolder);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            FileFolder updatedFileFolder =  FileFolderMapper.mapOmrsEntityDetailToFileFolder(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated FileFolder="+ updatedFileFolder );
            }
            return updatedFileFolder;
        }

    /**
     * Delete an fileFolder identified by its GUID. Delete is a soft delete, this means that the fileFolder has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the fileFolder
     * @return FileFolder the deleted FileFolder entity
     */

    public FileFolder deleteFileFolder(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteFileFolder";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the FileFolder type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("FileFolder");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"FileFolder",entityDef.getGUID(),entityGuid);
         FileFolder deletedFileFolder = FileFolderMapper.mapOmrsEntityDetailToFileFolder(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedFileFolder;

    }
    /**
     * Purge an fileFolder identified by its GUID. Delete is a hard delete, this means that the fileFolder is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the fileFolder
     */
    public void purgeFileFolder(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeFileFolder";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the FileFolder type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("FileFolder");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"FileFolder",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an FileFolder identified by its GUID. Restore resurrects a soft deleted FileFolder. When a FileFolder was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the FileFolder
     * @return  FileFolder the restored FileFolder
     */
    public FileFolder restoreFileFolder(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreFileFolder";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        FileFolder restoredFileFolder =  FileFolderMapper.mapOmrsEntityDetailToFileFolder(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredFileFolder;
    }    

    /**
     * Add classifications to the supplied fileFolder
     * @param userId user identity
     * @param entityGuid the GUID value for fileFolder
     * @param classifications the classifications to apply.
     * @return the fileFolder entity that has been classified
     */
     public FileFolder addFileFolderClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addFileFolderClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         FileFolder fileFolderClassificationBeans = FileFolderMapper.mapOmrsEntityDetailToFileFolder(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified FileFolder=" +  fileFolderClassificationBeans);
         }
         return  fileFolderClassificationBeans;
    }

    /**
     * Updates classifications to an existing fileFolder represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the fileFolder
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given fileFolder guid
     */
    public FileFolder updateFileFolderClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateFileFolderClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           FileFolder  fileFolderClassificationBeans = FileFolderMapper.mapOmrsEntityDetailToFileFolder(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  fileFolderClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing fileFolder represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the fileFolder
     * @param name name of the classification
     * @return deleted FileFolder  classification
     */
    public FileFolder deleteFileFolderClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteFileFolderClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       FileFolder declassifiedFileFolder =  FileFolderMapper.mapOmrsEntityDetailToFileFolder(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedFileFolder;
    }

    /**
      * Get the relationships associated with entity fileFolder represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the fileFolder
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getFileFolderRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getFileFolderRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an structSchemaType given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the structSchemaTypes relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return StructSchemaType the StructSchemaType entity with the requested GUID
     */
    public StructSchemaType getStructSchemaType(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getStructSchemaType";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        StructSchemaType gotstructSchemaType = StructSchemaTypeMapper.mapOmrsEntityDetailToStructSchemaType(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotstructSchemaType );
        }
        return gotstructSchemaType;

    }
    /**
     * Create new structSchemaType.
     * @param userId user identity
     * @param structSchemaType the input entity with values.
     * @return StructSchemaType the created entity.
     */

    public StructSchemaType createStructSchemaType(String userId,StructSchemaType structSchemaType)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createStructSchemaType";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = StructSchemaTypeMapper.mapStructSchemaTypeToOmrsEntityDetail(structSchemaType);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        StructSchemaType createdStructSchemaType =  StructSchemaTypeMapper.mapOmrsEntityDetailToStructSchemaType(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created StructSchemaType="+ createdStructSchemaType );
        }
        return createdStructSchemaType;
    }
    /**
     * Update structSchemaType
     * @param userId user identity
     * @param structSchemaType   structSchemaType to update
     * @return StructSchemaType the updated structSchemaType entity
     */
    public StructSchemaType updateStructSchemaType(String userId, StructSchemaType structSchemaType)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateStructSchemaType";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = StructSchemaTypeMapper.mapStructSchemaTypeToOmrsEntityDetail(structSchemaType);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            StructSchemaType updatedStructSchemaType =  StructSchemaTypeMapper.mapOmrsEntityDetailToStructSchemaType(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated StructSchemaType="+ updatedStructSchemaType );
            }
            return updatedStructSchemaType;
        }

    /**
     * Delete an structSchemaType identified by its GUID. Delete is a soft delete, this means that the structSchemaType has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the structSchemaType
     * @return StructSchemaType the deleted StructSchemaType entity
     */

    public StructSchemaType deleteStructSchemaType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteStructSchemaType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the StructSchemaType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("StructSchemaType");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"StructSchemaType",entityDef.getGUID(),entityGuid);
         StructSchemaType deletedStructSchemaType = StructSchemaTypeMapper.mapOmrsEntityDetailToStructSchemaType(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedStructSchemaType;

    }
    /**
     * Purge an structSchemaType identified by its GUID. Delete is a hard delete, this means that the structSchemaType is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the structSchemaType
     */
    public void purgeStructSchemaType(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeStructSchemaType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the StructSchemaType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("StructSchemaType");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"StructSchemaType",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an StructSchemaType identified by its GUID. Restore resurrects a soft deleted StructSchemaType. When a StructSchemaType was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the StructSchemaType
     * @return  StructSchemaType the restored StructSchemaType
     */
    public StructSchemaType restoreStructSchemaType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreStructSchemaType";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        StructSchemaType restoredStructSchemaType =  StructSchemaTypeMapper.mapOmrsEntityDetailToStructSchemaType(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredStructSchemaType;
    }    

    /**
     * Add classifications to the supplied structSchemaType
     * @param userId user identity
     * @param entityGuid the GUID value for structSchemaType
     * @param classifications the classifications to apply.
     * @return the structSchemaType entity that has been classified
     */
     public StructSchemaType addStructSchemaTypeClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addStructSchemaTypeClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         StructSchemaType structSchemaTypeClassificationBeans = StructSchemaTypeMapper.mapOmrsEntityDetailToStructSchemaType(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified StructSchemaType=" +  structSchemaTypeClassificationBeans);
         }
         return  structSchemaTypeClassificationBeans;
    }

    /**
     * Updates classifications to an existing structSchemaType represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the structSchemaType
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given structSchemaType guid
     */
    public StructSchemaType updateStructSchemaTypeClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateStructSchemaTypeClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           StructSchemaType  structSchemaTypeClassificationBeans = StructSchemaTypeMapper.mapOmrsEntityDetailToStructSchemaType(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  structSchemaTypeClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing structSchemaType represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the structSchemaType
     * @param name name of the classification
     * @return deleted StructSchemaType  classification
     */
    public StructSchemaType deleteStructSchemaTypeClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteStructSchemaTypeClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       StructSchemaType declassifiedStructSchemaType =  StructSchemaTypeMapper.mapOmrsEntityDetailToStructSchemaType(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedStructSchemaType;
    }

    /**
      * Get the relationships associated with entity structSchemaType represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the structSchemaType
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getStructSchemaTypeRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getStructSchemaTypeRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an boundedSchemaType given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the boundedSchemaTypes relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return BoundedSchemaType the BoundedSchemaType entity with the requested GUID
     */
    public BoundedSchemaType getBoundedSchemaType(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getBoundedSchemaType";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        BoundedSchemaType gotboundedSchemaType = BoundedSchemaTypeMapper.mapOmrsEntityDetailToBoundedSchemaType(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotboundedSchemaType );
        }
        return gotboundedSchemaType;

    }
    /**
     * Create new boundedSchemaType.
     * @param userId user identity
     * @param boundedSchemaType the input entity with values.
     * @return BoundedSchemaType the created entity.
     */

    public BoundedSchemaType createBoundedSchemaType(String userId,BoundedSchemaType boundedSchemaType)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createBoundedSchemaType";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = BoundedSchemaTypeMapper.mapBoundedSchemaTypeToOmrsEntityDetail(boundedSchemaType);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        BoundedSchemaType createdBoundedSchemaType =  BoundedSchemaTypeMapper.mapOmrsEntityDetailToBoundedSchemaType(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created BoundedSchemaType="+ createdBoundedSchemaType );
        }
        return createdBoundedSchemaType;
    }
    /**
     * Update boundedSchemaType
     * @param userId user identity
     * @param boundedSchemaType   boundedSchemaType to update
     * @return BoundedSchemaType the updated boundedSchemaType entity
     */
    public BoundedSchemaType updateBoundedSchemaType(String userId, BoundedSchemaType boundedSchemaType)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateBoundedSchemaType";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = BoundedSchemaTypeMapper.mapBoundedSchemaTypeToOmrsEntityDetail(boundedSchemaType);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            BoundedSchemaType updatedBoundedSchemaType =  BoundedSchemaTypeMapper.mapOmrsEntityDetailToBoundedSchemaType(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated BoundedSchemaType="+ updatedBoundedSchemaType );
            }
            return updatedBoundedSchemaType;
        }

    /**
     * Delete an boundedSchemaType identified by its GUID. Delete is a soft delete, this means that the boundedSchemaType has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the boundedSchemaType
     * @return BoundedSchemaType the deleted BoundedSchemaType entity
     */

    public BoundedSchemaType deleteBoundedSchemaType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteBoundedSchemaType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the BoundedSchemaType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("BoundedSchemaType");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"BoundedSchemaType",entityDef.getGUID(),entityGuid);
         BoundedSchemaType deletedBoundedSchemaType = BoundedSchemaTypeMapper.mapOmrsEntityDetailToBoundedSchemaType(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedBoundedSchemaType;

    }
    /**
     * Purge an boundedSchemaType identified by its GUID. Delete is a hard delete, this means that the boundedSchemaType is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the boundedSchemaType
     */
    public void purgeBoundedSchemaType(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeBoundedSchemaType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the BoundedSchemaType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("BoundedSchemaType");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"BoundedSchemaType",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an BoundedSchemaType identified by its GUID. Restore resurrects a soft deleted BoundedSchemaType. When a BoundedSchemaType was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the BoundedSchemaType
     * @return  BoundedSchemaType the restored BoundedSchemaType
     */
    public BoundedSchemaType restoreBoundedSchemaType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreBoundedSchemaType";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        BoundedSchemaType restoredBoundedSchemaType =  BoundedSchemaTypeMapper.mapOmrsEntityDetailToBoundedSchemaType(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredBoundedSchemaType;
    }    

    /**
     * Add classifications to the supplied boundedSchemaType
     * @param userId user identity
     * @param entityGuid the GUID value for boundedSchemaType
     * @param classifications the classifications to apply.
     * @return the boundedSchemaType entity that has been classified
     */
     public BoundedSchemaType addBoundedSchemaTypeClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addBoundedSchemaTypeClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         BoundedSchemaType boundedSchemaTypeClassificationBeans = BoundedSchemaTypeMapper.mapOmrsEntityDetailToBoundedSchemaType(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified BoundedSchemaType=" +  boundedSchemaTypeClassificationBeans);
         }
         return  boundedSchemaTypeClassificationBeans;
    }

    /**
     * Updates classifications to an existing boundedSchemaType represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the boundedSchemaType
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given boundedSchemaType guid
     */
    public BoundedSchemaType updateBoundedSchemaTypeClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateBoundedSchemaTypeClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           BoundedSchemaType  boundedSchemaTypeClassificationBeans = BoundedSchemaTypeMapper.mapOmrsEntityDetailToBoundedSchemaType(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  boundedSchemaTypeClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing boundedSchemaType represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the boundedSchemaType
     * @param name name of the classification
     * @return deleted BoundedSchemaType  classification
     */
    public BoundedSchemaType deleteBoundedSchemaTypeClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteBoundedSchemaTypeClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       BoundedSchemaType declassifiedBoundedSchemaType =  BoundedSchemaTypeMapper.mapOmrsEntityDetailToBoundedSchemaType(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedBoundedSchemaType;
    }

    /**
      * Get the relationships associated with entity boundedSchemaType represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the boundedSchemaType
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getBoundedSchemaTypeRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getBoundedSchemaTypeRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an actorProfile given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the actorProfiles relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return ActorProfile the ActorProfile entity with the requested GUID
     */
    public ActorProfile getActorProfile(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getActorProfile";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        ActorProfile gotactorProfile = ActorProfileMapper.mapOmrsEntityDetailToActorProfile(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotactorProfile );
        }
        return gotactorProfile;

    }
    /**
     * Create new actorProfile.
     * @param userId user identity
     * @param actorProfile the input entity with values.
     * @return ActorProfile the created entity.
     */

    public ActorProfile createActorProfile(String userId,ActorProfile actorProfile)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createActorProfile";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = ActorProfileMapper.mapActorProfileToOmrsEntityDetail(actorProfile);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        ActorProfile createdActorProfile =  ActorProfileMapper.mapOmrsEntityDetailToActorProfile(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created ActorProfile="+ createdActorProfile );
        }
        return createdActorProfile;
    }
    /**
     * Update actorProfile
     * @param userId user identity
     * @param actorProfile   actorProfile to update
     * @return ActorProfile the updated actorProfile entity
     */
    public ActorProfile updateActorProfile(String userId, ActorProfile actorProfile)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateActorProfile";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = ActorProfileMapper.mapActorProfileToOmrsEntityDetail(actorProfile);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            ActorProfile updatedActorProfile =  ActorProfileMapper.mapOmrsEntityDetailToActorProfile(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated ActorProfile="+ updatedActorProfile );
            }
            return updatedActorProfile;
        }

    /**
     * Delete an actorProfile identified by its GUID. Delete is a soft delete, this means that the actorProfile has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the actorProfile
     * @return ActorProfile the deleted ActorProfile entity
     */

    public ActorProfile deleteActorProfile(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteActorProfile";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ActorProfile type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ActorProfile");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"ActorProfile",entityDef.getGUID(),entityGuid);
         ActorProfile deletedActorProfile = ActorProfileMapper.mapOmrsEntityDetailToActorProfile(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedActorProfile;

    }
    /**
     * Purge an actorProfile identified by its GUID. Delete is a hard delete, this means that the actorProfile is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the actorProfile
     */
    public void purgeActorProfile(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeActorProfile";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ActorProfile type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ActorProfile");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"ActorProfile",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an ActorProfile identified by its GUID. Restore resurrects a soft deleted ActorProfile. When a ActorProfile was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the ActorProfile
     * @return  ActorProfile the restored ActorProfile
     */
    public ActorProfile restoreActorProfile(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreActorProfile";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        ActorProfile restoredActorProfile =  ActorProfileMapper.mapOmrsEntityDetailToActorProfile(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredActorProfile;
    }    

    /**
     * Add classifications to the supplied actorProfile
     * @param userId user identity
     * @param entityGuid the GUID value for actorProfile
     * @param classifications the classifications to apply.
     * @return the actorProfile entity that has been classified
     */
     public ActorProfile addActorProfileClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addActorProfileClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         ActorProfile actorProfileClassificationBeans = ActorProfileMapper.mapOmrsEntityDetailToActorProfile(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified ActorProfile=" +  actorProfileClassificationBeans);
         }
         return  actorProfileClassificationBeans;
    }

    /**
     * Updates classifications to an existing actorProfile represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the actorProfile
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given actorProfile guid
     */
    public ActorProfile updateActorProfileClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateActorProfileClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           ActorProfile  actorProfileClassificationBeans = ActorProfileMapper.mapOmrsEntityDetailToActorProfile(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  actorProfileClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing actorProfile represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the actorProfile
     * @param name name of the classification
     * @return deleted ActorProfile  classification
     */
    public ActorProfile deleteActorProfileClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteActorProfileClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       ActorProfile declassifiedActorProfile =  ActorProfileMapper.mapOmrsEntityDetailToActorProfile(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedActorProfile;
    }

    /**
      * Get the relationships associated with entity actorProfile represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the actorProfile
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getActorProfileRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getActorProfileRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an classificationAnnotation given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the classificationAnnotations relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return ClassificationAnnotation the ClassificationAnnotation entity with the requested GUID
     */
    public ClassificationAnnotation getClassificationAnnotation(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getClassificationAnnotation";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        ClassificationAnnotation gotclassificationAnnotation = ClassificationAnnotationMapper.mapOmrsEntityDetailToClassificationAnnotation(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotclassificationAnnotation );
        }
        return gotclassificationAnnotation;

    }
    /**
     * Create new classificationAnnotation.
     * @param userId user identity
     * @param classificationAnnotation the input entity with values.
     * @return ClassificationAnnotation the created entity.
     */

    public ClassificationAnnotation createClassificationAnnotation(String userId,ClassificationAnnotation classificationAnnotation)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createClassificationAnnotation";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = ClassificationAnnotationMapper.mapClassificationAnnotationToOmrsEntityDetail(classificationAnnotation);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        ClassificationAnnotation createdClassificationAnnotation =  ClassificationAnnotationMapper.mapOmrsEntityDetailToClassificationAnnotation(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created ClassificationAnnotation="+ createdClassificationAnnotation );
        }
        return createdClassificationAnnotation;
    }
    /**
     * Update classificationAnnotation
     * @param userId user identity
     * @param classificationAnnotation   classificationAnnotation to update
     * @return ClassificationAnnotation the updated classificationAnnotation entity
     */
    public ClassificationAnnotation updateClassificationAnnotation(String userId, ClassificationAnnotation classificationAnnotation)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateClassificationAnnotation";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = ClassificationAnnotationMapper.mapClassificationAnnotationToOmrsEntityDetail(classificationAnnotation);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            ClassificationAnnotation updatedClassificationAnnotation =  ClassificationAnnotationMapper.mapOmrsEntityDetailToClassificationAnnotation(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated ClassificationAnnotation="+ updatedClassificationAnnotation );
            }
            return updatedClassificationAnnotation;
        }

    /**
     * Delete an classificationAnnotation identified by its GUID. Delete is a soft delete, this means that the classificationAnnotation has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the classificationAnnotation
     * @return ClassificationAnnotation the deleted ClassificationAnnotation entity
     */

    public ClassificationAnnotation deleteClassificationAnnotation(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteClassificationAnnotation";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ClassificationAnnotation type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ClassificationAnnotation");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"ClassificationAnnotation",entityDef.getGUID(),entityGuid);
         ClassificationAnnotation deletedClassificationAnnotation = ClassificationAnnotationMapper.mapOmrsEntityDetailToClassificationAnnotation(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedClassificationAnnotation;

    }
    /**
     * Purge an classificationAnnotation identified by its GUID. Delete is a hard delete, this means that the classificationAnnotation is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the classificationAnnotation
     */
    public void purgeClassificationAnnotation(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeClassificationAnnotation";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ClassificationAnnotation type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ClassificationAnnotation");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"ClassificationAnnotation",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an ClassificationAnnotation identified by its GUID. Restore resurrects a soft deleted ClassificationAnnotation. When a ClassificationAnnotation was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the ClassificationAnnotation
     * @return  ClassificationAnnotation the restored ClassificationAnnotation
     */
    public ClassificationAnnotation restoreClassificationAnnotation(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreClassificationAnnotation";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        ClassificationAnnotation restoredClassificationAnnotation =  ClassificationAnnotationMapper.mapOmrsEntityDetailToClassificationAnnotation(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredClassificationAnnotation;
    }    

    /**
     * Add classifications to the supplied classificationAnnotation
     * @param userId user identity
     * @param entityGuid the GUID value for classificationAnnotation
     * @param classifications the classifications to apply.
     * @return the classificationAnnotation entity that has been classified
     */
     public ClassificationAnnotation addClassificationAnnotationClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addClassificationAnnotationClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         ClassificationAnnotation classificationAnnotationClassificationBeans = ClassificationAnnotationMapper.mapOmrsEntityDetailToClassificationAnnotation(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified ClassificationAnnotation=" +  classificationAnnotationClassificationBeans);
         }
         return  classificationAnnotationClassificationBeans;
    }

    /**
     * Updates classifications to an existing classificationAnnotation represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the classificationAnnotation
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given classificationAnnotation guid
     */
    public ClassificationAnnotation updateClassificationAnnotationClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateClassificationAnnotationClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           ClassificationAnnotation  classificationAnnotationClassificationBeans = ClassificationAnnotationMapper.mapOmrsEntityDetailToClassificationAnnotation(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  classificationAnnotationClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing classificationAnnotation represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the classificationAnnotation
     * @param name name of the classification
     * @return deleted ClassificationAnnotation  classification
     */
    public ClassificationAnnotation deleteClassificationAnnotationClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteClassificationAnnotationClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       ClassificationAnnotation declassifiedClassificationAnnotation =  ClassificationAnnotationMapper.mapOmrsEntityDetailToClassificationAnnotation(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedClassificationAnnotation;
    }

    /**
      * Get the relationships associated with entity classificationAnnotation represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the classificationAnnotation
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getClassificationAnnotationRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getClassificationAnnotationRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an iTInfrastructure given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the iTInfrastructures relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return ITInfrastructure the ITInfrastructure entity with the requested GUID
     */
    public ITInfrastructure getITInfrastructure(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getITInfrastructure";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        ITInfrastructure gotiTInfrastructure = ITInfrastructureMapper.mapOmrsEntityDetailToITInfrastructure(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotiTInfrastructure );
        }
        return gotiTInfrastructure;

    }
    /**
     * Create new iTInfrastructure.
     * @param userId user identity
     * @param iTInfrastructure the input entity with values.
     * @return ITInfrastructure the created entity.
     */

    public ITInfrastructure createITInfrastructure(String userId,ITInfrastructure iTInfrastructure)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createITInfrastructure";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = ITInfrastructureMapper.mapITInfrastructureToOmrsEntityDetail(iTInfrastructure);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        ITInfrastructure createdITInfrastructure =  ITInfrastructureMapper.mapOmrsEntityDetailToITInfrastructure(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created ITInfrastructure="+ createdITInfrastructure );
        }
        return createdITInfrastructure;
    }
    /**
     * Update iTInfrastructure
     * @param userId user identity
     * @param iTInfrastructure   iTInfrastructure to update
     * @return ITInfrastructure the updated iTInfrastructure entity
     */
    public ITInfrastructure updateITInfrastructure(String userId, ITInfrastructure iTInfrastructure)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateITInfrastructure";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = ITInfrastructureMapper.mapITInfrastructureToOmrsEntityDetail(iTInfrastructure);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            ITInfrastructure updatedITInfrastructure =  ITInfrastructureMapper.mapOmrsEntityDetailToITInfrastructure(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated ITInfrastructure="+ updatedITInfrastructure );
            }
            return updatedITInfrastructure;
        }

    /**
     * Delete an iTInfrastructure identified by its GUID. Delete is a soft delete, this means that the iTInfrastructure has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the iTInfrastructure
     * @return ITInfrastructure the deleted ITInfrastructure entity
     */

    public ITInfrastructure deleteITInfrastructure(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteITInfrastructure";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ITInfrastructure type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ITInfrastructure");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"ITInfrastructure",entityDef.getGUID(),entityGuid);
         ITInfrastructure deletedITInfrastructure = ITInfrastructureMapper.mapOmrsEntityDetailToITInfrastructure(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedITInfrastructure;

    }
    /**
     * Purge an iTInfrastructure identified by its GUID. Delete is a hard delete, this means that the iTInfrastructure is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the iTInfrastructure
     */
    public void purgeITInfrastructure(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeITInfrastructure";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ITInfrastructure type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ITInfrastructure");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"ITInfrastructure",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an ITInfrastructure identified by its GUID. Restore resurrects a soft deleted ITInfrastructure. When a ITInfrastructure was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the ITInfrastructure
     * @return  ITInfrastructure the restored ITInfrastructure
     */
    public ITInfrastructure restoreITInfrastructure(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreITInfrastructure";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        ITInfrastructure restoredITInfrastructure =  ITInfrastructureMapper.mapOmrsEntityDetailToITInfrastructure(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredITInfrastructure;
    }    

    /**
     * Add classifications to the supplied iTInfrastructure
     * @param userId user identity
     * @param entityGuid the GUID value for iTInfrastructure
     * @param classifications the classifications to apply.
     * @return the iTInfrastructure entity that has been classified
     */
     public ITInfrastructure addITInfrastructureClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addITInfrastructureClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         ITInfrastructure iTInfrastructureClassificationBeans = ITInfrastructureMapper.mapOmrsEntityDetailToITInfrastructure(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified ITInfrastructure=" +  iTInfrastructureClassificationBeans);
         }
         return  iTInfrastructureClassificationBeans;
    }

    /**
     * Updates classifications to an existing iTInfrastructure represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the iTInfrastructure
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given iTInfrastructure guid
     */
    public ITInfrastructure updateITInfrastructureClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateITInfrastructureClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           ITInfrastructure  iTInfrastructureClassificationBeans = ITInfrastructureMapper.mapOmrsEntityDetailToITInfrastructure(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  iTInfrastructureClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing iTInfrastructure represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the iTInfrastructure
     * @param name name of the classification
     * @return deleted ITInfrastructure  classification
     */
    public ITInfrastructure deleteITInfrastructureClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteITInfrastructureClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       ITInfrastructure declassifiedITInfrastructure =  ITInfrastructureMapper.mapOmrsEntityDetailToITInfrastructure(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedITInfrastructure;
    }

    /**
      * Get the relationships associated with entity iTInfrastructure represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the iTInfrastructure
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getITInfrastructureRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getITInfrastructureRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an aPIOperation given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the aPIOperations relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return APIOperation the APIOperation entity with the requested GUID
     */
    public APIOperation getAPIOperation(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getAPIOperation";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        APIOperation gotaPIOperation = APIOperationMapper.mapOmrsEntityDetailToAPIOperation(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotaPIOperation );
        }
        return gotaPIOperation;

    }
    /**
     * Create new aPIOperation.
     * @param userId user identity
     * @param aPIOperation the input entity with values.
     * @return APIOperation the created entity.
     */

    public APIOperation createAPIOperation(String userId,APIOperation aPIOperation)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createAPIOperation";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = APIOperationMapper.mapAPIOperationToOmrsEntityDetail(aPIOperation);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        APIOperation createdAPIOperation =  APIOperationMapper.mapOmrsEntityDetailToAPIOperation(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created APIOperation="+ createdAPIOperation );
        }
        return createdAPIOperation;
    }
    /**
     * Update aPIOperation
     * @param userId user identity
     * @param aPIOperation   aPIOperation to update
     * @return APIOperation the updated aPIOperation entity
     */
    public APIOperation updateAPIOperation(String userId, APIOperation aPIOperation)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateAPIOperation";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = APIOperationMapper.mapAPIOperationToOmrsEntityDetail(aPIOperation);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            APIOperation updatedAPIOperation =  APIOperationMapper.mapOmrsEntityDetailToAPIOperation(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated APIOperation="+ updatedAPIOperation );
            }
            return updatedAPIOperation;
        }

    /**
     * Delete an aPIOperation identified by its GUID. Delete is a soft delete, this means that the aPIOperation has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the aPIOperation
     * @return APIOperation the deleted APIOperation entity
     */

    public APIOperation deleteAPIOperation(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteAPIOperation";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the APIOperation type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("APIOperation");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"APIOperation",entityDef.getGUID(),entityGuid);
         APIOperation deletedAPIOperation = APIOperationMapper.mapOmrsEntityDetailToAPIOperation(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedAPIOperation;

    }
    /**
     * Purge an aPIOperation identified by its GUID. Delete is a hard delete, this means that the aPIOperation is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the aPIOperation
     */
    public void purgeAPIOperation(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeAPIOperation";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the APIOperation type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("APIOperation");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"APIOperation",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an APIOperation identified by its GUID. Restore resurrects a soft deleted APIOperation. When a APIOperation was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the APIOperation
     * @return  APIOperation the restored APIOperation
     */
    public APIOperation restoreAPIOperation(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreAPIOperation";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        APIOperation restoredAPIOperation =  APIOperationMapper.mapOmrsEntityDetailToAPIOperation(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredAPIOperation;
    }    

    /**
     * Add classifications to the supplied aPIOperation
     * @param userId user identity
     * @param entityGuid the GUID value for aPIOperation
     * @param classifications the classifications to apply.
     * @return the aPIOperation entity that has been classified
     */
     public APIOperation addAPIOperationClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addAPIOperationClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         APIOperation aPIOperationClassificationBeans = APIOperationMapper.mapOmrsEntityDetailToAPIOperation(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified APIOperation=" +  aPIOperationClassificationBeans);
         }
         return  aPIOperationClassificationBeans;
    }

    /**
     * Updates classifications to an existing aPIOperation represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the aPIOperation
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given aPIOperation guid
     */
    public APIOperation updateAPIOperationClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateAPIOperationClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           APIOperation  aPIOperationClassificationBeans = APIOperationMapper.mapOmrsEntityDetailToAPIOperation(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  aPIOperationClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing aPIOperation represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the aPIOperation
     * @param name name of the classification
     * @return deleted APIOperation  classification
     */
    public APIOperation deleteAPIOperationClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteAPIOperationClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       APIOperation declassifiedAPIOperation =  APIOperationMapper.mapOmrsEntityDetailToAPIOperation(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedAPIOperation;
    }

    /**
      * Get the relationships associated with entity aPIOperation represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the aPIOperation
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getAPIOperationRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getAPIOperationRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an engine given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the engines relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return Engine the Engine entity with the requested GUID
     */
    public Engine getEngine(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getEngine";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        Engine gotengine = EngineMapper.mapOmrsEntityDetailToEngine(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotengine );
        }
        return gotengine;

    }
    /**
     * Create new engine.
     * @param userId user identity
     * @param engine the input entity with values.
     * @return Engine the created entity.
     */

    public Engine createEngine(String userId,Engine engine)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createEngine";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = EngineMapper.mapEngineToOmrsEntityDetail(engine);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        Engine createdEngine =  EngineMapper.mapOmrsEntityDetailToEngine(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created Engine="+ createdEngine );
        }
        return createdEngine;
    }
    /**
     * Update engine
     * @param userId user identity
     * @param engine   engine to update
     * @return Engine the updated engine entity
     */
    public Engine updateEngine(String userId, Engine engine)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateEngine";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = EngineMapper.mapEngineToOmrsEntityDetail(engine);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            Engine updatedEngine =  EngineMapper.mapOmrsEntityDetailToEngine(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated Engine="+ updatedEngine );
            }
            return updatedEngine;
        }

    /**
     * Delete an engine identified by its GUID. Delete is a soft delete, this means that the engine has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the engine
     * @return Engine the deleted Engine entity
     */

    public Engine deleteEngine(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteEngine";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Engine type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Engine");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"Engine",entityDef.getGUID(),entityGuid);
         Engine deletedEngine = EngineMapper.mapOmrsEntityDetailToEngine(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedEngine;

    }
    /**
     * Purge an engine identified by its GUID. Delete is a hard delete, this means that the engine is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the engine
     */
    public void purgeEngine(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeEngine";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Engine type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Engine");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"Engine",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an Engine identified by its GUID. Restore resurrects a soft deleted Engine. When a Engine was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the Engine
     * @return  Engine the restored Engine
     */
    public Engine restoreEngine(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreEngine";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        Engine restoredEngine =  EngineMapper.mapOmrsEntityDetailToEngine(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredEngine;
    }    

    /**
     * Add classifications to the supplied engine
     * @param userId user identity
     * @param entityGuid the GUID value for engine
     * @param classifications the classifications to apply.
     * @return the engine entity that has been classified
     */
     public Engine addEngineClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addEngineClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         Engine engineClassificationBeans = EngineMapper.mapOmrsEntityDetailToEngine(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified Engine=" +  engineClassificationBeans);
         }
         return  engineClassificationBeans;
    }

    /**
     * Updates classifications to an existing engine represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the engine
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given engine guid
     */
    public Engine updateEngineClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateEngineClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           Engine  engineClassificationBeans = EngineMapper.mapOmrsEntityDetailToEngine(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  engineClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing engine represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the engine
     * @param name name of the classification
     * @return deleted Engine  classification
     */
    public Engine deleteEngineClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteEngineClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       Engine declassifiedEngine =  EngineMapper.mapOmrsEntityDetailToEngine(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedEngine;
    }

    /**
      * Get the relationships associated with entity engine represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the engine
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getEngineRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getEngineRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an toDo given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the toDos relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return ToDo the ToDo entity with the requested GUID
     */
    public ToDo getToDo(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getToDo";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        ToDo gottoDo = ToDoMapper.mapOmrsEntityDetailToToDo(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gottoDo );
        }
        return gottoDo;

    }
    /**
     * Create new toDo.
     * @param userId user identity
     * @param toDo the input entity with values.
     * @return ToDo the created entity.
     */

    public ToDo createToDo(String userId,ToDo toDo)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createToDo";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = ToDoMapper.mapToDoToOmrsEntityDetail(toDo);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        ToDo createdToDo =  ToDoMapper.mapOmrsEntityDetailToToDo(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created ToDo="+ createdToDo );
        }
        return createdToDo;
    }
    /**
     * Update toDo
     * @param userId user identity
     * @param toDo   toDo to update
     * @return ToDo the updated toDo entity
     */
    public ToDo updateToDo(String userId, ToDo toDo)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateToDo";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = ToDoMapper.mapToDoToOmrsEntityDetail(toDo);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            ToDo updatedToDo =  ToDoMapper.mapOmrsEntityDetailToToDo(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated ToDo="+ updatedToDo );
            }
            return updatedToDo;
        }

    /**
     * Delete an toDo identified by its GUID. Delete is a soft delete, this means that the toDo has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the toDo
     * @return ToDo the deleted ToDo entity
     */

    public ToDo deleteToDo(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteToDo";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ToDo type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ToDo");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"ToDo",entityDef.getGUID(),entityGuid);
         ToDo deletedToDo = ToDoMapper.mapOmrsEntityDetailToToDo(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedToDo;

    }
    /**
     * Purge an toDo identified by its GUID. Delete is a hard delete, this means that the toDo is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the toDo
     */
    public void purgeToDo(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeToDo";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ToDo type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ToDo");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"ToDo",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an ToDo identified by its GUID. Restore resurrects a soft deleted ToDo. When a ToDo was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the ToDo
     * @return  ToDo the restored ToDo
     */
    public ToDo restoreToDo(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreToDo";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        ToDo restoredToDo =  ToDoMapper.mapOmrsEntityDetailToToDo(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredToDo;
    }    

    /**
     * Add classifications to the supplied toDo
     * @param userId user identity
     * @param entityGuid the GUID value for toDo
     * @param classifications the classifications to apply.
     * @return the toDo entity that has been classified
     */
     public ToDo addToDoClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addToDoClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         ToDo toDoClassificationBeans = ToDoMapper.mapOmrsEntityDetailToToDo(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified ToDo=" +  toDoClassificationBeans);
         }
         return  toDoClassificationBeans;
    }

    /**
     * Updates classifications to an existing toDo represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the toDo
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given toDo guid
     */
    public ToDo updateToDoClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateToDoClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           ToDo  toDoClassificationBeans = ToDoMapper.mapOmrsEntityDetailToToDo(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  toDoClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing toDo represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the toDo
     * @param name name of the classification
     * @return deleted ToDo  classification
     */
    public ToDo deleteToDoClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteToDoClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       ToDo declassifiedToDo =  ToDoMapper.mapOmrsEntityDetailToToDo(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedToDo;
    }

    /**
      * Get the relationships associated with entity toDo represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the toDo
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getToDoRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getToDoRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an keyStoreCollection given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the keyStoreCollections relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return KeyStoreCollection the KeyStoreCollection entity with the requested GUID
     */
    public KeyStoreCollection getKeyStoreCollection(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getKeyStoreCollection";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        KeyStoreCollection gotkeyStoreCollection = KeyStoreCollectionMapper.mapOmrsEntityDetailToKeyStoreCollection(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotkeyStoreCollection );
        }
        return gotkeyStoreCollection;

    }
    /**
     * Create new keyStoreCollection.
     * @param userId user identity
     * @param keyStoreCollection the input entity with values.
     * @return KeyStoreCollection the created entity.
     */

    public KeyStoreCollection createKeyStoreCollection(String userId,KeyStoreCollection keyStoreCollection)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createKeyStoreCollection";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = KeyStoreCollectionMapper.mapKeyStoreCollectionToOmrsEntityDetail(keyStoreCollection);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        KeyStoreCollection createdKeyStoreCollection =  KeyStoreCollectionMapper.mapOmrsEntityDetailToKeyStoreCollection(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created KeyStoreCollection="+ createdKeyStoreCollection );
        }
        return createdKeyStoreCollection;
    }
    /**
     * Update keyStoreCollection
     * @param userId user identity
     * @param keyStoreCollection   keyStoreCollection to update
     * @return KeyStoreCollection the updated keyStoreCollection entity
     */
    public KeyStoreCollection updateKeyStoreCollection(String userId, KeyStoreCollection keyStoreCollection)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateKeyStoreCollection";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = KeyStoreCollectionMapper.mapKeyStoreCollectionToOmrsEntityDetail(keyStoreCollection);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            KeyStoreCollection updatedKeyStoreCollection =  KeyStoreCollectionMapper.mapOmrsEntityDetailToKeyStoreCollection(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated KeyStoreCollection="+ updatedKeyStoreCollection );
            }
            return updatedKeyStoreCollection;
        }

    /**
     * Delete an keyStoreCollection identified by its GUID. Delete is a soft delete, this means that the keyStoreCollection has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the keyStoreCollection
     * @return KeyStoreCollection the deleted KeyStoreCollection entity
     */

    public KeyStoreCollection deleteKeyStoreCollection(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteKeyStoreCollection";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the KeyStoreCollection type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("KeyStoreCollection");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"KeyStoreCollection",entityDef.getGUID(),entityGuid);
         KeyStoreCollection deletedKeyStoreCollection = KeyStoreCollectionMapper.mapOmrsEntityDetailToKeyStoreCollection(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedKeyStoreCollection;

    }
    /**
     * Purge an keyStoreCollection identified by its GUID. Delete is a hard delete, this means that the keyStoreCollection is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the keyStoreCollection
     */
    public void purgeKeyStoreCollection(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeKeyStoreCollection";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the KeyStoreCollection type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("KeyStoreCollection");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"KeyStoreCollection",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an KeyStoreCollection identified by its GUID. Restore resurrects a soft deleted KeyStoreCollection. When a KeyStoreCollection was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the KeyStoreCollection
     * @return  KeyStoreCollection the restored KeyStoreCollection
     */
    public KeyStoreCollection restoreKeyStoreCollection(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreKeyStoreCollection";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        KeyStoreCollection restoredKeyStoreCollection =  KeyStoreCollectionMapper.mapOmrsEntityDetailToKeyStoreCollection(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredKeyStoreCollection;
    }    

    /**
     * Add classifications to the supplied keyStoreCollection
     * @param userId user identity
     * @param entityGuid the GUID value for keyStoreCollection
     * @param classifications the classifications to apply.
     * @return the keyStoreCollection entity that has been classified
     */
     public KeyStoreCollection addKeyStoreCollectionClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addKeyStoreCollectionClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         KeyStoreCollection keyStoreCollectionClassificationBeans = KeyStoreCollectionMapper.mapOmrsEntityDetailToKeyStoreCollection(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified KeyStoreCollection=" +  keyStoreCollectionClassificationBeans);
         }
         return  keyStoreCollectionClassificationBeans;
    }

    /**
     * Updates classifications to an existing keyStoreCollection represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the keyStoreCollection
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given keyStoreCollection guid
     */
    public KeyStoreCollection updateKeyStoreCollectionClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateKeyStoreCollectionClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           KeyStoreCollection  keyStoreCollectionClassificationBeans = KeyStoreCollectionMapper.mapOmrsEntityDetailToKeyStoreCollection(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  keyStoreCollectionClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing keyStoreCollection represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the keyStoreCollection
     * @param name name of the classification
     * @return deleted KeyStoreCollection  classification
     */
    public KeyStoreCollection deleteKeyStoreCollectionClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteKeyStoreCollectionClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       KeyStoreCollection declassifiedKeyStoreCollection =  KeyStoreCollectionMapper.mapOmrsEntityDetailToKeyStoreCollection(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedKeyStoreCollection;
    }

    /**
      * Get the relationships associated with entity keyStoreCollection represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the keyStoreCollection
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getKeyStoreCollectionRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getKeyStoreCollectionRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an governanceResponsibility given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the governanceResponsibilities relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return GovernanceResponsibility the GovernanceResponsibility entity with the requested GUID
     */
    public GovernanceResponsibility getGovernanceResponsibility(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getGovernanceResponsibility";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        GovernanceResponsibility gotgovernanceResponsibility = GovernanceResponsibilityMapper.mapOmrsEntityDetailToGovernanceResponsibility(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotgovernanceResponsibility );
        }
        return gotgovernanceResponsibility;

    }
    /**
     * Create new governanceResponsibility.
     * @param userId user identity
     * @param governanceResponsibility the input entity with values.
     * @return GovernanceResponsibility the created entity.
     */

    public GovernanceResponsibility createGovernanceResponsibility(String userId,GovernanceResponsibility governanceResponsibility)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createGovernanceResponsibility";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = GovernanceResponsibilityMapper.mapGovernanceResponsibilityToOmrsEntityDetail(governanceResponsibility);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        GovernanceResponsibility createdGovernanceResponsibility =  GovernanceResponsibilityMapper.mapOmrsEntityDetailToGovernanceResponsibility(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created GovernanceResponsibility="+ createdGovernanceResponsibility );
        }
        return createdGovernanceResponsibility;
    }
    /**
     * Update governanceResponsibility
     * @param userId user identity
     * @param governanceResponsibility   governanceResponsibility to update
     * @return GovernanceResponsibility the updated governanceResponsibility entity
     */
    public GovernanceResponsibility updateGovernanceResponsibility(String userId, GovernanceResponsibility governanceResponsibility)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateGovernanceResponsibility";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = GovernanceResponsibilityMapper.mapGovernanceResponsibilityToOmrsEntityDetail(governanceResponsibility);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            GovernanceResponsibility updatedGovernanceResponsibility =  GovernanceResponsibilityMapper.mapOmrsEntityDetailToGovernanceResponsibility(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated GovernanceResponsibility="+ updatedGovernanceResponsibility );
            }
            return updatedGovernanceResponsibility;
        }

    /**
     * Delete an governanceResponsibility identified by its GUID. Delete is a soft delete, this means that the governanceResponsibility has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the governanceResponsibility
     * @return GovernanceResponsibility the deleted GovernanceResponsibility entity
     */

    public GovernanceResponsibility deleteGovernanceResponsibility(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteGovernanceResponsibility";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GovernanceResponsibility type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GovernanceResponsibility");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"GovernanceResponsibility",entityDef.getGUID(),entityGuid);
         GovernanceResponsibility deletedGovernanceResponsibility = GovernanceResponsibilityMapper.mapOmrsEntityDetailToGovernanceResponsibility(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedGovernanceResponsibility;

    }
    /**
     * Purge an governanceResponsibility identified by its GUID. Delete is a hard delete, this means that the governanceResponsibility is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the governanceResponsibility
     */
    public void purgeGovernanceResponsibility(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeGovernanceResponsibility";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GovernanceResponsibility type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GovernanceResponsibility");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"GovernanceResponsibility",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an GovernanceResponsibility identified by its GUID. Restore resurrects a soft deleted GovernanceResponsibility. When a GovernanceResponsibility was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the GovernanceResponsibility
     * @return  GovernanceResponsibility the restored GovernanceResponsibility
     */
    public GovernanceResponsibility restoreGovernanceResponsibility(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreGovernanceResponsibility";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        GovernanceResponsibility restoredGovernanceResponsibility =  GovernanceResponsibilityMapper.mapOmrsEntityDetailToGovernanceResponsibility(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredGovernanceResponsibility;
    }    

    /**
     * Add classifications to the supplied governanceResponsibility
     * @param userId user identity
     * @param entityGuid the GUID value for governanceResponsibility
     * @param classifications the classifications to apply.
     * @return the governanceResponsibility entity that has been classified
     */
     public GovernanceResponsibility addGovernanceResponsibilityClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addGovernanceResponsibilityClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         GovernanceResponsibility governanceResponsibilityClassificationBeans = GovernanceResponsibilityMapper.mapOmrsEntityDetailToGovernanceResponsibility(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified GovernanceResponsibility=" +  governanceResponsibilityClassificationBeans);
         }
         return  governanceResponsibilityClassificationBeans;
    }

    /**
     * Updates classifications to an existing governanceResponsibility represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the governanceResponsibility
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given governanceResponsibility guid
     */
    public GovernanceResponsibility updateGovernanceResponsibilityClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateGovernanceResponsibilityClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           GovernanceResponsibility  governanceResponsibilityClassificationBeans = GovernanceResponsibilityMapper.mapOmrsEntityDetailToGovernanceResponsibility(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  governanceResponsibilityClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing governanceResponsibility represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the governanceResponsibility
     * @param name name of the classification
     * @return deleted GovernanceResponsibility  classification
     */
    public GovernanceResponsibility deleteGovernanceResponsibilityClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteGovernanceResponsibilityClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       GovernanceResponsibility declassifiedGovernanceResponsibility =  GovernanceResponsibilityMapper.mapOmrsEntityDetailToGovernanceResponsibility(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedGovernanceResponsibility;
    }

    /**
      * Get the relationships associated with entity governanceResponsibility represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the governanceResponsibility
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getGovernanceResponsibilityRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getGovernanceResponsibilityRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an referenceCodeMappingTable given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the referenceCodeMappingTables relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return ReferenceCodeMappingTable the ReferenceCodeMappingTable entity with the requested GUID
     */
    public ReferenceCodeMappingTable getReferenceCodeMappingTable(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getReferenceCodeMappingTable";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        ReferenceCodeMappingTable gotreferenceCodeMappingTable = ReferenceCodeMappingTableMapper.mapOmrsEntityDetailToReferenceCodeMappingTable(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotreferenceCodeMappingTable );
        }
        return gotreferenceCodeMappingTable;

    }
    /**
     * Create new referenceCodeMappingTable.
     * @param userId user identity
     * @param referenceCodeMappingTable the input entity with values.
     * @return ReferenceCodeMappingTable the created entity.
     */

    public ReferenceCodeMappingTable createReferenceCodeMappingTable(String userId,ReferenceCodeMappingTable referenceCodeMappingTable)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createReferenceCodeMappingTable";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = ReferenceCodeMappingTableMapper.mapReferenceCodeMappingTableToOmrsEntityDetail(referenceCodeMappingTable);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        ReferenceCodeMappingTable createdReferenceCodeMappingTable =  ReferenceCodeMappingTableMapper.mapOmrsEntityDetailToReferenceCodeMappingTable(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created ReferenceCodeMappingTable="+ createdReferenceCodeMappingTable );
        }
        return createdReferenceCodeMappingTable;
    }
    /**
     * Update referenceCodeMappingTable
     * @param userId user identity
     * @param referenceCodeMappingTable   referenceCodeMappingTable to update
     * @return ReferenceCodeMappingTable the updated referenceCodeMappingTable entity
     */
    public ReferenceCodeMappingTable updateReferenceCodeMappingTable(String userId, ReferenceCodeMappingTable referenceCodeMappingTable)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateReferenceCodeMappingTable";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = ReferenceCodeMappingTableMapper.mapReferenceCodeMappingTableToOmrsEntityDetail(referenceCodeMappingTable);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            ReferenceCodeMappingTable updatedReferenceCodeMappingTable =  ReferenceCodeMappingTableMapper.mapOmrsEntityDetailToReferenceCodeMappingTable(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated ReferenceCodeMappingTable="+ updatedReferenceCodeMappingTable );
            }
            return updatedReferenceCodeMappingTable;
        }

    /**
     * Delete an referenceCodeMappingTable identified by its GUID. Delete is a soft delete, this means that the referenceCodeMappingTable has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the referenceCodeMappingTable
     * @return ReferenceCodeMappingTable the deleted ReferenceCodeMappingTable entity
     */

    public ReferenceCodeMappingTable deleteReferenceCodeMappingTable(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteReferenceCodeMappingTable";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ReferenceCodeMappingTable type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ReferenceCodeMappingTable");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"ReferenceCodeMappingTable",entityDef.getGUID(),entityGuid);
         ReferenceCodeMappingTable deletedReferenceCodeMappingTable = ReferenceCodeMappingTableMapper.mapOmrsEntityDetailToReferenceCodeMappingTable(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedReferenceCodeMappingTable;

    }
    /**
     * Purge an referenceCodeMappingTable identified by its GUID. Delete is a hard delete, this means that the referenceCodeMappingTable is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the referenceCodeMappingTable
     */
    public void purgeReferenceCodeMappingTable(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeReferenceCodeMappingTable";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ReferenceCodeMappingTable type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ReferenceCodeMappingTable");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"ReferenceCodeMappingTable",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an ReferenceCodeMappingTable identified by its GUID. Restore resurrects a soft deleted ReferenceCodeMappingTable. When a ReferenceCodeMappingTable was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the ReferenceCodeMappingTable
     * @return  ReferenceCodeMappingTable the restored ReferenceCodeMappingTable
     */
    public ReferenceCodeMappingTable restoreReferenceCodeMappingTable(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreReferenceCodeMappingTable";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        ReferenceCodeMappingTable restoredReferenceCodeMappingTable =  ReferenceCodeMappingTableMapper.mapOmrsEntityDetailToReferenceCodeMappingTable(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredReferenceCodeMappingTable;
    }    

    /**
     * Add classifications to the supplied referenceCodeMappingTable
     * @param userId user identity
     * @param entityGuid the GUID value for referenceCodeMappingTable
     * @param classifications the classifications to apply.
     * @return the referenceCodeMappingTable entity that has been classified
     */
     public ReferenceCodeMappingTable addReferenceCodeMappingTableClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addReferenceCodeMappingTableClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         ReferenceCodeMappingTable referenceCodeMappingTableClassificationBeans = ReferenceCodeMappingTableMapper.mapOmrsEntityDetailToReferenceCodeMappingTable(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified ReferenceCodeMappingTable=" +  referenceCodeMappingTableClassificationBeans);
         }
         return  referenceCodeMappingTableClassificationBeans;
    }

    /**
     * Updates classifications to an existing referenceCodeMappingTable represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the referenceCodeMappingTable
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given referenceCodeMappingTable guid
     */
    public ReferenceCodeMappingTable updateReferenceCodeMappingTableClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateReferenceCodeMappingTableClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           ReferenceCodeMappingTable  referenceCodeMappingTableClassificationBeans = ReferenceCodeMappingTableMapper.mapOmrsEntityDetailToReferenceCodeMappingTable(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  referenceCodeMappingTableClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing referenceCodeMappingTable represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the referenceCodeMappingTable
     * @param name name of the classification
     * @return deleted ReferenceCodeMappingTable  classification
     */
    public ReferenceCodeMappingTable deleteReferenceCodeMappingTableClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteReferenceCodeMappingTableClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       ReferenceCodeMappingTable declassifiedReferenceCodeMappingTable =  ReferenceCodeMappingTableMapper.mapOmrsEntityDetailToReferenceCodeMappingTable(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedReferenceCodeMappingTable;
    }

    /**
      * Get the relationships associated with entity referenceCodeMappingTable represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the referenceCodeMappingTable
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getReferenceCodeMappingTableRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getReferenceCodeMappingTableRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an noteEntry given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the noteEntries relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return NoteEntry the NoteEntry entity with the requested GUID
     */
    public NoteEntry getNoteEntry(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getNoteEntry";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        NoteEntry gotnoteEntry = NoteEntryMapper.mapOmrsEntityDetailToNoteEntry(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotnoteEntry );
        }
        return gotnoteEntry;

    }
    /**
     * Create new noteEntry.
     * @param userId user identity
     * @param noteEntry the input entity with values.
     * @return NoteEntry the created entity.
     */

    public NoteEntry createNoteEntry(String userId,NoteEntry noteEntry)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createNoteEntry";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = NoteEntryMapper.mapNoteEntryToOmrsEntityDetail(noteEntry);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        NoteEntry createdNoteEntry =  NoteEntryMapper.mapOmrsEntityDetailToNoteEntry(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created NoteEntry="+ createdNoteEntry );
        }
        return createdNoteEntry;
    }
    /**
     * Update noteEntry
     * @param userId user identity
     * @param noteEntry   noteEntry to update
     * @return NoteEntry the updated noteEntry entity
     */
    public NoteEntry updateNoteEntry(String userId, NoteEntry noteEntry)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateNoteEntry";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = NoteEntryMapper.mapNoteEntryToOmrsEntityDetail(noteEntry);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            NoteEntry updatedNoteEntry =  NoteEntryMapper.mapOmrsEntityDetailToNoteEntry(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated NoteEntry="+ updatedNoteEntry );
            }
            return updatedNoteEntry;
        }

    /**
     * Delete an noteEntry identified by its GUID. Delete is a soft delete, this means that the noteEntry has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the noteEntry
     * @return NoteEntry the deleted NoteEntry entity
     */

    public NoteEntry deleteNoteEntry(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteNoteEntry";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the NoteEntry type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("NoteEntry");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"NoteEntry",entityDef.getGUID(),entityGuid);
         NoteEntry deletedNoteEntry = NoteEntryMapper.mapOmrsEntityDetailToNoteEntry(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedNoteEntry;

    }
    /**
     * Purge an noteEntry identified by its GUID. Delete is a hard delete, this means that the noteEntry is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the noteEntry
     */
    public void purgeNoteEntry(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeNoteEntry";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the NoteEntry type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("NoteEntry");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"NoteEntry",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an NoteEntry identified by its GUID. Restore resurrects a soft deleted NoteEntry. When a NoteEntry was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the NoteEntry
     * @return  NoteEntry the restored NoteEntry
     */
    public NoteEntry restoreNoteEntry(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreNoteEntry";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        NoteEntry restoredNoteEntry =  NoteEntryMapper.mapOmrsEntityDetailToNoteEntry(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredNoteEntry;
    }    

    /**
     * Add classifications to the supplied noteEntry
     * @param userId user identity
     * @param entityGuid the GUID value for noteEntry
     * @param classifications the classifications to apply.
     * @return the noteEntry entity that has been classified
     */
     public NoteEntry addNoteEntryClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addNoteEntryClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         NoteEntry noteEntryClassificationBeans = NoteEntryMapper.mapOmrsEntityDetailToNoteEntry(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified NoteEntry=" +  noteEntryClassificationBeans);
         }
         return  noteEntryClassificationBeans;
    }

    /**
     * Updates classifications to an existing noteEntry represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the noteEntry
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given noteEntry guid
     */
    public NoteEntry updateNoteEntryClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateNoteEntryClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           NoteEntry  noteEntryClassificationBeans = NoteEntryMapper.mapOmrsEntityDetailToNoteEntry(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  noteEntryClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing noteEntry represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the noteEntry
     * @param name name of the classification
     * @return deleted NoteEntry  classification
     */
    public NoteEntry deleteNoteEntryClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteNoteEntryClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       NoteEntry declassifiedNoteEntry =  NoteEntryMapper.mapOmrsEntityDetailToNoteEntry(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedNoteEntry;
    }

    /**
      * Get the relationships associated with entity noteEntry represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the noteEntry
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getNoteEntryRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getNoteEntryRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an governancePrinciple given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the governancePrinciples relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return GovernancePrinciple the GovernancePrinciple entity with the requested GUID
     */
    public GovernancePrinciple getGovernancePrinciple(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getGovernancePrinciple";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        GovernancePrinciple gotgovernancePrinciple = GovernancePrincipleMapper.mapOmrsEntityDetailToGovernancePrinciple(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotgovernancePrinciple );
        }
        return gotgovernancePrinciple;

    }
    /**
     * Create new governancePrinciple.
     * @param userId user identity
     * @param governancePrinciple the input entity with values.
     * @return GovernancePrinciple the created entity.
     */

    public GovernancePrinciple createGovernancePrinciple(String userId,GovernancePrinciple governancePrinciple)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createGovernancePrinciple";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = GovernancePrincipleMapper.mapGovernancePrincipleToOmrsEntityDetail(governancePrinciple);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        GovernancePrinciple createdGovernancePrinciple =  GovernancePrincipleMapper.mapOmrsEntityDetailToGovernancePrinciple(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created GovernancePrinciple="+ createdGovernancePrinciple );
        }
        return createdGovernancePrinciple;
    }
    /**
     * Update governancePrinciple
     * @param userId user identity
     * @param governancePrinciple   governancePrinciple to update
     * @return GovernancePrinciple the updated governancePrinciple entity
     */
    public GovernancePrinciple updateGovernancePrinciple(String userId, GovernancePrinciple governancePrinciple)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateGovernancePrinciple";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = GovernancePrincipleMapper.mapGovernancePrincipleToOmrsEntityDetail(governancePrinciple);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            GovernancePrinciple updatedGovernancePrinciple =  GovernancePrincipleMapper.mapOmrsEntityDetailToGovernancePrinciple(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated GovernancePrinciple="+ updatedGovernancePrinciple );
            }
            return updatedGovernancePrinciple;
        }

    /**
     * Delete an governancePrinciple identified by its GUID. Delete is a soft delete, this means that the governancePrinciple has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the governancePrinciple
     * @return GovernancePrinciple the deleted GovernancePrinciple entity
     */

    public GovernancePrinciple deleteGovernancePrinciple(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteGovernancePrinciple";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GovernancePrinciple type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GovernancePrinciple");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"GovernancePrinciple",entityDef.getGUID(),entityGuid);
         GovernancePrinciple deletedGovernancePrinciple = GovernancePrincipleMapper.mapOmrsEntityDetailToGovernancePrinciple(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedGovernancePrinciple;

    }
    /**
     * Purge an governancePrinciple identified by its GUID. Delete is a hard delete, this means that the governancePrinciple is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the governancePrinciple
     */
    public void purgeGovernancePrinciple(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeGovernancePrinciple";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GovernancePrinciple type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GovernancePrinciple");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"GovernancePrinciple",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an GovernancePrinciple identified by its GUID. Restore resurrects a soft deleted GovernancePrinciple. When a GovernancePrinciple was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the GovernancePrinciple
     * @return  GovernancePrinciple the restored GovernancePrinciple
     */
    public GovernancePrinciple restoreGovernancePrinciple(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreGovernancePrinciple";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        GovernancePrinciple restoredGovernancePrinciple =  GovernancePrincipleMapper.mapOmrsEntityDetailToGovernancePrinciple(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredGovernancePrinciple;
    }    

    /**
     * Add classifications to the supplied governancePrinciple
     * @param userId user identity
     * @param entityGuid the GUID value for governancePrinciple
     * @param classifications the classifications to apply.
     * @return the governancePrinciple entity that has been classified
     */
     public GovernancePrinciple addGovernancePrincipleClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addGovernancePrincipleClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         GovernancePrinciple governancePrincipleClassificationBeans = GovernancePrincipleMapper.mapOmrsEntityDetailToGovernancePrinciple(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified GovernancePrinciple=" +  governancePrincipleClassificationBeans);
         }
         return  governancePrincipleClassificationBeans;
    }

    /**
     * Updates classifications to an existing governancePrinciple represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the governancePrinciple
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given governancePrinciple guid
     */
    public GovernancePrinciple updateGovernancePrincipleClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateGovernancePrincipleClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           GovernancePrinciple  governancePrincipleClassificationBeans = GovernancePrincipleMapper.mapOmrsEntityDetailToGovernancePrinciple(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  governancePrincipleClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing governancePrinciple represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the governancePrinciple
     * @param name name of the classification
     * @return deleted GovernancePrinciple  classification
     */
    public GovernancePrinciple deleteGovernancePrincipleClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteGovernancePrincipleClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       GovernancePrinciple declassifiedGovernancePrinciple =  GovernancePrincipleMapper.mapOmrsEntityDetailToGovernancePrinciple(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedGovernancePrinciple;
    }

    /**
      * Get the relationships associated with entity governancePrinciple represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the governancePrinciple
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getGovernancePrincipleRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getGovernancePrincipleRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an setDocumentType given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the setDocumentTypes relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return SetDocumentType the SetDocumentType entity with the requested GUID
     */
    public SetDocumentType getSetDocumentType(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getSetDocumentType";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        SetDocumentType gotsetDocumentType = SetDocumentTypeMapper.mapOmrsEntityDetailToSetDocumentType(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotsetDocumentType );
        }
        return gotsetDocumentType;

    }
    /**
     * Create new setDocumentType.
     * @param userId user identity
     * @param setDocumentType the input entity with values.
     * @return SetDocumentType the created entity.
     */

    public SetDocumentType createSetDocumentType(String userId,SetDocumentType setDocumentType)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createSetDocumentType";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = SetDocumentTypeMapper.mapSetDocumentTypeToOmrsEntityDetail(setDocumentType);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        SetDocumentType createdSetDocumentType =  SetDocumentTypeMapper.mapOmrsEntityDetailToSetDocumentType(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created SetDocumentType="+ createdSetDocumentType );
        }
        return createdSetDocumentType;
    }
    /**
     * Update setDocumentType
     * @param userId user identity
     * @param setDocumentType   setDocumentType to update
     * @return SetDocumentType the updated setDocumentType entity
     */
    public SetDocumentType updateSetDocumentType(String userId, SetDocumentType setDocumentType)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateSetDocumentType";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = SetDocumentTypeMapper.mapSetDocumentTypeToOmrsEntityDetail(setDocumentType);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            SetDocumentType updatedSetDocumentType =  SetDocumentTypeMapper.mapOmrsEntityDetailToSetDocumentType(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated SetDocumentType="+ updatedSetDocumentType );
            }
            return updatedSetDocumentType;
        }

    /**
     * Delete an setDocumentType identified by its GUID. Delete is a soft delete, this means that the setDocumentType has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the setDocumentType
     * @return SetDocumentType the deleted SetDocumentType entity
     */

    public SetDocumentType deleteSetDocumentType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteSetDocumentType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the SetDocumentType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("SetDocumentType");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"SetDocumentType",entityDef.getGUID(),entityGuid);
         SetDocumentType deletedSetDocumentType = SetDocumentTypeMapper.mapOmrsEntityDetailToSetDocumentType(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedSetDocumentType;

    }
    /**
     * Purge an setDocumentType identified by its GUID. Delete is a hard delete, this means that the setDocumentType is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the setDocumentType
     */
    public void purgeSetDocumentType(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeSetDocumentType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the SetDocumentType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("SetDocumentType");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"SetDocumentType",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an SetDocumentType identified by its GUID. Restore resurrects a soft deleted SetDocumentType. When a SetDocumentType was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the SetDocumentType
     * @return  SetDocumentType the restored SetDocumentType
     */
    public SetDocumentType restoreSetDocumentType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreSetDocumentType";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        SetDocumentType restoredSetDocumentType =  SetDocumentTypeMapper.mapOmrsEntityDetailToSetDocumentType(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredSetDocumentType;
    }    

    /**
     * Add classifications to the supplied setDocumentType
     * @param userId user identity
     * @param entityGuid the GUID value for setDocumentType
     * @param classifications the classifications to apply.
     * @return the setDocumentType entity that has been classified
     */
     public SetDocumentType addSetDocumentTypeClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addSetDocumentTypeClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         SetDocumentType setDocumentTypeClassificationBeans = SetDocumentTypeMapper.mapOmrsEntityDetailToSetDocumentType(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified SetDocumentType=" +  setDocumentTypeClassificationBeans);
         }
         return  setDocumentTypeClassificationBeans;
    }

    /**
     * Updates classifications to an existing setDocumentType represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the setDocumentType
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given setDocumentType guid
     */
    public SetDocumentType updateSetDocumentTypeClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateSetDocumentTypeClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           SetDocumentType  setDocumentTypeClassificationBeans = SetDocumentTypeMapper.mapOmrsEntityDetailToSetDocumentType(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  setDocumentTypeClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing setDocumentType represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the setDocumentType
     * @param name name of the classification
     * @return deleted SetDocumentType  classification
     */
    public SetDocumentType deleteSetDocumentTypeClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteSetDocumentTypeClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       SetDocumentType declassifiedSetDocumentType =  SetDocumentTypeMapper.mapOmrsEntityDetailToSetDocumentType(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedSetDocumentType;
    }

    /**
      * Get the relationships associated with entity setDocumentType represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the setDocumentType
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getSetDocumentTypeRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getSetDocumentTypeRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an projectManager given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the projectManagers relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return ProjectManager the ProjectManager entity with the requested GUID
     */
    public ProjectManager getProjectManager(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getProjectManager";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        ProjectManager gotprojectManager = ProjectManagerMapper.mapOmrsEntityDetailToProjectManager(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotprojectManager );
        }
        return gotprojectManager;

    }
    /**
     * Create new projectManager.
     * @param userId user identity
     * @param projectManager the input entity with values.
     * @return ProjectManager the created entity.
     */

    public ProjectManager createProjectManager(String userId,ProjectManager projectManager)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createProjectManager";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = ProjectManagerMapper.mapProjectManagerToOmrsEntityDetail(projectManager);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        ProjectManager createdProjectManager =  ProjectManagerMapper.mapOmrsEntityDetailToProjectManager(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created ProjectManager="+ createdProjectManager );
        }
        return createdProjectManager;
    }
    /**
     * Update projectManager
     * @param userId user identity
     * @param projectManager   projectManager to update
     * @return ProjectManager the updated projectManager entity
     */
    public ProjectManager updateProjectManager(String userId, ProjectManager projectManager)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateProjectManager";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = ProjectManagerMapper.mapProjectManagerToOmrsEntityDetail(projectManager);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            ProjectManager updatedProjectManager =  ProjectManagerMapper.mapOmrsEntityDetailToProjectManager(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated ProjectManager="+ updatedProjectManager );
            }
            return updatedProjectManager;
        }

    /**
     * Delete an projectManager identified by its GUID. Delete is a soft delete, this means that the projectManager has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the projectManager
     * @return ProjectManager the deleted ProjectManager entity
     */

    public ProjectManager deleteProjectManager(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteProjectManager";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ProjectManager type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ProjectManager");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"ProjectManager",entityDef.getGUID(),entityGuid);
         ProjectManager deletedProjectManager = ProjectManagerMapper.mapOmrsEntityDetailToProjectManager(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedProjectManager;

    }
    /**
     * Purge an projectManager identified by its GUID. Delete is a hard delete, this means that the projectManager is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the projectManager
     */
    public void purgeProjectManager(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeProjectManager";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ProjectManager type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ProjectManager");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"ProjectManager",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an ProjectManager identified by its GUID. Restore resurrects a soft deleted ProjectManager. When a ProjectManager was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the ProjectManager
     * @return  ProjectManager the restored ProjectManager
     */
    public ProjectManager restoreProjectManager(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreProjectManager";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        ProjectManager restoredProjectManager =  ProjectManagerMapper.mapOmrsEntityDetailToProjectManager(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredProjectManager;
    }    

    /**
     * Add classifications to the supplied projectManager
     * @param userId user identity
     * @param entityGuid the GUID value for projectManager
     * @param classifications the classifications to apply.
     * @return the projectManager entity that has been classified
     */
     public ProjectManager addProjectManagerClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addProjectManagerClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         ProjectManager projectManagerClassificationBeans = ProjectManagerMapper.mapOmrsEntityDetailToProjectManager(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified ProjectManager=" +  projectManagerClassificationBeans);
         }
         return  projectManagerClassificationBeans;
    }

    /**
     * Updates classifications to an existing projectManager represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the projectManager
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given projectManager guid
     */
    public ProjectManager updateProjectManagerClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateProjectManagerClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           ProjectManager  projectManagerClassificationBeans = ProjectManagerMapper.mapOmrsEntityDetailToProjectManager(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  projectManagerClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing projectManager represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the projectManager
     * @param name name of the classification
     * @return deleted ProjectManager  classification
     */
    public ProjectManager deleteProjectManagerClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteProjectManagerClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       ProjectManager declassifiedProjectManager =  ProjectManagerMapper.mapOmrsEntityDetailToProjectManager(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedProjectManager;
    }

    /**
      * Get the relationships associated with entity projectManager represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the projectManager
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getProjectManagerRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getProjectManagerRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an dataSourceMeasurementAnnotation given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the dataSourceMeasurementAnnotations relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return DataSourceMeasurementAnnotation the DataSourceMeasurementAnnotation entity with the requested GUID
     */
    public DataSourceMeasurementAnnotation getDataSourceMeasurementAnnotation(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getDataSourceMeasurementAnnotation";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        DataSourceMeasurementAnnotation gotdataSourceMeasurementAnnotation = DataSourceMeasurementAnnotationMapper.mapOmrsEntityDetailToDataSourceMeasurementAnnotation(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotdataSourceMeasurementAnnotation );
        }
        return gotdataSourceMeasurementAnnotation;

    }
    /**
     * Create new dataSourceMeasurementAnnotation.
     * @param userId user identity
     * @param dataSourceMeasurementAnnotation the input entity with values.
     * @return DataSourceMeasurementAnnotation the created entity.
     */

    public DataSourceMeasurementAnnotation createDataSourceMeasurementAnnotation(String userId,DataSourceMeasurementAnnotation dataSourceMeasurementAnnotation)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createDataSourceMeasurementAnnotation";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = DataSourceMeasurementAnnotationMapper.mapDataSourceMeasurementAnnotationToOmrsEntityDetail(dataSourceMeasurementAnnotation);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        DataSourceMeasurementAnnotation createdDataSourceMeasurementAnnotation =  DataSourceMeasurementAnnotationMapper.mapOmrsEntityDetailToDataSourceMeasurementAnnotation(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created DataSourceMeasurementAnnotation="+ createdDataSourceMeasurementAnnotation );
        }
        return createdDataSourceMeasurementAnnotation;
    }
    /**
     * Update dataSourceMeasurementAnnotation
     * @param userId user identity
     * @param dataSourceMeasurementAnnotation   dataSourceMeasurementAnnotation to update
     * @return DataSourceMeasurementAnnotation the updated dataSourceMeasurementAnnotation entity
     */
    public DataSourceMeasurementAnnotation updateDataSourceMeasurementAnnotation(String userId, DataSourceMeasurementAnnotation dataSourceMeasurementAnnotation)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateDataSourceMeasurementAnnotation";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = DataSourceMeasurementAnnotationMapper.mapDataSourceMeasurementAnnotationToOmrsEntityDetail(dataSourceMeasurementAnnotation);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            DataSourceMeasurementAnnotation updatedDataSourceMeasurementAnnotation =  DataSourceMeasurementAnnotationMapper.mapOmrsEntityDetailToDataSourceMeasurementAnnotation(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated DataSourceMeasurementAnnotation="+ updatedDataSourceMeasurementAnnotation );
            }
            return updatedDataSourceMeasurementAnnotation;
        }

    /**
     * Delete an dataSourceMeasurementAnnotation identified by its GUID. Delete is a soft delete, this means that the dataSourceMeasurementAnnotation has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the dataSourceMeasurementAnnotation
     * @return DataSourceMeasurementAnnotation the deleted DataSourceMeasurementAnnotation entity
     */

    public DataSourceMeasurementAnnotation deleteDataSourceMeasurementAnnotation(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteDataSourceMeasurementAnnotation";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DataSourceMeasurementAnnotation type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DataSourceMeasurementAnnotation");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"DataSourceMeasurementAnnotation",entityDef.getGUID(),entityGuid);
         DataSourceMeasurementAnnotation deletedDataSourceMeasurementAnnotation = DataSourceMeasurementAnnotationMapper.mapOmrsEntityDetailToDataSourceMeasurementAnnotation(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedDataSourceMeasurementAnnotation;

    }
    /**
     * Purge an dataSourceMeasurementAnnotation identified by its GUID. Delete is a hard delete, this means that the dataSourceMeasurementAnnotation is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the dataSourceMeasurementAnnotation
     */
    public void purgeDataSourceMeasurementAnnotation(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeDataSourceMeasurementAnnotation";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DataSourceMeasurementAnnotation type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DataSourceMeasurementAnnotation");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"DataSourceMeasurementAnnotation",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an DataSourceMeasurementAnnotation identified by its GUID. Restore resurrects a soft deleted DataSourceMeasurementAnnotation. When a DataSourceMeasurementAnnotation was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the DataSourceMeasurementAnnotation
     * @return  DataSourceMeasurementAnnotation the restored DataSourceMeasurementAnnotation
     */
    public DataSourceMeasurementAnnotation restoreDataSourceMeasurementAnnotation(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreDataSourceMeasurementAnnotation";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        DataSourceMeasurementAnnotation restoredDataSourceMeasurementAnnotation =  DataSourceMeasurementAnnotationMapper.mapOmrsEntityDetailToDataSourceMeasurementAnnotation(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredDataSourceMeasurementAnnotation;
    }    

    /**
     * Add classifications to the supplied dataSourceMeasurementAnnotation
     * @param userId user identity
     * @param entityGuid the GUID value for dataSourceMeasurementAnnotation
     * @param classifications the classifications to apply.
     * @return the dataSourceMeasurementAnnotation entity that has been classified
     */
     public DataSourceMeasurementAnnotation addDataSourceMeasurementAnnotationClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addDataSourceMeasurementAnnotationClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         DataSourceMeasurementAnnotation dataSourceMeasurementAnnotationClassificationBeans = DataSourceMeasurementAnnotationMapper.mapOmrsEntityDetailToDataSourceMeasurementAnnotation(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified DataSourceMeasurementAnnotation=" +  dataSourceMeasurementAnnotationClassificationBeans);
         }
         return  dataSourceMeasurementAnnotationClassificationBeans;
    }

    /**
     * Updates classifications to an existing dataSourceMeasurementAnnotation represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the dataSourceMeasurementAnnotation
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given dataSourceMeasurementAnnotation guid
     */
    public DataSourceMeasurementAnnotation updateDataSourceMeasurementAnnotationClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateDataSourceMeasurementAnnotationClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           DataSourceMeasurementAnnotation  dataSourceMeasurementAnnotationClassificationBeans = DataSourceMeasurementAnnotationMapper.mapOmrsEntityDetailToDataSourceMeasurementAnnotation(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  dataSourceMeasurementAnnotationClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing dataSourceMeasurementAnnotation represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the dataSourceMeasurementAnnotation
     * @param name name of the classification
     * @return deleted DataSourceMeasurementAnnotation  classification
     */
    public DataSourceMeasurementAnnotation deleteDataSourceMeasurementAnnotationClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteDataSourceMeasurementAnnotationClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       DataSourceMeasurementAnnotation declassifiedDataSourceMeasurementAnnotation =  DataSourceMeasurementAnnotationMapper.mapOmrsEntityDetailToDataSourceMeasurementAnnotation(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedDataSourceMeasurementAnnotation;
    }

    /**
      * Get the relationships associated with entity dataSourceMeasurementAnnotation represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the dataSourceMeasurementAnnotation
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getDataSourceMeasurementAnnotationRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getDataSourceMeasurementAnnotationRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an propertyFacet given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the propertyFacets relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return PropertyFacet the PropertyFacet entity with the requested GUID
     */
    public PropertyFacet getPropertyFacet(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getPropertyFacet";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        PropertyFacet gotpropertyFacet = PropertyFacetMapper.mapOmrsEntityDetailToPropertyFacet(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotpropertyFacet );
        }
        return gotpropertyFacet;

    }
    /**
     * Create new propertyFacet.
     * @param userId user identity
     * @param propertyFacet the input entity with values.
     * @return PropertyFacet the created entity.
     */

    public PropertyFacet createPropertyFacet(String userId,PropertyFacet propertyFacet)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createPropertyFacet";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = PropertyFacetMapper.mapPropertyFacetToOmrsEntityDetail(propertyFacet);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        PropertyFacet createdPropertyFacet =  PropertyFacetMapper.mapOmrsEntityDetailToPropertyFacet(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created PropertyFacet="+ createdPropertyFacet );
        }
        return createdPropertyFacet;
    }
    /**
     * Update propertyFacet
     * @param userId user identity
     * @param propertyFacet   propertyFacet to update
     * @return PropertyFacet the updated propertyFacet entity
     */
    public PropertyFacet updatePropertyFacet(String userId, PropertyFacet propertyFacet)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updatePropertyFacet";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = PropertyFacetMapper.mapPropertyFacetToOmrsEntityDetail(propertyFacet);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            PropertyFacet updatedPropertyFacet =  PropertyFacetMapper.mapOmrsEntityDetailToPropertyFacet(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated PropertyFacet="+ updatedPropertyFacet );
            }
            return updatedPropertyFacet;
        }

    /**
     * Delete an propertyFacet identified by its GUID. Delete is a soft delete, this means that the propertyFacet has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the propertyFacet
     * @return PropertyFacet the deleted PropertyFacet entity
     */

    public PropertyFacet deletePropertyFacet(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deletePropertyFacet";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the PropertyFacet type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("PropertyFacet");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"PropertyFacet",entityDef.getGUID(),entityGuid);
         PropertyFacet deletedPropertyFacet = PropertyFacetMapper.mapOmrsEntityDetailToPropertyFacet(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedPropertyFacet;

    }
    /**
     * Purge an propertyFacet identified by its GUID. Delete is a hard delete, this means that the propertyFacet is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the propertyFacet
     */
    public void purgePropertyFacet(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgePropertyFacet";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the PropertyFacet type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("PropertyFacet");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"PropertyFacet",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an PropertyFacet identified by its GUID. Restore resurrects a soft deleted PropertyFacet. When a PropertyFacet was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the PropertyFacet
     * @return  PropertyFacet the restored PropertyFacet
     */
    public PropertyFacet restorePropertyFacet(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restorePropertyFacet";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        PropertyFacet restoredPropertyFacet =  PropertyFacetMapper.mapOmrsEntityDetailToPropertyFacet(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredPropertyFacet;
    }    

    /**
     * Add classifications to the supplied propertyFacet
     * @param userId user identity
     * @param entityGuid the GUID value for propertyFacet
     * @param classifications the classifications to apply.
     * @return the propertyFacet entity that has been classified
     */
     public PropertyFacet addPropertyFacetClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addPropertyFacetClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         PropertyFacet propertyFacetClassificationBeans = PropertyFacetMapper.mapOmrsEntityDetailToPropertyFacet(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified PropertyFacet=" +  propertyFacetClassificationBeans);
         }
         return  propertyFacetClassificationBeans;
    }

    /**
     * Updates classifications to an existing propertyFacet represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the propertyFacet
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given propertyFacet guid
     */
    public PropertyFacet updatePropertyFacetClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updatePropertyFacetClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           PropertyFacet  propertyFacetClassificationBeans = PropertyFacetMapper.mapOmrsEntityDetailToPropertyFacet(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  propertyFacetClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing propertyFacet represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the propertyFacet
     * @param name name of the classification
     * @return deleted PropertyFacet  classification
     */
    public PropertyFacet deletePropertyFacetClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deletePropertyFacetClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       PropertyFacet declassifiedPropertyFacet =  PropertyFacetMapper.mapOmrsEntityDetailToPropertyFacet(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedPropertyFacet;
    }

    /**
      * Get the relationships associated with entity propertyFacet represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the propertyFacet
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getPropertyFacetRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getPropertyFacetRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an referenceCodeTable given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the referenceCodeTables relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return ReferenceCodeTable the ReferenceCodeTable entity with the requested GUID
     */
    public ReferenceCodeTable getReferenceCodeTable(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getReferenceCodeTable";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        ReferenceCodeTable gotreferenceCodeTable = ReferenceCodeTableMapper.mapOmrsEntityDetailToReferenceCodeTable(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotreferenceCodeTable );
        }
        return gotreferenceCodeTable;

    }
    /**
     * Create new referenceCodeTable.
     * @param userId user identity
     * @param referenceCodeTable the input entity with values.
     * @return ReferenceCodeTable the created entity.
     */

    public ReferenceCodeTable createReferenceCodeTable(String userId,ReferenceCodeTable referenceCodeTable)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createReferenceCodeTable";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = ReferenceCodeTableMapper.mapReferenceCodeTableToOmrsEntityDetail(referenceCodeTable);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        ReferenceCodeTable createdReferenceCodeTable =  ReferenceCodeTableMapper.mapOmrsEntityDetailToReferenceCodeTable(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created ReferenceCodeTable="+ createdReferenceCodeTable );
        }
        return createdReferenceCodeTable;
    }
    /**
     * Update referenceCodeTable
     * @param userId user identity
     * @param referenceCodeTable   referenceCodeTable to update
     * @return ReferenceCodeTable the updated referenceCodeTable entity
     */
    public ReferenceCodeTable updateReferenceCodeTable(String userId, ReferenceCodeTable referenceCodeTable)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateReferenceCodeTable";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = ReferenceCodeTableMapper.mapReferenceCodeTableToOmrsEntityDetail(referenceCodeTable);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            ReferenceCodeTable updatedReferenceCodeTable =  ReferenceCodeTableMapper.mapOmrsEntityDetailToReferenceCodeTable(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated ReferenceCodeTable="+ updatedReferenceCodeTable );
            }
            return updatedReferenceCodeTable;
        }

    /**
     * Delete an referenceCodeTable identified by its GUID. Delete is a soft delete, this means that the referenceCodeTable has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the referenceCodeTable
     * @return ReferenceCodeTable the deleted ReferenceCodeTable entity
     */

    public ReferenceCodeTable deleteReferenceCodeTable(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteReferenceCodeTable";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ReferenceCodeTable type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ReferenceCodeTable");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"ReferenceCodeTable",entityDef.getGUID(),entityGuid);
         ReferenceCodeTable deletedReferenceCodeTable = ReferenceCodeTableMapper.mapOmrsEntityDetailToReferenceCodeTable(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedReferenceCodeTable;

    }
    /**
     * Purge an referenceCodeTable identified by its GUID. Delete is a hard delete, this means that the referenceCodeTable is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the referenceCodeTable
     */
    public void purgeReferenceCodeTable(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeReferenceCodeTable";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ReferenceCodeTable type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ReferenceCodeTable");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"ReferenceCodeTable",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an ReferenceCodeTable identified by its GUID. Restore resurrects a soft deleted ReferenceCodeTable. When a ReferenceCodeTable was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the ReferenceCodeTable
     * @return  ReferenceCodeTable the restored ReferenceCodeTable
     */
    public ReferenceCodeTable restoreReferenceCodeTable(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreReferenceCodeTable";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        ReferenceCodeTable restoredReferenceCodeTable =  ReferenceCodeTableMapper.mapOmrsEntityDetailToReferenceCodeTable(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredReferenceCodeTable;
    }    

    /**
     * Add classifications to the supplied referenceCodeTable
     * @param userId user identity
     * @param entityGuid the GUID value for referenceCodeTable
     * @param classifications the classifications to apply.
     * @return the referenceCodeTable entity that has been classified
     */
     public ReferenceCodeTable addReferenceCodeTableClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addReferenceCodeTableClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         ReferenceCodeTable referenceCodeTableClassificationBeans = ReferenceCodeTableMapper.mapOmrsEntityDetailToReferenceCodeTable(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified ReferenceCodeTable=" +  referenceCodeTableClassificationBeans);
         }
         return  referenceCodeTableClassificationBeans;
    }

    /**
     * Updates classifications to an existing referenceCodeTable represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the referenceCodeTable
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given referenceCodeTable guid
     */
    public ReferenceCodeTable updateReferenceCodeTableClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateReferenceCodeTableClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           ReferenceCodeTable  referenceCodeTableClassificationBeans = ReferenceCodeTableMapper.mapOmrsEntityDetailToReferenceCodeTable(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  referenceCodeTableClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing referenceCodeTable represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the referenceCodeTable
     * @param name name of the classification
     * @return deleted ReferenceCodeTable  classification
     */
    public ReferenceCodeTable deleteReferenceCodeTableClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteReferenceCodeTableClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       ReferenceCodeTable declassifiedReferenceCodeTable =  ReferenceCodeTableMapper.mapOmrsEntityDetailToReferenceCodeTable(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedReferenceCodeTable;
    }

    /**
      * Get the relationships associated with entity referenceCodeTable represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the referenceCodeTable
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getReferenceCodeTableRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getReferenceCodeTableRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an technicalControl given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the technicalControls relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return TechnicalControl the TechnicalControl entity with the requested GUID
     */
    public TechnicalControl getTechnicalControl(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getTechnicalControl";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        TechnicalControl gottechnicalControl = TechnicalControlMapper.mapOmrsEntityDetailToTechnicalControl(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gottechnicalControl );
        }
        return gottechnicalControl;

    }
    /**
     * Create new technicalControl.
     * @param userId user identity
     * @param technicalControl the input entity with values.
     * @return TechnicalControl the created entity.
     */

    public TechnicalControl createTechnicalControl(String userId,TechnicalControl technicalControl)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createTechnicalControl";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = TechnicalControlMapper.mapTechnicalControlToOmrsEntityDetail(technicalControl);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        TechnicalControl createdTechnicalControl =  TechnicalControlMapper.mapOmrsEntityDetailToTechnicalControl(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created TechnicalControl="+ createdTechnicalControl );
        }
        return createdTechnicalControl;
    }
    /**
     * Update technicalControl
     * @param userId user identity
     * @param technicalControl   technicalControl to update
     * @return TechnicalControl the updated technicalControl entity
     */
    public TechnicalControl updateTechnicalControl(String userId, TechnicalControl technicalControl)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateTechnicalControl";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = TechnicalControlMapper.mapTechnicalControlToOmrsEntityDetail(technicalControl);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            TechnicalControl updatedTechnicalControl =  TechnicalControlMapper.mapOmrsEntityDetailToTechnicalControl(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated TechnicalControl="+ updatedTechnicalControl );
            }
            return updatedTechnicalControl;
        }

    /**
     * Delete an technicalControl identified by its GUID. Delete is a soft delete, this means that the technicalControl has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the technicalControl
     * @return TechnicalControl the deleted TechnicalControl entity
     */

    public TechnicalControl deleteTechnicalControl(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteTechnicalControl";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the TechnicalControl type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("TechnicalControl");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"TechnicalControl",entityDef.getGUID(),entityGuid);
         TechnicalControl deletedTechnicalControl = TechnicalControlMapper.mapOmrsEntityDetailToTechnicalControl(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedTechnicalControl;

    }
    /**
     * Purge an technicalControl identified by its GUID. Delete is a hard delete, this means that the technicalControl is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the technicalControl
     */
    public void purgeTechnicalControl(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeTechnicalControl";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the TechnicalControl type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("TechnicalControl");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"TechnicalControl",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an TechnicalControl identified by its GUID. Restore resurrects a soft deleted TechnicalControl. When a TechnicalControl was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the TechnicalControl
     * @return  TechnicalControl the restored TechnicalControl
     */
    public TechnicalControl restoreTechnicalControl(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreTechnicalControl";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        TechnicalControl restoredTechnicalControl =  TechnicalControlMapper.mapOmrsEntityDetailToTechnicalControl(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredTechnicalControl;
    }    

    /**
     * Add classifications to the supplied technicalControl
     * @param userId user identity
     * @param entityGuid the GUID value for technicalControl
     * @param classifications the classifications to apply.
     * @return the technicalControl entity that has been classified
     */
     public TechnicalControl addTechnicalControlClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addTechnicalControlClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         TechnicalControl technicalControlClassificationBeans = TechnicalControlMapper.mapOmrsEntityDetailToTechnicalControl(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified TechnicalControl=" +  technicalControlClassificationBeans);
         }
         return  technicalControlClassificationBeans;
    }

    /**
     * Updates classifications to an existing technicalControl represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the technicalControl
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given technicalControl guid
     */
    public TechnicalControl updateTechnicalControlClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateTechnicalControlClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           TechnicalControl  technicalControlClassificationBeans = TechnicalControlMapper.mapOmrsEntityDetailToTechnicalControl(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  technicalControlClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing technicalControl represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the technicalControl
     * @param name name of the classification
     * @return deleted TechnicalControl  classification
     */
    public TechnicalControl deleteTechnicalControlClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteTechnicalControlClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       TechnicalControl declassifiedTechnicalControl =  TechnicalControlMapper.mapOmrsEntityDetailToTechnicalControl(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedTechnicalControl;
    }

    /**
      * Get the relationships associated with entity technicalControl represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the technicalControl
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getTechnicalControlRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getTechnicalControlRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an graphSchemaType given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the graphSchemaTypes relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return GraphSchemaType the GraphSchemaType entity with the requested GUID
     */
    public GraphSchemaType getGraphSchemaType(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getGraphSchemaType";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        GraphSchemaType gotgraphSchemaType = GraphSchemaTypeMapper.mapOmrsEntityDetailToGraphSchemaType(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotgraphSchemaType );
        }
        return gotgraphSchemaType;

    }
    /**
     * Create new graphSchemaType.
     * @param userId user identity
     * @param graphSchemaType the input entity with values.
     * @return GraphSchemaType the created entity.
     */

    public GraphSchemaType createGraphSchemaType(String userId,GraphSchemaType graphSchemaType)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createGraphSchemaType";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = GraphSchemaTypeMapper.mapGraphSchemaTypeToOmrsEntityDetail(graphSchemaType);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        GraphSchemaType createdGraphSchemaType =  GraphSchemaTypeMapper.mapOmrsEntityDetailToGraphSchemaType(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created GraphSchemaType="+ createdGraphSchemaType );
        }
        return createdGraphSchemaType;
    }
    /**
     * Update graphSchemaType
     * @param userId user identity
     * @param graphSchemaType   graphSchemaType to update
     * @return GraphSchemaType the updated graphSchemaType entity
     */
    public GraphSchemaType updateGraphSchemaType(String userId, GraphSchemaType graphSchemaType)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateGraphSchemaType";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = GraphSchemaTypeMapper.mapGraphSchemaTypeToOmrsEntityDetail(graphSchemaType);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            GraphSchemaType updatedGraphSchemaType =  GraphSchemaTypeMapper.mapOmrsEntityDetailToGraphSchemaType(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated GraphSchemaType="+ updatedGraphSchemaType );
            }
            return updatedGraphSchemaType;
        }

    /**
     * Delete an graphSchemaType identified by its GUID. Delete is a soft delete, this means that the graphSchemaType has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the graphSchemaType
     * @return GraphSchemaType the deleted GraphSchemaType entity
     */

    public GraphSchemaType deleteGraphSchemaType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteGraphSchemaType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GraphSchemaType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GraphSchemaType");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"GraphSchemaType",entityDef.getGUID(),entityGuid);
         GraphSchemaType deletedGraphSchemaType = GraphSchemaTypeMapper.mapOmrsEntityDetailToGraphSchemaType(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedGraphSchemaType;

    }
    /**
     * Purge an graphSchemaType identified by its GUID. Delete is a hard delete, this means that the graphSchemaType is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the graphSchemaType
     */
    public void purgeGraphSchemaType(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeGraphSchemaType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GraphSchemaType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GraphSchemaType");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"GraphSchemaType",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an GraphSchemaType identified by its GUID. Restore resurrects a soft deleted GraphSchemaType. When a GraphSchemaType was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the GraphSchemaType
     * @return  GraphSchemaType the restored GraphSchemaType
     */
    public GraphSchemaType restoreGraphSchemaType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreGraphSchemaType";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        GraphSchemaType restoredGraphSchemaType =  GraphSchemaTypeMapper.mapOmrsEntityDetailToGraphSchemaType(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredGraphSchemaType;
    }    

    /**
     * Add classifications to the supplied graphSchemaType
     * @param userId user identity
     * @param entityGuid the GUID value for graphSchemaType
     * @param classifications the classifications to apply.
     * @return the graphSchemaType entity that has been classified
     */
     public GraphSchemaType addGraphSchemaTypeClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addGraphSchemaTypeClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         GraphSchemaType graphSchemaTypeClassificationBeans = GraphSchemaTypeMapper.mapOmrsEntityDetailToGraphSchemaType(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified GraphSchemaType=" +  graphSchemaTypeClassificationBeans);
         }
         return  graphSchemaTypeClassificationBeans;
    }

    /**
     * Updates classifications to an existing graphSchemaType represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the graphSchemaType
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given graphSchemaType guid
     */
    public GraphSchemaType updateGraphSchemaTypeClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateGraphSchemaTypeClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           GraphSchemaType  graphSchemaTypeClassificationBeans = GraphSchemaTypeMapper.mapOmrsEntityDetailToGraphSchemaType(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  graphSchemaTypeClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing graphSchemaType represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the graphSchemaType
     * @param name name of the classification
     * @return deleted GraphSchemaType  classification
     */
    public GraphSchemaType deleteGraphSchemaTypeClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteGraphSchemaTypeClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       GraphSchemaType declassifiedGraphSchemaType =  GraphSchemaTypeMapper.mapOmrsEntityDetailToGraphSchemaType(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedGraphSchemaType;
    }

    /**
      * Get the relationships associated with entity graphSchemaType represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the graphSchemaType
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getGraphSchemaTypeRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getGraphSchemaTypeRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an glossary given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the glossaries relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return Glossary the Glossary entity with the requested GUID
     */
    public Glossary getGlossary(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getGlossary";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        Glossary gotglossary = GlossaryMapper.mapOmrsEntityDetailToGlossary(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotglossary );
        }
        return gotglossary;

    }
    /**
     * Create new glossary.
     * @param userId user identity
     * @param glossary the input entity with values.
     * @return Glossary the created entity.
     */

    public Glossary createGlossary(String userId,Glossary glossary)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createGlossary";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = GlossaryMapper.mapGlossaryToOmrsEntityDetail(glossary);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        Glossary createdGlossary =  GlossaryMapper.mapOmrsEntityDetailToGlossary(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created Glossary="+ createdGlossary );
        }
        return createdGlossary;
    }
    /**
     * Update glossary
     * @param userId user identity
     * @param glossary   glossary to update
     * @return Glossary the updated glossary entity
     */
    public Glossary updateGlossary(String userId, Glossary glossary)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateGlossary";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = GlossaryMapper.mapGlossaryToOmrsEntityDetail(glossary);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            Glossary updatedGlossary =  GlossaryMapper.mapOmrsEntityDetailToGlossary(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated Glossary="+ updatedGlossary );
            }
            return updatedGlossary;
        }

    /**
     * Delete an glossary identified by its GUID. Delete is a soft delete, this means that the glossary has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the glossary
     * @return Glossary the deleted Glossary entity
     */

    public Glossary deleteGlossary(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteGlossary";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Glossary type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Glossary");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"Glossary",entityDef.getGUID(),entityGuid);
         Glossary deletedGlossary = GlossaryMapper.mapOmrsEntityDetailToGlossary(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedGlossary;

    }
    /**
     * Purge an glossary identified by its GUID. Delete is a hard delete, this means that the glossary is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the glossary
     */
    public void purgeGlossary(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeGlossary";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Glossary type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Glossary");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"Glossary",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an Glossary identified by its GUID. Restore resurrects a soft deleted Glossary. When a Glossary was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the Glossary
     * @return  Glossary the restored Glossary
     */
    public Glossary restoreGlossary(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreGlossary";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        Glossary restoredGlossary =  GlossaryMapper.mapOmrsEntityDetailToGlossary(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredGlossary;
    }    

    /**
     * Add classifications to the supplied glossary
     * @param userId user identity
     * @param entityGuid the GUID value for glossary
     * @param classifications the classifications to apply.
     * @return the glossary entity that has been classified
     */
     public Glossary addGlossaryClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addGlossaryClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         Glossary glossaryClassificationBeans = GlossaryMapper.mapOmrsEntityDetailToGlossary(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified Glossary=" +  glossaryClassificationBeans);
         }
         return  glossaryClassificationBeans;
    }

    /**
     * Updates classifications to an existing glossary represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the glossary
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given glossary guid
     */
    public Glossary updateGlossaryClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateGlossaryClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           Glossary  glossaryClassificationBeans = GlossaryMapper.mapOmrsEntityDetailToGlossary(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  glossaryClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing glossary represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the glossary
     * @param name name of the classification
     * @return deleted Glossary  classification
     */
    public Glossary deleteGlossaryClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteGlossaryClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       Glossary declassifiedGlossary =  GlossaryMapper.mapOmrsEntityDetailToGlossary(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedGlossary;
    }

    /**
      * Get the relationships associated with entity glossary represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the glossary
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getGlossaryRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getGlossaryRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an simpleDocumentType given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the simpleDocumentTypes relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return SimpleDocumentType the SimpleDocumentType entity with the requested GUID
     */
    public SimpleDocumentType getSimpleDocumentType(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getSimpleDocumentType";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        SimpleDocumentType gotsimpleDocumentType = SimpleDocumentTypeMapper.mapOmrsEntityDetailToSimpleDocumentType(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotsimpleDocumentType );
        }
        return gotsimpleDocumentType;

    }
    /**
     * Create new simpleDocumentType.
     * @param userId user identity
     * @param simpleDocumentType the input entity with values.
     * @return SimpleDocumentType the created entity.
     */

    public SimpleDocumentType createSimpleDocumentType(String userId,SimpleDocumentType simpleDocumentType)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createSimpleDocumentType";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = SimpleDocumentTypeMapper.mapSimpleDocumentTypeToOmrsEntityDetail(simpleDocumentType);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        SimpleDocumentType createdSimpleDocumentType =  SimpleDocumentTypeMapper.mapOmrsEntityDetailToSimpleDocumentType(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created SimpleDocumentType="+ createdSimpleDocumentType );
        }
        return createdSimpleDocumentType;
    }
    /**
     * Update simpleDocumentType
     * @param userId user identity
     * @param simpleDocumentType   simpleDocumentType to update
     * @return SimpleDocumentType the updated simpleDocumentType entity
     */
    public SimpleDocumentType updateSimpleDocumentType(String userId, SimpleDocumentType simpleDocumentType)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateSimpleDocumentType";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = SimpleDocumentTypeMapper.mapSimpleDocumentTypeToOmrsEntityDetail(simpleDocumentType);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            SimpleDocumentType updatedSimpleDocumentType =  SimpleDocumentTypeMapper.mapOmrsEntityDetailToSimpleDocumentType(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated SimpleDocumentType="+ updatedSimpleDocumentType );
            }
            return updatedSimpleDocumentType;
        }

    /**
     * Delete an simpleDocumentType identified by its GUID. Delete is a soft delete, this means that the simpleDocumentType has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the simpleDocumentType
     * @return SimpleDocumentType the deleted SimpleDocumentType entity
     */

    public SimpleDocumentType deleteSimpleDocumentType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteSimpleDocumentType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the SimpleDocumentType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("SimpleDocumentType");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"SimpleDocumentType",entityDef.getGUID(),entityGuid);
         SimpleDocumentType deletedSimpleDocumentType = SimpleDocumentTypeMapper.mapOmrsEntityDetailToSimpleDocumentType(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedSimpleDocumentType;

    }
    /**
     * Purge an simpleDocumentType identified by its GUID. Delete is a hard delete, this means that the simpleDocumentType is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the simpleDocumentType
     */
    public void purgeSimpleDocumentType(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeSimpleDocumentType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the SimpleDocumentType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("SimpleDocumentType");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"SimpleDocumentType",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an SimpleDocumentType identified by its GUID. Restore resurrects a soft deleted SimpleDocumentType. When a SimpleDocumentType was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the SimpleDocumentType
     * @return  SimpleDocumentType the restored SimpleDocumentType
     */
    public SimpleDocumentType restoreSimpleDocumentType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreSimpleDocumentType";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        SimpleDocumentType restoredSimpleDocumentType =  SimpleDocumentTypeMapper.mapOmrsEntityDetailToSimpleDocumentType(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredSimpleDocumentType;
    }    

    /**
     * Add classifications to the supplied simpleDocumentType
     * @param userId user identity
     * @param entityGuid the GUID value for simpleDocumentType
     * @param classifications the classifications to apply.
     * @return the simpleDocumentType entity that has been classified
     */
     public SimpleDocumentType addSimpleDocumentTypeClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addSimpleDocumentTypeClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         SimpleDocumentType simpleDocumentTypeClassificationBeans = SimpleDocumentTypeMapper.mapOmrsEntityDetailToSimpleDocumentType(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified SimpleDocumentType=" +  simpleDocumentTypeClassificationBeans);
         }
         return  simpleDocumentTypeClassificationBeans;
    }

    /**
     * Updates classifications to an existing simpleDocumentType represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the simpleDocumentType
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given simpleDocumentType guid
     */
    public SimpleDocumentType updateSimpleDocumentTypeClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateSimpleDocumentTypeClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           SimpleDocumentType  simpleDocumentTypeClassificationBeans = SimpleDocumentTypeMapper.mapOmrsEntityDetailToSimpleDocumentType(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  simpleDocumentTypeClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing simpleDocumentType represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the simpleDocumentType
     * @param name name of the classification
     * @return deleted SimpleDocumentType  classification
     */
    public SimpleDocumentType deleteSimpleDocumentTypeClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteSimpleDocumentTypeClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       SimpleDocumentType declassifiedSimpleDocumentType =  SimpleDocumentTypeMapper.mapOmrsEntityDetailToSimpleDocumentType(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedSimpleDocumentType;
    }

    /**
      * Get the relationships associated with entity simpleDocumentType represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the simpleDocumentType
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getSimpleDocumentTypeRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getSimpleDocumentTypeRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an annotationReview given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the annotationReviews relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return AnnotationReview the AnnotationReview entity with the requested GUID
     */
    public AnnotationReview getAnnotationReview(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getAnnotationReview";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        AnnotationReview gotannotationReview = AnnotationReviewMapper.mapOmrsEntityDetailToAnnotationReview(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotannotationReview );
        }
        return gotannotationReview;

    }
    /**
     * Create new annotationReview.
     * @param userId user identity
     * @param annotationReview the input entity with values.
     * @return AnnotationReview the created entity.
     */

    public AnnotationReview createAnnotationReview(String userId,AnnotationReview annotationReview)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createAnnotationReview";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = AnnotationReviewMapper.mapAnnotationReviewToOmrsEntityDetail(annotationReview);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        AnnotationReview createdAnnotationReview =  AnnotationReviewMapper.mapOmrsEntityDetailToAnnotationReview(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created AnnotationReview="+ createdAnnotationReview );
        }
        return createdAnnotationReview;
    }
    /**
     * Update annotationReview
     * @param userId user identity
     * @param annotationReview   annotationReview to update
     * @return AnnotationReview the updated annotationReview entity
     */
    public AnnotationReview updateAnnotationReview(String userId, AnnotationReview annotationReview)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateAnnotationReview";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = AnnotationReviewMapper.mapAnnotationReviewToOmrsEntityDetail(annotationReview);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            AnnotationReview updatedAnnotationReview =  AnnotationReviewMapper.mapOmrsEntityDetailToAnnotationReview(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated AnnotationReview="+ updatedAnnotationReview );
            }
            return updatedAnnotationReview;
        }

    /**
     * Delete an annotationReview identified by its GUID. Delete is a soft delete, this means that the annotationReview has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the annotationReview
     * @return AnnotationReview the deleted AnnotationReview entity
     */

    public AnnotationReview deleteAnnotationReview(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteAnnotationReview";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the AnnotationReview type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("AnnotationReview");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"AnnotationReview",entityDef.getGUID(),entityGuid);
         AnnotationReview deletedAnnotationReview = AnnotationReviewMapper.mapOmrsEntityDetailToAnnotationReview(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedAnnotationReview;

    }
    /**
     * Purge an annotationReview identified by its GUID. Delete is a hard delete, this means that the annotationReview is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the annotationReview
     */
    public void purgeAnnotationReview(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeAnnotationReview";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the AnnotationReview type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("AnnotationReview");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"AnnotationReview",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an AnnotationReview identified by its GUID. Restore resurrects a soft deleted AnnotationReview. When a AnnotationReview was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the AnnotationReview
     * @return  AnnotationReview the restored AnnotationReview
     */
    public AnnotationReview restoreAnnotationReview(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreAnnotationReview";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        AnnotationReview restoredAnnotationReview =  AnnotationReviewMapper.mapOmrsEntityDetailToAnnotationReview(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredAnnotationReview;
    }    

    /**
     * Add classifications to the supplied annotationReview
     * @param userId user identity
     * @param entityGuid the GUID value for annotationReview
     * @param classifications the classifications to apply.
     * @return the annotationReview entity that has been classified
     */
     public AnnotationReview addAnnotationReviewClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addAnnotationReviewClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         AnnotationReview annotationReviewClassificationBeans = AnnotationReviewMapper.mapOmrsEntityDetailToAnnotationReview(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified AnnotationReview=" +  annotationReviewClassificationBeans);
         }
         return  annotationReviewClassificationBeans;
    }

    /**
     * Updates classifications to an existing annotationReview represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the annotationReview
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given annotationReview guid
     */
    public AnnotationReview updateAnnotationReviewClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateAnnotationReviewClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           AnnotationReview  annotationReviewClassificationBeans = AnnotationReviewMapper.mapOmrsEntityDetailToAnnotationReview(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  annotationReviewClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing annotationReview represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the annotationReview
     * @param name name of the classification
     * @return deleted AnnotationReview  classification
     */
    public AnnotationReview deleteAnnotationReviewClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteAnnotationReviewClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       AnnotationReview declassifiedAnnotationReview =  AnnotationReviewMapper.mapOmrsEntityDetailToAnnotationReview(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedAnnotationReview;
    }

    /**
      * Get the relationships associated with entity annotationReview represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the annotationReview
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getAnnotationReviewRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getAnnotationReviewRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an mediaCollection given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the mediaCollections relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return MediaCollection the MediaCollection entity with the requested GUID
     */
    public MediaCollection getMediaCollection(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getMediaCollection";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        MediaCollection gotmediaCollection = MediaCollectionMapper.mapOmrsEntityDetailToMediaCollection(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotmediaCollection );
        }
        return gotmediaCollection;

    }
    /**
     * Create new mediaCollection.
     * @param userId user identity
     * @param mediaCollection the input entity with values.
     * @return MediaCollection the created entity.
     */

    public MediaCollection createMediaCollection(String userId,MediaCollection mediaCollection)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createMediaCollection";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = MediaCollectionMapper.mapMediaCollectionToOmrsEntityDetail(mediaCollection);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        MediaCollection createdMediaCollection =  MediaCollectionMapper.mapOmrsEntityDetailToMediaCollection(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created MediaCollection="+ createdMediaCollection );
        }
        return createdMediaCollection;
    }
    /**
     * Update mediaCollection
     * @param userId user identity
     * @param mediaCollection   mediaCollection to update
     * @return MediaCollection the updated mediaCollection entity
     */
    public MediaCollection updateMediaCollection(String userId, MediaCollection mediaCollection)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateMediaCollection";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = MediaCollectionMapper.mapMediaCollectionToOmrsEntityDetail(mediaCollection);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            MediaCollection updatedMediaCollection =  MediaCollectionMapper.mapOmrsEntityDetailToMediaCollection(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated MediaCollection="+ updatedMediaCollection );
            }
            return updatedMediaCollection;
        }

    /**
     * Delete an mediaCollection identified by its GUID. Delete is a soft delete, this means that the mediaCollection has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the mediaCollection
     * @return MediaCollection the deleted MediaCollection entity
     */

    public MediaCollection deleteMediaCollection(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteMediaCollection";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the MediaCollection type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("MediaCollection");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"MediaCollection",entityDef.getGUID(),entityGuid);
         MediaCollection deletedMediaCollection = MediaCollectionMapper.mapOmrsEntityDetailToMediaCollection(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedMediaCollection;

    }
    /**
     * Purge an mediaCollection identified by its GUID. Delete is a hard delete, this means that the mediaCollection is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the mediaCollection
     */
    public void purgeMediaCollection(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeMediaCollection";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the MediaCollection type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("MediaCollection");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"MediaCollection",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an MediaCollection identified by its GUID. Restore resurrects a soft deleted MediaCollection. When a MediaCollection was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the MediaCollection
     * @return  MediaCollection the restored MediaCollection
     */
    public MediaCollection restoreMediaCollection(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreMediaCollection";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        MediaCollection restoredMediaCollection =  MediaCollectionMapper.mapOmrsEntityDetailToMediaCollection(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredMediaCollection;
    }    

    /**
     * Add classifications to the supplied mediaCollection
     * @param userId user identity
     * @param entityGuid the GUID value for mediaCollection
     * @param classifications the classifications to apply.
     * @return the mediaCollection entity that has been classified
     */
     public MediaCollection addMediaCollectionClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addMediaCollectionClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         MediaCollection mediaCollectionClassificationBeans = MediaCollectionMapper.mapOmrsEntityDetailToMediaCollection(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified MediaCollection=" +  mediaCollectionClassificationBeans);
         }
         return  mediaCollectionClassificationBeans;
    }

    /**
     * Updates classifications to an existing mediaCollection represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the mediaCollection
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given mediaCollection guid
     */
    public MediaCollection updateMediaCollectionClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateMediaCollectionClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           MediaCollection  mediaCollectionClassificationBeans = MediaCollectionMapper.mapOmrsEntityDetailToMediaCollection(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  mediaCollectionClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing mediaCollection represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the mediaCollection
     * @param name name of the classification
     * @return deleted MediaCollection  classification
     */
    public MediaCollection deleteMediaCollectionClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteMediaCollectionClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       MediaCollection declassifiedMediaCollection =  MediaCollectionMapper.mapOmrsEntityDetailToMediaCollection(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedMediaCollection;
    }

    /**
      * Get the relationships associated with entity mediaCollection represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the mediaCollection
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getMediaCollectionRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getMediaCollectionRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an collection given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the collections relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return Collection the Collection entity with the requested GUID
     */
    public Collection getCollection(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getCollection";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        Collection gotcollection = CollectionMapper.mapOmrsEntityDetailToCollection(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotcollection );
        }
        return gotcollection;

    }
    /**
     * Create new collection.
     * @param userId user identity
     * @param collection the input entity with values.
     * @return Collection the created entity.
     */

    public Collection createCollection(String userId,Collection collection)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createCollection";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = CollectionMapper.mapCollectionToOmrsEntityDetail(collection);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        Collection createdCollection =  CollectionMapper.mapOmrsEntityDetailToCollection(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created Collection="+ createdCollection );
        }
        return createdCollection;
    }
    /**
     * Update collection
     * @param userId user identity
     * @param collection   collection to update
     * @return Collection the updated collection entity
     */
    public Collection updateCollection(String userId, Collection collection)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateCollection";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = CollectionMapper.mapCollectionToOmrsEntityDetail(collection);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            Collection updatedCollection =  CollectionMapper.mapOmrsEntityDetailToCollection(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated Collection="+ updatedCollection );
            }
            return updatedCollection;
        }

    /**
     * Delete an collection identified by its GUID. Delete is a soft delete, this means that the collection has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the collection
     * @return Collection the deleted Collection entity
     */

    public Collection deleteCollection(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteCollection";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Collection type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Collection");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"Collection",entityDef.getGUID(),entityGuid);
         Collection deletedCollection = CollectionMapper.mapOmrsEntityDetailToCollection(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedCollection;

    }
    /**
     * Purge an collection identified by its GUID. Delete is a hard delete, this means that the collection is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the collection
     */
    public void purgeCollection(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeCollection";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Collection type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Collection");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"Collection",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an Collection identified by its GUID. Restore resurrects a soft deleted Collection. When a Collection was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the Collection
     * @return  Collection the restored Collection
     */
    public Collection restoreCollection(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreCollection";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        Collection restoredCollection =  CollectionMapper.mapOmrsEntityDetailToCollection(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredCollection;
    }    

    /**
     * Add classifications to the supplied collection
     * @param userId user identity
     * @param entityGuid the GUID value for collection
     * @param classifications the classifications to apply.
     * @return the collection entity that has been classified
     */
     public Collection addCollectionClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addCollectionClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         Collection collectionClassificationBeans = CollectionMapper.mapOmrsEntityDetailToCollection(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified Collection=" +  collectionClassificationBeans);
         }
         return  collectionClassificationBeans;
    }

    /**
     * Updates classifications to an existing collection represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the collection
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given collection guid
     */
    public Collection updateCollectionClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateCollectionClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           Collection  collectionClassificationBeans = CollectionMapper.mapOmrsEntityDetailToCollection(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  collectionClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing collection represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the collection
     * @param name name of the classification
     * @return deleted Collection  classification
     */
    public Collection deleteCollectionClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteCollectionClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       Collection declassifiedCollection =  CollectionMapper.mapOmrsEntityDetailToCollection(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedCollection;
    }

    /**
      * Get the relationships associated with entity collection represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the collection
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getCollectionRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getCollectionRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an tabularSchemaType given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the tabularSchemaTypes relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return TabularSchemaType the TabularSchemaType entity with the requested GUID
     */
    public TabularSchemaType getTabularSchemaType(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getTabularSchemaType";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        TabularSchemaType gottabularSchemaType = TabularSchemaTypeMapper.mapOmrsEntityDetailToTabularSchemaType(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gottabularSchemaType );
        }
        return gottabularSchemaType;

    }
    /**
     * Create new tabularSchemaType.
     * @param userId user identity
     * @param tabularSchemaType the input entity with values.
     * @return TabularSchemaType the created entity.
     */

    public TabularSchemaType createTabularSchemaType(String userId,TabularSchemaType tabularSchemaType)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createTabularSchemaType";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = TabularSchemaTypeMapper.mapTabularSchemaTypeToOmrsEntityDetail(tabularSchemaType);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        TabularSchemaType createdTabularSchemaType =  TabularSchemaTypeMapper.mapOmrsEntityDetailToTabularSchemaType(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created TabularSchemaType="+ createdTabularSchemaType );
        }
        return createdTabularSchemaType;
    }
    /**
     * Update tabularSchemaType
     * @param userId user identity
     * @param tabularSchemaType   tabularSchemaType to update
     * @return TabularSchemaType the updated tabularSchemaType entity
     */
    public TabularSchemaType updateTabularSchemaType(String userId, TabularSchemaType tabularSchemaType)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateTabularSchemaType";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = TabularSchemaTypeMapper.mapTabularSchemaTypeToOmrsEntityDetail(tabularSchemaType);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            TabularSchemaType updatedTabularSchemaType =  TabularSchemaTypeMapper.mapOmrsEntityDetailToTabularSchemaType(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated TabularSchemaType="+ updatedTabularSchemaType );
            }
            return updatedTabularSchemaType;
        }

    /**
     * Delete an tabularSchemaType identified by its GUID. Delete is a soft delete, this means that the tabularSchemaType has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the tabularSchemaType
     * @return TabularSchemaType the deleted TabularSchemaType entity
     */

    public TabularSchemaType deleteTabularSchemaType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteTabularSchemaType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the TabularSchemaType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("TabularSchemaType");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"TabularSchemaType",entityDef.getGUID(),entityGuid);
         TabularSchemaType deletedTabularSchemaType = TabularSchemaTypeMapper.mapOmrsEntityDetailToTabularSchemaType(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedTabularSchemaType;

    }
    /**
     * Purge an tabularSchemaType identified by its GUID. Delete is a hard delete, this means that the tabularSchemaType is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the tabularSchemaType
     */
    public void purgeTabularSchemaType(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeTabularSchemaType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the TabularSchemaType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("TabularSchemaType");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"TabularSchemaType",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an TabularSchemaType identified by its GUID. Restore resurrects a soft deleted TabularSchemaType. When a TabularSchemaType was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the TabularSchemaType
     * @return  TabularSchemaType the restored TabularSchemaType
     */
    public TabularSchemaType restoreTabularSchemaType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreTabularSchemaType";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        TabularSchemaType restoredTabularSchemaType =  TabularSchemaTypeMapper.mapOmrsEntityDetailToTabularSchemaType(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredTabularSchemaType;
    }    

    /**
     * Add classifications to the supplied tabularSchemaType
     * @param userId user identity
     * @param entityGuid the GUID value for tabularSchemaType
     * @param classifications the classifications to apply.
     * @return the tabularSchemaType entity that has been classified
     */
     public TabularSchemaType addTabularSchemaTypeClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addTabularSchemaTypeClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         TabularSchemaType tabularSchemaTypeClassificationBeans = TabularSchemaTypeMapper.mapOmrsEntityDetailToTabularSchemaType(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified TabularSchemaType=" +  tabularSchemaTypeClassificationBeans);
         }
         return  tabularSchemaTypeClassificationBeans;
    }

    /**
     * Updates classifications to an existing tabularSchemaType represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the tabularSchemaType
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given tabularSchemaType guid
     */
    public TabularSchemaType updateTabularSchemaTypeClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateTabularSchemaTypeClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           TabularSchemaType  tabularSchemaTypeClassificationBeans = TabularSchemaTypeMapper.mapOmrsEntityDetailToTabularSchemaType(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  tabularSchemaTypeClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing tabularSchemaType represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the tabularSchemaType
     * @param name name of the classification
     * @return deleted TabularSchemaType  classification
     */
    public TabularSchemaType deleteTabularSchemaTypeClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteTabularSchemaTypeClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       TabularSchemaType declassifiedTabularSchemaType =  TabularSchemaTypeMapper.mapOmrsEntityDetailToTabularSchemaType(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedTabularSchemaType;
    }

    /**
      * Get the relationships associated with entity tabularSchemaType represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the tabularSchemaType
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getTabularSchemaTypeRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getTabularSchemaTypeRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an governanceZone given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the governanceZones relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return GovernanceZone the GovernanceZone entity with the requested GUID
     */
    public GovernanceZone getGovernanceZone(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getGovernanceZone";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        GovernanceZone gotgovernanceZone = GovernanceZoneMapper.mapOmrsEntityDetailToGovernanceZone(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotgovernanceZone );
        }
        return gotgovernanceZone;

    }
    /**
     * Create new governanceZone.
     * @param userId user identity
     * @param governanceZone the input entity with values.
     * @return GovernanceZone the created entity.
     */

    public GovernanceZone createGovernanceZone(String userId,GovernanceZone governanceZone)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createGovernanceZone";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = GovernanceZoneMapper.mapGovernanceZoneToOmrsEntityDetail(governanceZone);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        GovernanceZone createdGovernanceZone =  GovernanceZoneMapper.mapOmrsEntityDetailToGovernanceZone(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created GovernanceZone="+ createdGovernanceZone );
        }
        return createdGovernanceZone;
    }
    /**
     * Update governanceZone
     * @param userId user identity
     * @param governanceZone   governanceZone to update
     * @return GovernanceZone the updated governanceZone entity
     */
    public GovernanceZone updateGovernanceZone(String userId, GovernanceZone governanceZone)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateGovernanceZone";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = GovernanceZoneMapper.mapGovernanceZoneToOmrsEntityDetail(governanceZone);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            GovernanceZone updatedGovernanceZone =  GovernanceZoneMapper.mapOmrsEntityDetailToGovernanceZone(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated GovernanceZone="+ updatedGovernanceZone );
            }
            return updatedGovernanceZone;
        }

    /**
     * Delete an governanceZone identified by its GUID. Delete is a soft delete, this means that the governanceZone has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the governanceZone
     * @return GovernanceZone the deleted GovernanceZone entity
     */

    public GovernanceZone deleteGovernanceZone(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteGovernanceZone";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GovernanceZone type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GovernanceZone");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"GovernanceZone",entityDef.getGUID(),entityGuid);
         GovernanceZone deletedGovernanceZone = GovernanceZoneMapper.mapOmrsEntityDetailToGovernanceZone(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedGovernanceZone;

    }
    /**
     * Purge an governanceZone identified by its GUID. Delete is a hard delete, this means that the governanceZone is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the governanceZone
     */
    public void purgeGovernanceZone(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeGovernanceZone";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GovernanceZone type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GovernanceZone");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"GovernanceZone",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an GovernanceZone identified by its GUID. Restore resurrects a soft deleted GovernanceZone. When a GovernanceZone was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the GovernanceZone
     * @return  GovernanceZone the restored GovernanceZone
     */
    public GovernanceZone restoreGovernanceZone(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreGovernanceZone";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        GovernanceZone restoredGovernanceZone =  GovernanceZoneMapper.mapOmrsEntityDetailToGovernanceZone(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredGovernanceZone;
    }    

    /**
     * Add classifications to the supplied governanceZone
     * @param userId user identity
     * @param entityGuid the GUID value for governanceZone
     * @param classifications the classifications to apply.
     * @return the governanceZone entity that has been classified
     */
     public GovernanceZone addGovernanceZoneClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addGovernanceZoneClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         GovernanceZone governanceZoneClassificationBeans = GovernanceZoneMapper.mapOmrsEntityDetailToGovernanceZone(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified GovernanceZone=" +  governanceZoneClassificationBeans);
         }
         return  governanceZoneClassificationBeans;
    }

    /**
     * Updates classifications to an existing governanceZone represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the governanceZone
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given governanceZone guid
     */
    public GovernanceZone updateGovernanceZoneClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateGovernanceZoneClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           GovernanceZone  governanceZoneClassificationBeans = GovernanceZoneMapper.mapOmrsEntityDetailToGovernanceZone(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  governanceZoneClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing governanceZone represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the governanceZone
     * @param name name of the classification
     * @return deleted GovernanceZone  classification
     */
    public GovernanceZone deleteGovernanceZoneClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteGovernanceZoneClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       GovernanceZone declassifiedGovernanceZone =  GovernanceZoneMapper.mapOmrsEntityDetailToGovernanceZone(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedGovernanceZone;
    }

    /**
      * Get the relationships associated with entity governanceZone represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the governanceZone
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getGovernanceZoneRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getGovernanceZoneRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an relationalDBSchemaType given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the relationalDBSchemaTypes relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return RelationalDBSchemaType the RelationalDBSchemaType entity with the requested GUID
     */
    public RelationalDBSchemaType getRelationalDBSchemaType(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getRelationalDBSchemaType";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        RelationalDBSchemaType gotrelationalDBSchemaType = RelationalDBSchemaTypeMapper.mapOmrsEntityDetailToRelationalDBSchemaType(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotrelationalDBSchemaType );
        }
        return gotrelationalDBSchemaType;

    }
    /**
     * Create new relationalDBSchemaType.
     * @param userId user identity
     * @param relationalDBSchemaType the input entity with values.
     * @return RelationalDBSchemaType the created entity.
     */

    public RelationalDBSchemaType createRelationalDBSchemaType(String userId,RelationalDBSchemaType relationalDBSchemaType)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createRelationalDBSchemaType";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = RelationalDBSchemaTypeMapper.mapRelationalDBSchemaTypeToOmrsEntityDetail(relationalDBSchemaType);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        RelationalDBSchemaType createdRelationalDBSchemaType =  RelationalDBSchemaTypeMapper.mapOmrsEntityDetailToRelationalDBSchemaType(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created RelationalDBSchemaType="+ createdRelationalDBSchemaType );
        }
        return createdRelationalDBSchemaType;
    }
    /**
     * Update relationalDBSchemaType
     * @param userId user identity
     * @param relationalDBSchemaType   relationalDBSchemaType to update
     * @return RelationalDBSchemaType the updated relationalDBSchemaType entity
     */
    public RelationalDBSchemaType updateRelationalDBSchemaType(String userId, RelationalDBSchemaType relationalDBSchemaType)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateRelationalDBSchemaType";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = RelationalDBSchemaTypeMapper.mapRelationalDBSchemaTypeToOmrsEntityDetail(relationalDBSchemaType);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            RelationalDBSchemaType updatedRelationalDBSchemaType =  RelationalDBSchemaTypeMapper.mapOmrsEntityDetailToRelationalDBSchemaType(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated RelationalDBSchemaType="+ updatedRelationalDBSchemaType );
            }
            return updatedRelationalDBSchemaType;
        }

    /**
     * Delete an relationalDBSchemaType identified by its GUID. Delete is a soft delete, this means that the relationalDBSchemaType has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the relationalDBSchemaType
     * @return RelationalDBSchemaType the deleted RelationalDBSchemaType entity
     */

    public RelationalDBSchemaType deleteRelationalDBSchemaType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteRelationalDBSchemaType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the RelationalDBSchemaType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("RelationalDBSchemaType");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"RelationalDBSchemaType",entityDef.getGUID(),entityGuid);
         RelationalDBSchemaType deletedRelationalDBSchemaType = RelationalDBSchemaTypeMapper.mapOmrsEntityDetailToRelationalDBSchemaType(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedRelationalDBSchemaType;

    }
    /**
     * Purge an relationalDBSchemaType identified by its GUID. Delete is a hard delete, this means that the relationalDBSchemaType is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the relationalDBSchemaType
     */
    public void purgeRelationalDBSchemaType(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeRelationalDBSchemaType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the RelationalDBSchemaType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("RelationalDBSchemaType");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"RelationalDBSchemaType",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an RelationalDBSchemaType identified by its GUID. Restore resurrects a soft deleted RelationalDBSchemaType. When a RelationalDBSchemaType was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the RelationalDBSchemaType
     * @return  RelationalDBSchemaType the restored RelationalDBSchemaType
     */
    public RelationalDBSchemaType restoreRelationalDBSchemaType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreRelationalDBSchemaType";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        RelationalDBSchemaType restoredRelationalDBSchemaType =  RelationalDBSchemaTypeMapper.mapOmrsEntityDetailToRelationalDBSchemaType(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredRelationalDBSchemaType;
    }    

    /**
     * Add classifications to the supplied relationalDBSchemaType
     * @param userId user identity
     * @param entityGuid the GUID value for relationalDBSchemaType
     * @param classifications the classifications to apply.
     * @return the relationalDBSchemaType entity that has been classified
     */
     public RelationalDBSchemaType addRelationalDBSchemaTypeClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addRelationalDBSchemaTypeClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         RelationalDBSchemaType relationalDBSchemaTypeClassificationBeans = RelationalDBSchemaTypeMapper.mapOmrsEntityDetailToRelationalDBSchemaType(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified RelationalDBSchemaType=" +  relationalDBSchemaTypeClassificationBeans);
         }
         return  relationalDBSchemaTypeClassificationBeans;
    }

    /**
     * Updates classifications to an existing relationalDBSchemaType represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the relationalDBSchemaType
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given relationalDBSchemaType guid
     */
    public RelationalDBSchemaType updateRelationalDBSchemaTypeClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateRelationalDBSchemaTypeClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           RelationalDBSchemaType  relationalDBSchemaTypeClassificationBeans = RelationalDBSchemaTypeMapper.mapOmrsEntityDetailToRelationalDBSchemaType(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  relationalDBSchemaTypeClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing relationalDBSchemaType represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the relationalDBSchemaType
     * @param name name of the classification
     * @return deleted RelationalDBSchemaType  classification
     */
    public RelationalDBSchemaType deleteRelationalDBSchemaTypeClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteRelationalDBSchemaTypeClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       RelationalDBSchemaType declassifiedRelationalDBSchemaType =  RelationalDBSchemaTypeMapper.mapOmrsEntityDetailToRelationalDBSchemaType(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedRelationalDBSchemaType;
    }

    /**
      * Get the relationships associated with entity relationalDBSchemaType represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the relationalDBSchemaType
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getRelationalDBSchemaTypeRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getRelationalDBSchemaTypeRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an governanceApproach given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the governanceApproachs relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return GovernanceApproach the GovernanceApproach entity with the requested GUID
     */
    public GovernanceApproach getGovernanceApproach(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getGovernanceApproach";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        GovernanceApproach gotgovernanceApproach = GovernanceApproachMapper.mapOmrsEntityDetailToGovernanceApproach(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotgovernanceApproach );
        }
        return gotgovernanceApproach;

    }
    /**
     * Create new governanceApproach.
     * @param userId user identity
     * @param governanceApproach the input entity with values.
     * @return GovernanceApproach the created entity.
     */

    public GovernanceApproach createGovernanceApproach(String userId,GovernanceApproach governanceApproach)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createGovernanceApproach";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = GovernanceApproachMapper.mapGovernanceApproachToOmrsEntityDetail(governanceApproach);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        GovernanceApproach createdGovernanceApproach =  GovernanceApproachMapper.mapOmrsEntityDetailToGovernanceApproach(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created GovernanceApproach="+ createdGovernanceApproach );
        }
        return createdGovernanceApproach;
    }
    /**
     * Update governanceApproach
     * @param userId user identity
     * @param governanceApproach   governanceApproach to update
     * @return GovernanceApproach the updated governanceApproach entity
     */
    public GovernanceApproach updateGovernanceApproach(String userId, GovernanceApproach governanceApproach)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateGovernanceApproach";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = GovernanceApproachMapper.mapGovernanceApproachToOmrsEntityDetail(governanceApproach);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            GovernanceApproach updatedGovernanceApproach =  GovernanceApproachMapper.mapOmrsEntityDetailToGovernanceApproach(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated GovernanceApproach="+ updatedGovernanceApproach );
            }
            return updatedGovernanceApproach;
        }

    /**
     * Delete an governanceApproach identified by its GUID. Delete is a soft delete, this means that the governanceApproach has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the governanceApproach
     * @return GovernanceApproach the deleted GovernanceApproach entity
     */

    public GovernanceApproach deleteGovernanceApproach(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteGovernanceApproach";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GovernanceApproach type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GovernanceApproach");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"GovernanceApproach",entityDef.getGUID(),entityGuid);
         GovernanceApproach deletedGovernanceApproach = GovernanceApproachMapper.mapOmrsEntityDetailToGovernanceApproach(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedGovernanceApproach;

    }
    /**
     * Purge an governanceApproach identified by its GUID. Delete is a hard delete, this means that the governanceApproach is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the governanceApproach
     */
    public void purgeGovernanceApproach(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeGovernanceApproach";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GovernanceApproach type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GovernanceApproach");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"GovernanceApproach",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an GovernanceApproach identified by its GUID. Restore resurrects a soft deleted GovernanceApproach. When a GovernanceApproach was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the GovernanceApproach
     * @return  GovernanceApproach the restored GovernanceApproach
     */
    public GovernanceApproach restoreGovernanceApproach(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreGovernanceApproach";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        GovernanceApproach restoredGovernanceApproach =  GovernanceApproachMapper.mapOmrsEntityDetailToGovernanceApproach(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredGovernanceApproach;
    }    

    /**
     * Add classifications to the supplied governanceApproach
     * @param userId user identity
     * @param entityGuid the GUID value for governanceApproach
     * @param classifications the classifications to apply.
     * @return the governanceApproach entity that has been classified
     */
     public GovernanceApproach addGovernanceApproachClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addGovernanceApproachClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         GovernanceApproach governanceApproachClassificationBeans = GovernanceApproachMapper.mapOmrsEntityDetailToGovernanceApproach(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified GovernanceApproach=" +  governanceApproachClassificationBeans);
         }
         return  governanceApproachClassificationBeans;
    }

    /**
     * Updates classifications to an existing governanceApproach represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the governanceApproach
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given governanceApproach guid
     */
    public GovernanceApproach updateGovernanceApproachClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateGovernanceApproachClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           GovernanceApproach  governanceApproachClassificationBeans = GovernanceApproachMapper.mapOmrsEntityDetailToGovernanceApproach(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  governanceApproachClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing governanceApproach represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the governanceApproach
     * @param name name of the classification
     * @return deleted GovernanceApproach  classification
     */
    public GovernanceApproach deleteGovernanceApproachClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteGovernanceApproachClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       GovernanceApproach declassifiedGovernanceApproach =  GovernanceApproachMapper.mapOmrsEntityDetailToGovernanceApproach(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedGovernanceApproach;
    }

    /**
      * Get the relationships associated with entity governanceApproach represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the governanceApproach
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getGovernanceApproachRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getGovernanceApproachRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an arraySchemaType given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the arraySchemaTypes relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return ArraySchemaType the ArraySchemaType entity with the requested GUID
     */
    public ArraySchemaType getArraySchemaType(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getArraySchemaType";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        ArraySchemaType gotarraySchemaType = ArraySchemaTypeMapper.mapOmrsEntityDetailToArraySchemaType(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotarraySchemaType );
        }
        return gotarraySchemaType;

    }
    /**
     * Create new arraySchemaType.
     * @param userId user identity
     * @param arraySchemaType the input entity with values.
     * @return ArraySchemaType the created entity.
     */

    public ArraySchemaType createArraySchemaType(String userId,ArraySchemaType arraySchemaType)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createArraySchemaType";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = ArraySchemaTypeMapper.mapArraySchemaTypeToOmrsEntityDetail(arraySchemaType);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        ArraySchemaType createdArraySchemaType =  ArraySchemaTypeMapper.mapOmrsEntityDetailToArraySchemaType(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created ArraySchemaType="+ createdArraySchemaType );
        }
        return createdArraySchemaType;
    }
    /**
     * Update arraySchemaType
     * @param userId user identity
     * @param arraySchemaType   arraySchemaType to update
     * @return ArraySchemaType the updated arraySchemaType entity
     */
    public ArraySchemaType updateArraySchemaType(String userId, ArraySchemaType arraySchemaType)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateArraySchemaType";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = ArraySchemaTypeMapper.mapArraySchemaTypeToOmrsEntityDetail(arraySchemaType);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            ArraySchemaType updatedArraySchemaType =  ArraySchemaTypeMapper.mapOmrsEntityDetailToArraySchemaType(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated ArraySchemaType="+ updatedArraySchemaType );
            }
            return updatedArraySchemaType;
        }

    /**
     * Delete an arraySchemaType identified by its GUID. Delete is a soft delete, this means that the arraySchemaType has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the arraySchemaType
     * @return ArraySchemaType the deleted ArraySchemaType entity
     */

    public ArraySchemaType deleteArraySchemaType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteArraySchemaType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ArraySchemaType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ArraySchemaType");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"ArraySchemaType",entityDef.getGUID(),entityGuid);
         ArraySchemaType deletedArraySchemaType = ArraySchemaTypeMapper.mapOmrsEntityDetailToArraySchemaType(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedArraySchemaType;

    }
    /**
     * Purge an arraySchemaType identified by its GUID. Delete is a hard delete, this means that the arraySchemaType is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the arraySchemaType
     */
    public void purgeArraySchemaType(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeArraySchemaType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ArraySchemaType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ArraySchemaType");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"ArraySchemaType",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an ArraySchemaType identified by its GUID. Restore resurrects a soft deleted ArraySchemaType. When a ArraySchemaType was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the ArraySchemaType
     * @return  ArraySchemaType the restored ArraySchemaType
     */
    public ArraySchemaType restoreArraySchemaType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreArraySchemaType";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        ArraySchemaType restoredArraySchemaType =  ArraySchemaTypeMapper.mapOmrsEntityDetailToArraySchemaType(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredArraySchemaType;
    }    

    /**
     * Add classifications to the supplied arraySchemaType
     * @param userId user identity
     * @param entityGuid the GUID value for arraySchemaType
     * @param classifications the classifications to apply.
     * @return the arraySchemaType entity that has been classified
     */
     public ArraySchemaType addArraySchemaTypeClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addArraySchemaTypeClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         ArraySchemaType arraySchemaTypeClassificationBeans = ArraySchemaTypeMapper.mapOmrsEntityDetailToArraySchemaType(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified ArraySchemaType=" +  arraySchemaTypeClassificationBeans);
         }
         return  arraySchemaTypeClassificationBeans;
    }

    /**
     * Updates classifications to an existing arraySchemaType represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the arraySchemaType
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given arraySchemaType guid
     */
    public ArraySchemaType updateArraySchemaTypeClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateArraySchemaTypeClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           ArraySchemaType  arraySchemaTypeClassificationBeans = ArraySchemaTypeMapper.mapOmrsEntityDetailToArraySchemaType(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  arraySchemaTypeClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing arraySchemaType represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the arraySchemaType
     * @param name name of the classification
     * @return deleted ArraySchemaType  classification
     */
    public ArraySchemaType deleteArraySchemaTypeClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteArraySchemaTypeClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       ArraySchemaType declassifiedArraySchemaType =  ArraySchemaTypeMapper.mapOmrsEntityDetailToArraySchemaType(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedArraySchemaType;
    }

    /**
      * Get the relationships associated with entity arraySchemaType represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the arraySchemaType
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getArraySchemaTypeRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getArraySchemaTypeRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an form given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the forms relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return Form the Form entity with the requested GUID
     */
    public Form getForm(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getForm";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        Form gotform = FormMapper.mapOmrsEntityDetailToForm(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotform );
        }
        return gotform;

    }
    /**
     * Create new form.
     * @param userId user identity
     * @param form the input entity with values.
     * @return Form the created entity.
     */

    public Form createForm(String userId,Form form)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createForm";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = FormMapper.mapFormToOmrsEntityDetail(form);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        Form createdForm =  FormMapper.mapOmrsEntityDetailToForm(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created Form="+ createdForm );
        }
        return createdForm;
    }
    /**
     * Update form
     * @param userId user identity
     * @param form   form to update
     * @return Form the updated form entity
     */
    public Form updateForm(String userId, Form form)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateForm";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = FormMapper.mapFormToOmrsEntityDetail(form);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            Form updatedForm =  FormMapper.mapOmrsEntityDetailToForm(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated Form="+ updatedForm );
            }
            return updatedForm;
        }

    /**
     * Delete an form identified by its GUID. Delete is a soft delete, this means that the form has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the form
     * @return Form the deleted Form entity
     */

    public Form deleteForm(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteForm";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Form type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Form");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"Form",entityDef.getGUID(),entityGuid);
         Form deletedForm = FormMapper.mapOmrsEntityDetailToForm(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedForm;

    }
    /**
     * Purge an form identified by its GUID. Delete is a hard delete, this means that the form is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the form
     */
    public void purgeForm(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeForm";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Form type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Form");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"Form",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an Form identified by its GUID. Restore resurrects a soft deleted Form. When a Form was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the Form
     * @return  Form the restored Form
     */
    public Form restoreForm(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreForm";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        Form restoredForm =  FormMapper.mapOmrsEntityDetailToForm(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredForm;
    }    

    /**
     * Add classifications to the supplied form
     * @param userId user identity
     * @param entityGuid the GUID value for form
     * @param classifications the classifications to apply.
     * @return the form entity that has been classified
     */
     public Form addFormClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addFormClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         Form formClassificationBeans = FormMapper.mapOmrsEntityDetailToForm(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified Form=" +  formClassificationBeans);
         }
         return  formClassificationBeans;
    }

    /**
     * Updates classifications to an existing form represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the form
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given form guid
     */
    public Form updateFormClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateFormClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           Form  formClassificationBeans = FormMapper.mapOmrsEntityDetailToForm(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  formClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing form represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the form
     * @param name name of the classification
     * @return deleted Form  classification
     */
    public Form deleteFormClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteFormClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       Form declassifiedForm =  FormMapper.mapOmrsEntityDetailToForm(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedForm;
    }

    /**
      * Get the relationships associated with entity form represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the form
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getFormRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getFormRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an rating given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the ratings relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return Rating the Rating entity with the requested GUID
     */
    public Rating getRating(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getRating";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        Rating gotrating = RatingMapper.mapOmrsEntityDetailToRating(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotrating );
        }
        return gotrating;

    }
    /**
     * Create new rating.
     * @param userId user identity
     * @param rating the input entity with values.
     * @return Rating the created entity.
     */

    public Rating createRating(String userId,Rating rating)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createRating";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = RatingMapper.mapRatingToOmrsEntityDetail(rating);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        Rating createdRating =  RatingMapper.mapOmrsEntityDetailToRating(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created Rating="+ createdRating );
        }
        return createdRating;
    }
    /**
     * Update rating
     * @param userId user identity
     * @param rating   rating to update
     * @return Rating the updated rating entity
     */
    public Rating updateRating(String userId, Rating rating)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateRating";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = RatingMapper.mapRatingToOmrsEntityDetail(rating);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            Rating updatedRating =  RatingMapper.mapOmrsEntityDetailToRating(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated Rating="+ updatedRating );
            }
            return updatedRating;
        }

    /**
     * Delete an rating identified by its GUID. Delete is a soft delete, this means that the rating has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the rating
     * @return Rating the deleted Rating entity
     */

    public Rating deleteRating(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteRating";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Rating type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Rating");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"Rating",entityDef.getGUID(),entityGuid);
         Rating deletedRating = RatingMapper.mapOmrsEntityDetailToRating(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedRating;

    }
    /**
     * Purge an rating identified by its GUID. Delete is a hard delete, this means that the rating is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the rating
     */
    public void purgeRating(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeRating";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Rating type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Rating");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"Rating",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an Rating identified by its GUID. Restore resurrects a soft deleted Rating. When a Rating was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the Rating
     * @return  Rating the restored Rating
     */
    public Rating restoreRating(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreRating";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        Rating restoredRating =  RatingMapper.mapOmrsEntityDetailToRating(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredRating;
    }    

    /**
     * Add classifications to the supplied rating
     * @param userId user identity
     * @param entityGuid the GUID value for rating
     * @param classifications the classifications to apply.
     * @return the rating entity that has been classified
     */
     public Rating addRatingClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addRatingClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         Rating ratingClassificationBeans = RatingMapper.mapOmrsEntityDetailToRating(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified Rating=" +  ratingClassificationBeans);
         }
         return  ratingClassificationBeans;
    }

    /**
     * Updates classifications to an existing rating represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the rating
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given rating guid
     */
    public Rating updateRatingClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateRatingClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           Rating  ratingClassificationBeans = RatingMapper.mapOmrsEntityDetailToRating(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  ratingClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing rating represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the rating
     * @param name name of the classification
     * @return deleted Rating  classification
     */
    public Rating deleteRatingClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteRatingClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       Rating declassifiedRating =  RatingMapper.mapOmrsEntityDetailToRating(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedRating;
    }

    /**
      * Get the relationships associated with entity rating represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the rating
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getRatingRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getRatingRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an primitiveSchemaType given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the primitiveSchemaTypes relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return PrimitiveSchemaType the PrimitiveSchemaType entity with the requested GUID
     */
    public PrimitiveSchemaType getPrimitiveSchemaType(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getPrimitiveSchemaType";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        PrimitiveSchemaType gotprimitiveSchemaType = PrimitiveSchemaTypeMapper.mapOmrsEntityDetailToPrimitiveSchemaType(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotprimitiveSchemaType );
        }
        return gotprimitiveSchemaType;

    }
    /**
     * Create new primitiveSchemaType.
     * @param userId user identity
     * @param primitiveSchemaType the input entity with values.
     * @return PrimitiveSchemaType the created entity.
     */

    public PrimitiveSchemaType createPrimitiveSchemaType(String userId,PrimitiveSchemaType primitiveSchemaType)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createPrimitiveSchemaType";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = PrimitiveSchemaTypeMapper.mapPrimitiveSchemaTypeToOmrsEntityDetail(primitiveSchemaType);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        PrimitiveSchemaType createdPrimitiveSchemaType =  PrimitiveSchemaTypeMapper.mapOmrsEntityDetailToPrimitiveSchemaType(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created PrimitiveSchemaType="+ createdPrimitiveSchemaType );
        }
        return createdPrimitiveSchemaType;
    }
    /**
     * Update primitiveSchemaType
     * @param userId user identity
     * @param primitiveSchemaType   primitiveSchemaType to update
     * @return PrimitiveSchemaType the updated primitiveSchemaType entity
     */
    public PrimitiveSchemaType updatePrimitiveSchemaType(String userId, PrimitiveSchemaType primitiveSchemaType)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updatePrimitiveSchemaType";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = PrimitiveSchemaTypeMapper.mapPrimitiveSchemaTypeToOmrsEntityDetail(primitiveSchemaType);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            PrimitiveSchemaType updatedPrimitiveSchemaType =  PrimitiveSchemaTypeMapper.mapOmrsEntityDetailToPrimitiveSchemaType(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated PrimitiveSchemaType="+ updatedPrimitiveSchemaType );
            }
            return updatedPrimitiveSchemaType;
        }

    /**
     * Delete an primitiveSchemaType identified by its GUID. Delete is a soft delete, this means that the primitiveSchemaType has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the primitiveSchemaType
     * @return PrimitiveSchemaType the deleted PrimitiveSchemaType entity
     */

    public PrimitiveSchemaType deletePrimitiveSchemaType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deletePrimitiveSchemaType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the PrimitiveSchemaType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("PrimitiveSchemaType");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"PrimitiveSchemaType",entityDef.getGUID(),entityGuid);
         PrimitiveSchemaType deletedPrimitiveSchemaType = PrimitiveSchemaTypeMapper.mapOmrsEntityDetailToPrimitiveSchemaType(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedPrimitiveSchemaType;

    }
    /**
     * Purge an primitiveSchemaType identified by its GUID. Delete is a hard delete, this means that the primitiveSchemaType is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the primitiveSchemaType
     */
    public void purgePrimitiveSchemaType(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgePrimitiveSchemaType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the PrimitiveSchemaType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("PrimitiveSchemaType");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"PrimitiveSchemaType",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an PrimitiveSchemaType identified by its GUID. Restore resurrects a soft deleted PrimitiveSchemaType. When a PrimitiveSchemaType was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the PrimitiveSchemaType
     * @return  PrimitiveSchemaType the restored PrimitiveSchemaType
     */
    public PrimitiveSchemaType restorePrimitiveSchemaType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restorePrimitiveSchemaType";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        PrimitiveSchemaType restoredPrimitiveSchemaType =  PrimitiveSchemaTypeMapper.mapOmrsEntityDetailToPrimitiveSchemaType(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredPrimitiveSchemaType;
    }    

    /**
     * Add classifications to the supplied primitiveSchemaType
     * @param userId user identity
     * @param entityGuid the GUID value for primitiveSchemaType
     * @param classifications the classifications to apply.
     * @return the primitiveSchemaType entity that has been classified
     */
     public PrimitiveSchemaType addPrimitiveSchemaTypeClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addPrimitiveSchemaTypeClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         PrimitiveSchemaType primitiveSchemaTypeClassificationBeans = PrimitiveSchemaTypeMapper.mapOmrsEntityDetailToPrimitiveSchemaType(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified PrimitiveSchemaType=" +  primitiveSchemaTypeClassificationBeans);
         }
         return  primitiveSchemaTypeClassificationBeans;
    }

    /**
     * Updates classifications to an existing primitiveSchemaType represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the primitiveSchemaType
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given primitiveSchemaType guid
     */
    public PrimitiveSchemaType updatePrimitiveSchemaTypeClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updatePrimitiveSchemaTypeClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           PrimitiveSchemaType  primitiveSchemaTypeClassificationBeans = PrimitiveSchemaTypeMapper.mapOmrsEntityDetailToPrimitiveSchemaType(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  primitiveSchemaTypeClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing primitiveSchemaType represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the primitiveSchemaType
     * @param name name of the classification
     * @return deleted PrimitiveSchemaType  classification
     */
    public PrimitiveSchemaType deletePrimitiveSchemaTypeClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deletePrimitiveSchemaTypeClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       PrimitiveSchemaType declassifiedPrimitiveSchemaType =  PrimitiveSchemaTypeMapper.mapOmrsEntityDetailToPrimitiveSchemaType(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedPrimitiveSchemaType;
    }

    /**
      * Get the relationships associated with entity primitiveSchemaType represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the primitiveSchemaType
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getPrimitiveSchemaTypeRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getPrimitiveSchemaTypeRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an objectSchemaType given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the objectSchemaTypes relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return ObjectSchemaType the ObjectSchemaType entity with the requested GUID
     */
    public ObjectSchemaType getObjectSchemaType(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getObjectSchemaType";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        ObjectSchemaType gotobjectSchemaType = ObjectSchemaTypeMapper.mapOmrsEntityDetailToObjectSchemaType(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotobjectSchemaType );
        }
        return gotobjectSchemaType;

    }
    /**
     * Create new objectSchemaType.
     * @param userId user identity
     * @param objectSchemaType the input entity with values.
     * @return ObjectSchemaType the created entity.
     */

    public ObjectSchemaType createObjectSchemaType(String userId,ObjectSchemaType objectSchemaType)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createObjectSchemaType";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = ObjectSchemaTypeMapper.mapObjectSchemaTypeToOmrsEntityDetail(objectSchemaType);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        ObjectSchemaType createdObjectSchemaType =  ObjectSchemaTypeMapper.mapOmrsEntityDetailToObjectSchemaType(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created ObjectSchemaType="+ createdObjectSchemaType );
        }
        return createdObjectSchemaType;
    }
    /**
     * Update objectSchemaType
     * @param userId user identity
     * @param objectSchemaType   objectSchemaType to update
     * @return ObjectSchemaType the updated objectSchemaType entity
     */
    public ObjectSchemaType updateObjectSchemaType(String userId, ObjectSchemaType objectSchemaType)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateObjectSchemaType";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = ObjectSchemaTypeMapper.mapObjectSchemaTypeToOmrsEntityDetail(objectSchemaType);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            ObjectSchemaType updatedObjectSchemaType =  ObjectSchemaTypeMapper.mapOmrsEntityDetailToObjectSchemaType(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated ObjectSchemaType="+ updatedObjectSchemaType );
            }
            return updatedObjectSchemaType;
        }

    /**
     * Delete an objectSchemaType identified by its GUID. Delete is a soft delete, this means that the objectSchemaType has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the objectSchemaType
     * @return ObjectSchemaType the deleted ObjectSchemaType entity
     */

    public ObjectSchemaType deleteObjectSchemaType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteObjectSchemaType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ObjectSchemaType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ObjectSchemaType");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"ObjectSchemaType",entityDef.getGUID(),entityGuid);
         ObjectSchemaType deletedObjectSchemaType = ObjectSchemaTypeMapper.mapOmrsEntityDetailToObjectSchemaType(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedObjectSchemaType;

    }
    /**
     * Purge an objectSchemaType identified by its GUID. Delete is a hard delete, this means that the objectSchemaType is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the objectSchemaType
     */
    public void purgeObjectSchemaType(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeObjectSchemaType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ObjectSchemaType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ObjectSchemaType");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"ObjectSchemaType",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an ObjectSchemaType identified by its GUID. Restore resurrects a soft deleted ObjectSchemaType. When a ObjectSchemaType was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the ObjectSchemaType
     * @return  ObjectSchemaType the restored ObjectSchemaType
     */
    public ObjectSchemaType restoreObjectSchemaType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreObjectSchemaType";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        ObjectSchemaType restoredObjectSchemaType =  ObjectSchemaTypeMapper.mapOmrsEntityDetailToObjectSchemaType(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredObjectSchemaType;
    }    

    /**
     * Add classifications to the supplied objectSchemaType
     * @param userId user identity
     * @param entityGuid the GUID value for objectSchemaType
     * @param classifications the classifications to apply.
     * @return the objectSchemaType entity that has been classified
     */
     public ObjectSchemaType addObjectSchemaTypeClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addObjectSchemaTypeClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         ObjectSchemaType objectSchemaTypeClassificationBeans = ObjectSchemaTypeMapper.mapOmrsEntityDetailToObjectSchemaType(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified ObjectSchemaType=" +  objectSchemaTypeClassificationBeans);
         }
         return  objectSchemaTypeClassificationBeans;
    }

    /**
     * Updates classifications to an existing objectSchemaType represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the objectSchemaType
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given objectSchemaType guid
     */
    public ObjectSchemaType updateObjectSchemaTypeClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateObjectSchemaTypeClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           ObjectSchemaType  objectSchemaTypeClassificationBeans = ObjectSchemaTypeMapper.mapOmrsEntityDetailToObjectSchemaType(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  objectSchemaTypeClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing objectSchemaType represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the objectSchemaType
     * @param name name of the classification
     * @return deleted ObjectSchemaType  classification
     */
    public ObjectSchemaType deleteObjectSchemaTypeClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteObjectSchemaTypeClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       ObjectSchemaType declassifiedObjectSchemaType =  ObjectSchemaTypeMapper.mapOmrsEntityDetailToObjectSchemaType(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedObjectSchemaType;
    }

    /**
      * Get the relationships associated with entity objectSchemaType represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the objectSchemaType
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getObjectSchemaTypeRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getObjectSchemaTypeRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an governanceStrategy given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the governanceStrategies relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return GovernanceStrategy the GovernanceStrategy entity with the requested GUID
     */
    public GovernanceStrategy getGovernanceStrategy(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getGovernanceStrategy";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        GovernanceStrategy gotgovernanceStrategy = GovernanceStrategyMapper.mapOmrsEntityDetailToGovernanceStrategy(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotgovernanceStrategy );
        }
        return gotgovernanceStrategy;

    }
    /**
     * Create new governanceStrategy.
     * @param userId user identity
     * @param governanceStrategy the input entity with values.
     * @return GovernanceStrategy the created entity.
     */

    public GovernanceStrategy createGovernanceStrategy(String userId,GovernanceStrategy governanceStrategy)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createGovernanceStrategy";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = GovernanceStrategyMapper.mapGovernanceStrategyToOmrsEntityDetail(governanceStrategy);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        GovernanceStrategy createdGovernanceStrategy =  GovernanceStrategyMapper.mapOmrsEntityDetailToGovernanceStrategy(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created GovernanceStrategy="+ createdGovernanceStrategy );
        }
        return createdGovernanceStrategy;
    }
    /**
     * Update governanceStrategy
     * @param userId user identity
     * @param governanceStrategy   governanceStrategy to update
     * @return GovernanceStrategy the updated governanceStrategy entity
     */
    public GovernanceStrategy updateGovernanceStrategy(String userId, GovernanceStrategy governanceStrategy)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateGovernanceStrategy";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = GovernanceStrategyMapper.mapGovernanceStrategyToOmrsEntityDetail(governanceStrategy);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            GovernanceStrategy updatedGovernanceStrategy =  GovernanceStrategyMapper.mapOmrsEntityDetailToGovernanceStrategy(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated GovernanceStrategy="+ updatedGovernanceStrategy );
            }
            return updatedGovernanceStrategy;
        }

    /**
     * Delete an governanceStrategy identified by its GUID. Delete is a soft delete, this means that the governanceStrategy has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the governanceStrategy
     * @return GovernanceStrategy the deleted GovernanceStrategy entity
     */

    public GovernanceStrategy deleteGovernanceStrategy(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteGovernanceStrategy";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GovernanceStrategy type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GovernanceStrategy");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"GovernanceStrategy",entityDef.getGUID(),entityGuid);
         GovernanceStrategy deletedGovernanceStrategy = GovernanceStrategyMapper.mapOmrsEntityDetailToGovernanceStrategy(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedGovernanceStrategy;

    }
    /**
     * Purge an governanceStrategy identified by its GUID. Delete is a hard delete, this means that the governanceStrategy is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the governanceStrategy
     */
    public void purgeGovernanceStrategy(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeGovernanceStrategy";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GovernanceStrategy type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GovernanceStrategy");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"GovernanceStrategy",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an GovernanceStrategy identified by its GUID. Restore resurrects a soft deleted GovernanceStrategy. When a GovernanceStrategy was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the GovernanceStrategy
     * @return  GovernanceStrategy the restored GovernanceStrategy
     */
    public GovernanceStrategy restoreGovernanceStrategy(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreGovernanceStrategy";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        GovernanceStrategy restoredGovernanceStrategy =  GovernanceStrategyMapper.mapOmrsEntityDetailToGovernanceStrategy(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredGovernanceStrategy;
    }    

    /**
     * Add classifications to the supplied governanceStrategy
     * @param userId user identity
     * @param entityGuid the GUID value for governanceStrategy
     * @param classifications the classifications to apply.
     * @return the governanceStrategy entity that has been classified
     */
     public GovernanceStrategy addGovernanceStrategyClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addGovernanceStrategyClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         GovernanceStrategy governanceStrategyClassificationBeans = GovernanceStrategyMapper.mapOmrsEntityDetailToGovernanceStrategy(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified GovernanceStrategy=" +  governanceStrategyClassificationBeans);
         }
         return  governanceStrategyClassificationBeans;
    }

    /**
     * Updates classifications to an existing governanceStrategy represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the governanceStrategy
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given governanceStrategy guid
     */
    public GovernanceStrategy updateGovernanceStrategyClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateGovernanceStrategyClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           GovernanceStrategy  governanceStrategyClassificationBeans = GovernanceStrategyMapper.mapOmrsEntityDetailToGovernanceStrategy(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  governanceStrategyClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing governanceStrategy represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the governanceStrategy
     * @param name name of the classification
     * @return deleted GovernanceStrategy  classification
     */
    public GovernanceStrategy deleteGovernanceStrategyClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteGovernanceStrategyClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       GovernanceStrategy declassifiedGovernanceStrategy =  GovernanceStrategyMapper.mapOmrsEntityDetailToGovernanceStrategy(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedGovernanceStrategy;
    }

    /**
      * Get the relationships associated with entity governanceStrategy represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the governanceStrategy
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getGovernanceStrategyRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getGovernanceStrategyRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an deployedReport given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the deployedReports relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return DeployedReport the DeployedReport entity with the requested GUID
     */
    public DeployedReport getDeployedReport(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getDeployedReport";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        DeployedReport gotdeployedReport = DeployedReportMapper.mapOmrsEntityDetailToDeployedReport(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotdeployedReport );
        }
        return gotdeployedReport;

    }
    /**
     * Create new deployedReport.
     * @param userId user identity
     * @param deployedReport the input entity with values.
     * @return DeployedReport the created entity.
     */

    public DeployedReport createDeployedReport(String userId,DeployedReport deployedReport)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createDeployedReport";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = DeployedReportMapper.mapDeployedReportToOmrsEntityDetail(deployedReport);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        DeployedReport createdDeployedReport =  DeployedReportMapper.mapOmrsEntityDetailToDeployedReport(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created DeployedReport="+ createdDeployedReport );
        }
        return createdDeployedReport;
    }
    /**
     * Update deployedReport
     * @param userId user identity
     * @param deployedReport   deployedReport to update
     * @return DeployedReport the updated deployedReport entity
     */
    public DeployedReport updateDeployedReport(String userId, DeployedReport deployedReport)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateDeployedReport";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = DeployedReportMapper.mapDeployedReportToOmrsEntityDetail(deployedReport);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            DeployedReport updatedDeployedReport =  DeployedReportMapper.mapOmrsEntityDetailToDeployedReport(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated DeployedReport="+ updatedDeployedReport );
            }
            return updatedDeployedReport;
        }

    /**
     * Delete an deployedReport identified by its GUID. Delete is a soft delete, this means that the deployedReport has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the deployedReport
     * @return DeployedReport the deleted DeployedReport entity
     */

    public DeployedReport deleteDeployedReport(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteDeployedReport";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DeployedReport type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DeployedReport");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"DeployedReport",entityDef.getGUID(),entityGuid);
         DeployedReport deletedDeployedReport = DeployedReportMapper.mapOmrsEntityDetailToDeployedReport(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedDeployedReport;

    }
    /**
     * Purge an deployedReport identified by its GUID. Delete is a hard delete, this means that the deployedReport is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the deployedReport
     */
    public void purgeDeployedReport(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeDeployedReport";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DeployedReport type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DeployedReport");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"DeployedReport",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an DeployedReport identified by its GUID. Restore resurrects a soft deleted DeployedReport. When a DeployedReport was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the DeployedReport
     * @return  DeployedReport the restored DeployedReport
     */
    public DeployedReport restoreDeployedReport(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreDeployedReport";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        DeployedReport restoredDeployedReport =  DeployedReportMapper.mapOmrsEntityDetailToDeployedReport(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredDeployedReport;
    }    

    /**
     * Add classifications to the supplied deployedReport
     * @param userId user identity
     * @param entityGuid the GUID value for deployedReport
     * @param classifications the classifications to apply.
     * @return the deployedReport entity that has been classified
     */
     public DeployedReport addDeployedReportClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addDeployedReportClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         DeployedReport deployedReportClassificationBeans = DeployedReportMapper.mapOmrsEntityDetailToDeployedReport(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified DeployedReport=" +  deployedReportClassificationBeans);
         }
         return  deployedReportClassificationBeans;
    }

    /**
     * Updates classifications to an existing deployedReport represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the deployedReport
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given deployedReport guid
     */
    public DeployedReport updateDeployedReportClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateDeployedReportClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           DeployedReport  deployedReportClassificationBeans = DeployedReportMapper.mapOmrsEntityDetailToDeployedReport(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  deployedReportClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing deployedReport represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the deployedReport
     * @param name name of the classification
     * @return deleted DeployedReport  classification
     */
    public DeployedReport deleteDeployedReportClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteDeployedReportClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       DeployedReport declassifiedDeployedReport =  DeployedReportMapper.mapOmrsEntityDetailToDeployedReport(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedDeployedReport;
    }

    /**
      * Get the relationships associated with entity deployedReport represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the deployedReport
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getDeployedReportRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getDeployedReportRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an projectCharter given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the projectCharters relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return ProjectCharter the ProjectCharter entity with the requested GUID
     */
    public ProjectCharter getProjectCharter(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getProjectCharter";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        ProjectCharter gotprojectCharter = ProjectCharterMapper.mapOmrsEntityDetailToProjectCharter(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotprojectCharter );
        }
        return gotprojectCharter;

    }
    /**
     * Create new projectCharter.
     * @param userId user identity
     * @param projectCharter the input entity with values.
     * @return ProjectCharter the created entity.
     */

    public ProjectCharter createProjectCharter(String userId,ProjectCharter projectCharter)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createProjectCharter";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = ProjectCharterMapper.mapProjectCharterToOmrsEntityDetail(projectCharter);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        ProjectCharter createdProjectCharter =  ProjectCharterMapper.mapOmrsEntityDetailToProjectCharter(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created ProjectCharter="+ createdProjectCharter );
        }
        return createdProjectCharter;
    }
    /**
     * Update projectCharter
     * @param userId user identity
     * @param projectCharter   projectCharter to update
     * @return ProjectCharter the updated projectCharter entity
     */
    public ProjectCharter updateProjectCharter(String userId, ProjectCharter projectCharter)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateProjectCharter";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = ProjectCharterMapper.mapProjectCharterToOmrsEntityDetail(projectCharter);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            ProjectCharter updatedProjectCharter =  ProjectCharterMapper.mapOmrsEntityDetailToProjectCharter(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated ProjectCharter="+ updatedProjectCharter );
            }
            return updatedProjectCharter;
        }

    /**
     * Delete an projectCharter identified by its GUID. Delete is a soft delete, this means that the projectCharter has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the projectCharter
     * @return ProjectCharter the deleted ProjectCharter entity
     */

    public ProjectCharter deleteProjectCharter(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteProjectCharter";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ProjectCharter type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ProjectCharter");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"ProjectCharter",entityDef.getGUID(),entityGuid);
         ProjectCharter deletedProjectCharter = ProjectCharterMapper.mapOmrsEntityDetailToProjectCharter(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedProjectCharter;

    }
    /**
     * Purge an projectCharter identified by its GUID. Delete is a hard delete, this means that the projectCharter is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the projectCharter
     */
    public void purgeProjectCharter(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeProjectCharter";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ProjectCharter type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ProjectCharter");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"ProjectCharter",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an ProjectCharter identified by its GUID. Restore resurrects a soft deleted ProjectCharter. When a ProjectCharter was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the ProjectCharter
     * @return  ProjectCharter the restored ProjectCharter
     */
    public ProjectCharter restoreProjectCharter(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreProjectCharter";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        ProjectCharter restoredProjectCharter =  ProjectCharterMapper.mapOmrsEntityDetailToProjectCharter(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredProjectCharter;
    }    

    /**
     * Add classifications to the supplied projectCharter
     * @param userId user identity
     * @param entityGuid the GUID value for projectCharter
     * @param classifications the classifications to apply.
     * @return the projectCharter entity that has been classified
     */
     public ProjectCharter addProjectCharterClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addProjectCharterClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         ProjectCharter projectCharterClassificationBeans = ProjectCharterMapper.mapOmrsEntityDetailToProjectCharter(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified ProjectCharter=" +  projectCharterClassificationBeans);
         }
         return  projectCharterClassificationBeans;
    }

    /**
     * Updates classifications to an existing projectCharter represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the projectCharter
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given projectCharter guid
     */
    public ProjectCharter updateProjectCharterClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateProjectCharterClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           ProjectCharter  projectCharterClassificationBeans = ProjectCharterMapper.mapOmrsEntityDetailToProjectCharter(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  projectCharterClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing projectCharter represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the projectCharter
     * @param name name of the classification
     * @return deleted ProjectCharter  classification
     */
    public ProjectCharter deleteProjectCharterClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteProjectCharterClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       ProjectCharter declassifiedProjectCharter =  ProjectCharterMapper.mapOmrsEntityDetailToProjectCharter(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedProjectCharter;
    }

    /**
      * Get the relationships associated with entity projectCharter represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the projectCharter
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getProjectCharterRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getProjectCharterRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an governanceOfficer given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the governanceOfficers relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return GovernanceOfficer the GovernanceOfficer entity with the requested GUID
     */
    public GovernanceOfficer getGovernanceOfficer(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getGovernanceOfficer";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        GovernanceOfficer gotgovernanceOfficer = GovernanceOfficerMapper.mapOmrsEntityDetailToGovernanceOfficer(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotgovernanceOfficer );
        }
        return gotgovernanceOfficer;

    }
    /**
     * Create new governanceOfficer.
     * @param userId user identity
     * @param governanceOfficer the input entity with values.
     * @return GovernanceOfficer the created entity.
     */

    public GovernanceOfficer createGovernanceOfficer(String userId,GovernanceOfficer governanceOfficer)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createGovernanceOfficer";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = GovernanceOfficerMapper.mapGovernanceOfficerToOmrsEntityDetail(governanceOfficer);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        GovernanceOfficer createdGovernanceOfficer =  GovernanceOfficerMapper.mapOmrsEntityDetailToGovernanceOfficer(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created GovernanceOfficer="+ createdGovernanceOfficer );
        }
        return createdGovernanceOfficer;
    }
    /**
     * Update governanceOfficer
     * @param userId user identity
     * @param governanceOfficer   governanceOfficer to update
     * @return GovernanceOfficer the updated governanceOfficer entity
     */
    public GovernanceOfficer updateGovernanceOfficer(String userId, GovernanceOfficer governanceOfficer)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateGovernanceOfficer";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = GovernanceOfficerMapper.mapGovernanceOfficerToOmrsEntityDetail(governanceOfficer);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            GovernanceOfficer updatedGovernanceOfficer =  GovernanceOfficerMapper.mapOmrsEntityDetailToGovernanceOfficer(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated GovernanceOfficer="+ updatedGovernanceOfficer );
            }
            return updatedGovernanceOfficer;
        }

    /**
     * Delete an governanceOfficer identified by its GUID. Delete is a soft delete, this means that the governanceOfficer has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the governanceOfficer
     * @return GovernanceOfficer the deleted GovernanceOfficer entity
     */

    public GovernanceOfficer deleteGovernanceOfficer(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteGovernanceOfficer";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GovernanceOfficer type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GovernanceOfficer");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"GovernanceOfficer",entityDef.getGUID(),entityGuid);
         GovernanceOfficer deletedGovernanceOfficer = GovernanceOfficerMapper.mapOmrsEntityDetailToGovernanceOfficer(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedGovernanceOfficer;

    }
    /**
     * Purge an governanceOfficer identified by its GUID. Delete is a hard delete, this means that the governanceOfficer is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the governanceOfficer
     */
    public void purgeGovernanceOfficer(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeGovernanceOfficer";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GovernanceOfficer type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GovernanceOfficer");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"GovernanceOfficer",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an GovernanceOfficer identified by its GUID. Restore resurrects a soft deleted GovernanceOfficer. When a GovernanceOfficer was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the GovernanceOfficer
     * @return  GovernanceOfficer the restored GovernanceOfficer
     */
    public GovernanceOfficer restoreGovernanceOfficer(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreGovernanceOfficer";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        GovernanceOfficer restoredGovernanceOfficer =  GovernanceOfficerMapper.mapOmrsEntityDetailToGovernanceOfficer(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredGovernanceOfficer;
    }    

    /**
     * Add classifications to the supplied governanceOfficer
     * @param userId user identity
     * @param entityGuid the GUID value for governanceOfficer
     * @param classifications the classifications to apply.
     * @return the governanceOfficer entity that has been classified
     */
     public GovernanceOfficer addGovernanceOfficerClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addGovernanceOfficerClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         GovernanceOfficer governanceOfficerClassificationBeans = GovernanceOfficerMapper.mapOmrsEntityDetailToGovernanceOfficer(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified GovernanceOfficer=" +  governanceOfficerClassificationBeans);
         }
         return  governanceOfficerClassificationBeans;
    }

    /**
     * Updates classifications to an existing governanceOfficer represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the governanceOfficer
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given governanceOfficer guid
     */
    public GovernanceOfficer updateGovernanceOfficerClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateGovernanceOfficerClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           GovernanceOfficer  governanceOfficerClassificationBeans = GovernanceOfficerMapper.mapOmrsEntityDetailToGovernanceOfficer(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  governanceOfficerClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing governanceOfficer represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the governanceOfficer
     * @param name name of the classification
     * @return deleted GovernanceOfficer  classification
     */
    public GovernanceOfficer deleteGovernanceOfficerClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteGovernanceOfficerClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       GovernanceOfficer declassifiedGovernanceOfficer =  GovernanceOfficerMapper.mapOmrsEntityDetailToGovernanceOfficer(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedGovernanceOfficer;
    }

    /**
      * Get the relationships associated with entity governanceOfficer represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the governanceOfficer
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getGovernanceOfficerRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getGovernanceOfficerRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an softwareServerCapability given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the softwareServerCapabilities relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return SoftwareServerCapability the SoftwareServerCapability entity with the requested GUID
     */
    public SoftwareServerCapability getSoftwareServerCapability(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getSoftwareServerCapability";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        SoftwareServerCapability gotsoftwareServerCapability = SoftwareServerCapabilityMapper.mapOmrsEntityDetailToSoftwareServerCapability(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotsoftwareServerCapability );
        }
        return gotsoftwareServerCapability;

    }
    /**
     * Create new softwareServerCapability.
     * @param userId user identity
     * @param softwareServerCapability the input entity with values.
     * @return SoftwareServerCapability the created entity.
     */

    public SoftwareServerCapability createSoftwareServerCapability(String userId,SoftwareServerCapability softwareServerCapability)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createSoftwareServerCapability";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = SoftwareServerCapabilityMapper.mapSoftwareServerCapabilityToOmrsEntityDetail(softwareServerCapability);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        SoftwareServerCapability createdSoftwareServerCapability =  SoftwareServerCapabilityMapper.mapOmrsEntityDetailToSoftwareServerCapability(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created SoftwareServerCapability="+ createdSoftwareServerCapability );
        }
        return createdSoftwareServerCapability;
    }
    /**
     * Update softwareServerCapability
     * @param userId user identity
     * @param softwareServerCapability   softwareServerCapability to update
     * @return SoftwareServerCapability the updated softwareServerCapability entity
     */
    public SoftwareServerCapability updateSoftwareServerCapability(String userId, SoftwareServerCapability softwareServerCapability)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateSoftwareServerCapability";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = SoftwareServerCapabilityMapper.mapSoftwareServerCapabilityToOmrsEntityDetail(softwareServerCapability);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            SoftwareServerCapability updatedSoftwareServerCapability =  SoftwareServerCapabilityMapper.mapOmrsEntityDetailToSoftwareServerCapability(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated SoftwareServerCapability="+ updatedSoftwareServerCapability );
            }
            return updatedSoftwareServerCapability;
        }

    /**
     * Delete an softwareServerCapability identified by its GUID. Delete is a soft delete, this means that the softwareServerCapability has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the softwareServerCapability
     * @return SoftwareServerCapability the deleted SoftwareServerCapability entity
     */

    public SoftwareServerCapability deleteSoftwareServerCapability(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteSoftwareServerCapability";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the SoftwareServerCapability type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("SoftwareServerCapability");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"SoftwareServerCapability",entityDef.getGUID(),entityGuid);
         SoftwareServerCapability deletedSoftwareServerCapability = SoftwareServerCapabilityMapper.mapOmrsEntityDetailToSoftwareServerCapability(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedSoftwareServerCapability;

    }
    /**
     * Purge an softwareServerCapability identified by its GUID. Delete is a hard delete, this means that the softwareServerCapability is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the softwareServerCapability
     */
    public void purgeSoftwareServerCapability(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeSoftwareServerCapability";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the SoftwareServerCapability type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("SoftwareServerCapability");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"SoftwareServerCapability",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an SoftwareServerCapability identified by its GUID. Restore resurrects a soft deleted SoftwareServerCapability. When a SoftwareServerCapability was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the SoftwareServerCapability
     * @return  SoftwareServerCapability the restored SoftwareServerCapability
     */
    public SoftwareServerCapability restoreSoftwareServerCapability(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreSoftwareServerCapability";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        SoftwareServerCapability restoredSoftwareServerCapability =  SoftwareServerCapabilityMapper.mapOmrsEntityDetailToSoftwareServerCapability(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredSoftwareServerCapability;
    }    

    /**
     * Add classifications to the supplied softwareServerCapability
     * @param userId user identity
     * @param entityGuid the GUID value for softwareServerCapability
     * @param classifications the classifications to apply.
     * @return the softwareServerCapability entity that has been classified
     */
     public SoftwareServerCapability addSoftwareServerCapabilityClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addSoftwareServerCapabilityClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         SoftwareServerCapability softwareServerCapabilityClassificationBeans = SoftwareServerCapabilityMapper.mapOmrsEntityDetailToSoftwareServerCapability(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified SoftwareServerCapability=" +  softwareServerCapabilityClassificationBeans);
         }
         return  softwareServerCapabilityClassificationBeans;
    }

    /**
     * Updates classifications to an existing softwareServerCapability represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the softwareServerCapability
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given softwareServerCapability guid
     */
    public SoftwareServerCapability updateSoftwareServerCapabilityClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateSoftwareServerCapabilityClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           SoftwareServerCapability  softwareServerCapabilityClassificationBeans = SoftwareServerCapabilityMapper.mapOmrsEntityDetailToSoftwareServerCapability(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  softwareServerCapabilityClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing softwareServerCapability represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the softwareServerCapability
     * @param name name of the classification
     * @return deleted SoftwareServerCapability  classification
     */
    public SoftwareServerCapability deleteSoftwareServerCapabilityClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteSoftwareServerCapabilityClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       SoftwareServerCapability declassifiedSoftwareServerCapability =  SoftwareServerCapabilityMapper.mapOmrsEntityDetailToSoftwareServerCapability(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedSoftwareServerCapability;
    }

    /**
      * Get the relationships associated with entity softwareServerCapability represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the softwareServerCapability
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getSoftwareServerCapabilityRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getSoftwareServerCapabilityRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an personRole given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the personRoles relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return PersonRole the PersonRole entity with the requested GUID
     */
    public PersonRole getPersonRole(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getPersonRole";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        PersonRole gotpersonRole = PersonRoleMapper.mapOmrsEntityDetailToPersonRole(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotpersonRole );
        }
        return gotpersonRole;

    }
    /**
     * Create new personRole.
     * @param userId user identity
     * @param personRole the input entity with values.
     * @return PersonRole the created entity.
     */

    public PersonRole createPersonRole(String userId,PersonRole personRole)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createPersonRole";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = PersonRoleMapper.mapPersonRoleToOmrsEntityDetail(personRole);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        PersonRole createdPersonRole =  PersonRoleMapper.mapOmrsEntityDetailToPersonRole(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created PersonRole="+ createdPersonRole );
        }
        return createdPersonRole;
    }
    /**
     * Update personRole
     * @param userId user identity
     * @param personRole   personRole to update
     * @return PersonRole the updated personRole entity
     */
    public PersonRole updatePersonRole(String userId, PersonRole personRole)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updatePersonRole";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = PersonRoleMapper.mapPersonRoleToOmrsEntityDetail(personRole);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            PersonRole updatedPersonRole =  PersonRoleMapper.mapOmrsEntityDetailToPersonRole(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated PersonRole="+ updatedPersonRole );
            }
            return updatedPersonRole;
        }

    /**
     * Delete an personRole identified by its GUID. Delete is a soft delete, this means that the personRole has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the personRole
     * @return PersonRole the deleted PersonRole entity
     */

    public PersonRole deletePersonRole(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deletePersonRole";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the PersonRole type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("PersonRole");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"PersonRole",entityDef.getGUID(),entityGuid);
         PersonRole deletedPersonRole = PersonRoleMapper.mapOmrsEntityDetailToPersonRole(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedPersonRole;

    }
    /**
     * Purge an personRole identified by its GUID. Delete is a hard delete, this means that the personRole is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the personRole
     */
    public void purgePersonRole(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgePersonRole";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the PersonRole type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("PersonRole");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"PersonRole",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an PersonRole identified by its GUID. Restore resurrects a soft deleted PersonRole. When a PersonRole was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the PersonRole
     * @return  PersonRole the restored PersonRole
     */
    public PersonRole restorePersonRole(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restorePersonRole";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        PersonRole restoredPersonRole =  PersonRoleMapper.mapOmrsEntityDetailToPersonRole(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredPersonRole;
    }    

    /**
     * Add classifications to the supplied personRole
     * @param userId user identity
     * @param entityGuid the GUID value for personRole
     * @param classifications the classifications to apply.
     * @return the personRole entity that has been classified
     */
     public PersonRole addPersonRoleClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addPersonRoleClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         PersonRole personRoleClassificationBeans = PersonRoleMapper.mapOmrsEntityDetailToPersonRole(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified PersonRole=" +  personRoleClassificationBeans);
         }
         return  personRoleClassificationBeans;
    }

    /**
     * Updates classifications to an existing personRole represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the personRole
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given personRole guid
     */
    public PersonRole updatePersonRoleClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updatePersonRoleClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           PersonRole  personRoleClassificationBeans = PersonRoleMapper.mapOmrsEntityDetailToPersonRole(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  personRoleClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing personRole represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the personRole
     * @param name name of the classification
     * @return deleted PersonRole  classification
     */
    public PersonRole deletePersonRoleClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deletePersonRoleClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       PersonRole declassifiedPersonRole =  PersonRoleMapper.mapOmrsEntityDetailToPersonRole(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedPersonRole;
    }

    /**
      * Get the relationships associated with entity personRole represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the personRole
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getPersonRoleRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getPersonRoleRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an licenseType given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the licenseTypes relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return LicenseType the LicenseType entity with the requested GUID
     */
    public LicenseType getLicenseType(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getLicenseType";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        LicenseType gotlicenseType = LicenseTypeMapper.mapOmrsEntityDetailToLicenseType(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotlicenseType );
        }
        return gotlicenseType;

    }
    /**
     * Create new licenseType.
     * @param userId user identity
     * @param licenseType the input entity with values.
     * @return LicenseType the created entity.
     */

    public LicenseType createLicenseType(String userId,LicenseType licenseType)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createLicenseType";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = LicenseTypeMapper.mapLicenseTypeToOmrsEntityDetail(licenseType);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        LicenseType createdLicenseType =  LicenseTypeMapper.mapOmrsEntityDetailToLicenseType(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created LicenseType="+ createdLicenseType );
        }
        return createdLicenseType;
    }
    /**
     * Update licenseType
     * @param userId user identity
     * @param licenseType   licenseType to update
     * @return LicenseType the updated licenseType entity
     */
    public LicenseType updateLicenseType(String userId, LicenseType licenseType)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateLicenseType";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = LicenseTypeMapper.mapLicenseTypeToOmrsEntityDetail(licenseType);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            LicenseType updatedLicenseType =  LicenseTypeMapper.mapOmrsEntityDetailToLicenseType(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated LicenseType="+ updatedLicenseType );
            }
            return updatedLicenseType;
        }

    /**
     * Delete an licenseType identified by its GUID. Delete is a soft delete, this means that the licenseType has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the licenseType
     * @return LicenseType the deleted LicenseType entity
     */

    public LicenseType deleteLicenseType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteLicenseType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the LicenseType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("LicenseType");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"LicenseType",entityDef.getGUID(),entityGuid);
         LicenseType deletedLicenseType = LicenseTypeMapper.mapOmrsEntityDetailToLicenseType(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedLicenseType;

    }
    /**
     * Purge an licenseType identified by its GUID. Delete is a hard delete, this means that the licenseType is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the licenseType
     */
    public void purgeLicenseType(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeLicenseType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the LicenseType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("LicenseType");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"LicenseType",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an LicenseType identified by its GUID. Restore resurrects a soft deleted LicenseType. When a LicenseType was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the LicenseType
     * @return  LicenseType the restored LicenseType
     */
    public LicenseType restoreLicenseType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreLicenseType";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        LicenseType restoredLicenseType =  LicenseTypeMapper.mapOmrsEntityDetailToLicenseType(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredLicenseType;
    }    

    /**
     * Add classifications to the supplied licenseType
     * @param userId user identity
     * @param entityGuid the GUID value for licenseType
     * @param classifications the classifications to apply.
     * @return the licenseType entity that has been classified
     */
     public LicenseType addLicenseTypeClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addLicenseTypeClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         LicenseType licenseTypeClassificationBeans = LicenseTypeMapper.mapOmrsEntityDetailToLicenseType(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified LicenseType=" +  licenseTypeClassificationBeans);
         }
         return  licenseTypeClassificationBeans;
    }

    /**
     * Updates classifications to an existing licenseType represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the licenseType
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given licenseType guid
     */
    public LicenseType updateLicenseTypeClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateLicenseTypeClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           LicenseType  licenseTypeClassificationBeans = LicenseTypeMapper.mapOmrsEntityDetailToLicenseType(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  licenseTypeClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing licenseType represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the licenseType
     * @param name name of the classification
     * @return deleted LicenseType  classification
     */
    public LicenseType deleteLicenseTypeClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteLicenseTypeClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       LicenseType declassifiedLicenseType =  LicenseTypeMapper.mapOmrsEntityDetailToLicenseType(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedLicenseType;
    }

    /**
      * Get the relationships associated with entity licenseType represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the licenseType
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getLicenseTypeRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getLicenseTypeRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an schemaAnalysisAnnotation given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the schemaAnalysisAnnotations relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return SchemaAnalysisAnnotation the SchemaAnalysisAnnotation entity with the requested GUID
     */
    public SchemaAnalysisAnnotation getSchemaAnalysisAnnotation(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getSchemaAnalysisAnnotation";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        SchemaAnalysisAnnotation gotschemaAnalysisAnnotation = SchemaAnalysisAnnotationMapper.mapOmrsEntityDetailToSchemaAnalysisAnnotation(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotschemaAnalysisAnnotation );
        }
        return gotschemaAnalysisAnnotation;

    }
    /**
     * Create new schemaAnalysisAnnotation.
     * @param userId user identity
     * @param schemaAnalysisAnnotation the input entity with values.
     * @return SchemaAnalysisAnnotation the created entity.
     */

    public SchemaAnalysisAnnotation createSchemaAnalysisAnnotation(String userId,SchemaAnalysisAnnotation schemaAnalysisAnnotation)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createSchemaAnalysisAnnotation";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = SchemaAnalysisAnnotationMapper.mapSchemaAnalysisAnnotationToOmrsEntityDetail(schemaAnalysisAnnotation);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        SchemaAnalysisAnnotation createdSchemaAnalysisAnnotation =  SchemaAnalysisAnnotationMapper.mapOmrsEntityDetailToSchemaAnalysisAnnotation(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created SchemaAnalysisAnnotation="+ createdSchemaAnalysisAnnotation );
        }
        return createdSchemaAnalysisAnnotation;
    }
    /**
     * Update schemaAnalysisAnnotation
     * @param userId user identity
     * @param schemaAnalysisAnnotation   schemaAnalysisAnnotation to update
     * @return SchemaAnalysisAnnotation the updated schemaAnalysisAnnotation entity
     */
    public SchemaAnalysisAnnotation updateSchemaAnalysisAnnotation(String userId, SchemaAnalysisAnnotation schemaAnalysisAnnotation)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateSchemaAnalysisAnnotation";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = SchemaAnalysisAnnotationMapper.mapSchemaAnalysisAnnotationToOmrsEntityDetail(schemaAnalysisAnnotation);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            SchemaAnalysisAnnotation updatedSchemaAnalysisAnnotation =  SchemaAnalysisAnnotationMapper.mapOmrsEntityDetailToSchemaAnalysisAnnotation(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated SchemaAnalysisAnnotation="+ updatedSchemaAnalysisAnnotation );
            }
            return updatedSchemaAnalysisAnnotation;
        }

    /**
     * Delete an schemaAnalysisAnnotation identified by its GUID. Delete is a soft delete, this means that the schemaAnalysisAnnotation has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the schemaAnalysisAnnotation
     * @return SchemaAnalysisAnnotation the deleted SchemaAnalysisAnnotation entity
     */

    public SchemaAnalysisAnnotation deleteSchemaAnalysisAnnotation(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteSchemaAnalysisAnnotation";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the SchemaAnalysisAnnotation type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("SchemaAnalysisAnnotation");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"SchemaAnalysisAnnotation",entityDef.getGUID(),entityGuid);
         SchemaAnalysisAnnotation deletedSchemaAnalysisAnnotation = SchemaAnalysisAnnotationMapper.mapOmrsEntityDetailToSchemaAnalysisAnnotation(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedSchemaAnalysisAnnotation;

    }
    /**
     * Purge an schemaAnalysisAnnotation identified by its GUID. Delete is a hard delete, this means that the schemaAnalysisAnnotation is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the schemaAnalysisAnnotation
     */
    public void purgeSchemaAnalysisAnnotation(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeSchemaAnalysisAnnotation";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the SchemaAnalysisAnnotation type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("SchemaAnalysisAnnotation");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"SchemaAnalysisAnnotation",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an SchemaAnalysisAnnotation identified by its GUID. Restore resurrects a soft deleted SchemaAnalysisAnnotation. When a SchemaAnalysisAnnotation was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the SchemaAnalysisAnnotation
     * @return  SchemaAnalysisAnnotation the restored SchemaAnalysisAnnotation
     */
    public SchemaAnalysisAnnotation restoreSchemaAnalysisAnnotation(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreSchemaAnalysisAnnotation";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        SchemaAnalysisAnnotation restoredSchemaAnalysisAnnotation =  SchemaAnalysisAnnotationMapper.mapOmrsEntityDetailToSchemaAnalysisAnnotation(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredSchemaAnalysisAnnotation;
    }    

    /**
     * Add classifications to the supplied schemaAnalysisAnnotation
     * @param userId user identity
     * @param entityGuid the GUID value for schemaAnalysisAnnotation
     * @param classifications the classifications to apply.
     * @return the schemaAnalysisAnnotation entity that has been classified
     */
     public SchemaAnalysisAnnotation addSchemaAnalysisAnnotationClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addSchemaAnalysisAnnotationClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         SchemaAnalysisAnnotation schemaAnalysisAnnotationClassificationBeans = SchemaAnalysisAnnotationMapper.mapOmrsEntityDetailToSchemaAnalysisAnnotation(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified SchemaAnalysisAnnotation=" +  schemaAnalysisAnnotationClassificationBeans);
         }
         return  schemaAnalysisAnnotationClassificationBeans;
    }

    /**
     * Updates classifications to an existing schemaAnalysisAnnotation represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the schemaAnalysisAnnotation
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given schemaAnalysisAnnotation guid
     */
    public SchemaAnalysisAnnotation updateSchemaAnalysisAnnotationClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateSchemaAnalysisAnnotationClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           SchemaAnalysisAnnotation  schemaAnalysisAnnotationClassificationBeans = SchemaAnalysisAnnotationMapper.mapOmrsEntityDetailToSchemaAnalysisAnnotation(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  schemaAnalysisAnnotationClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing schemaAnalysisAnnotation represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the schemaAnalysisAnnotation
     * @param name name of the classification
     * @return deleted SchemaAnalysisAnnotation  classification
     */
    public SchemaAnalysisAnnotation deleteSchemaAnalysisAnnotationClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteSchemaAnalysisAnnotationClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       SchemaAnalysisAnnotation declassifiedSchemaAnalysisAnnotation =  SchemaAnalysisAnnotationMapper.mapOmrsEntityDetailToSchemaAnalysisAnnotation(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedSchemaAnalysisAnnotation;
    }

    /**
      * Get the relationships associated with entity schemaAnalysisAnnotation represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the schemaAnalysisAnnotation
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getSchemaAnalysisAnnotationRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getSchemaAnalysisAnnotationRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an iTProfile given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the iTProfiles relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return ITProfile the ITProfile entity with the requested GUID
     */
    public ITProfile getITProfile(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getITProfile";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        ITProfile gotiTProfile = ITProfileMapper.mapOmrsEntityDetailToITProfile(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotiTProfile );
        }
        return gotiTProfile;

    }
    /**
     * Create new iTProfile.
     * @param userId user identity
     * @param iTProfile the input entity with values.
     * @return ITProfile the created entity.
     */

    public ITProfile createITProfile(String userId,ITProfile iTProfile)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createITProfile";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = ITProfileMapper.mapITProfileToOmrsEntityDetail(iTProfile);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        ITProfile createdITProfile =  ITProfileMapper.mapOmrsEntityDetailToITProfile(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created ITProfile="+ createdITProfile );
        }
        return createdITProfile;
    }
    /**
     * Update iTProfile
     * @param userId user identity
     * @param iTProfile   iTProfile to update
     * @return ITProfile the updated iTProfile entity
     */
    public ITProfile updateITProfile(String userId, ITProfile iTProfile)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateITProfile";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = ITProfileMapper.mapITProfileToOmrsEntityDetail(iTProfile);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            ITProfile updatedITProfile =  ITProfileMapper.mapOmrsEntityDetailToITProfile(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated ITProfile="+ updatedITProfile );
            }
            return updatedITProfile;
        }

    /**
     * Delete an iTProfile identified by its GUID. Delete is a soft delete, this means that the iTProfile has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the iTProfile
     * @return ITProfile the deleted ITProfile entity
     */

    public ITProfile deleteITProfile(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteITProfile";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ITProfile type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ITProfile");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"ITProfile",entityDef.getGUID(),entityGuid);
         ITProfile deletedITProfile = ITProfileMapper.mapOmrsEntityDetailToITProfile(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedITProfile;

    }
    /**
     * Purge an iTProfile identified by its GUID. Delete is a hard delete, this means that the iTProfile is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the iTProfile
     */
    public void purgeITProfile(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeITProfile";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ITProfile type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ITProfile");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"ITProfile",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an ITProfile identified by its GUID. Restore resurrects a soft deleted ITProfile. When a ITProfile was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the ITProfile
     * @return  ITProfile the restored ITProfile
     */
    public ITProfile restoreITProfile(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreITProfile";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        ITProfile restoredITProfile =  ITProfileMapper.mapOmrsEntityDetailToITProfile(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredITProfile;
    }    

    /**
     * Add classifications to the supplied iTProfile
     * @param userId user identity
     * @param entityGuid the GUID value for iTProfile
     * @param classifications the classifications to apply.
     * @return the iTProfile entity that has been classified
     */
     public ITProfile addITProfileClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addITProfileClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         ITProfile iTProfileClassificationBeans = ITProfileMapper.mapOmrsEntityDetailToITProfile(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified ITProfile=" +  iTProfileClassificationBeans);
         }
         return  iTProfileClassificationBeans;
    }

    /**
     * Updates classifications to an existing iTProfile represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the iTProfile
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given iTProfile guid
     */
    public ITProfile updateITProfileClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateITProfileClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           ITProfile  iTProfileClassificationBeans = ITProfileMapper.mapOmrsEntityDetailToITProfile(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  iTProfileClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing iTProfile represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the iTProfile
     * @param name name of the classification
     * @return deleted ITProfile  classification
     */
    public ITProfile deleteITProfileClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteITProfileClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       ITProfile declassifiedITProfile =  ITProfileMapper.mapOmrsEntityDetailToITProfile(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedITProfile;
    }

    /**
      * Get the relationships associated with entity iTProfile represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the iTProfile
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getITProfileRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getITProfileRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an graphVertex given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the graphVertexs relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return GraphVertex the GraphVertex entity with the requested GUID
     */
    public GraphVertex getGraphVertex(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getGraphVertex";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        GraphVertex gotgraphVertex = GraphVertexMapper.mapOmrsEntityDetailToGraphVertex(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotgraphVertex );
        }
        return gotgraphVertex;

    }
    /**
     * Create new graphVertex.
     * @param userId user identity
     * @param graphVertex the input entity with values.
     * @return GraphVertex the created entity.
     */

    public GraphVertex createGraphVertex(String userId,GraphVertex graphVertex)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createGraphVertex";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = GraphVertexMapper.mapGraphVertexToOmrsEntityDetail(graphVertex);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        GraphVertex createdGraphVertex =  GraphVertexMapper.mapOmrsEntityDetailToGraphVertex(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created GraphVertex="+ createdGraphVertex );
        }
        return createdGraphVertex;
    }
    /**
     * Update graphVertex
     * @param userId user identity
     * @param graphVertex   graphVertex to update
     * @return GraphVertex the updated graphVertex entity
     */
    public GraphVertex updateGraphVertex(String userId, GraphVertex graphVertex)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateGraphVertex";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = GraphVertexMapper.mapGraphVertexToOmrsEntityDetail(graphVertex);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            GraphVertex updatedGraphVertex =  GraphVertexMapper.mapOmrsEntityDetailToGraphVertex(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated GraphVertex="+ updatedGraphVertex );
            }
            return updatedGraphVertex;
        }

    /**
     * Delete an graphVertex identified by its GUID. Delete is a soft delete, this means that the graphVertex has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the graphVertex
     * @return GraphVertex the deleted GraphVertex entity
     */

    public GraphVertex deleteGraphVertex(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteGraphVertex";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GraphVertex type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GraphVertex");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"GraphVertex",entityDef.getGUID(),entityGuid);
         GraphVertex deletedGraphVertex = GraphVertexMapper.mapOmrsEntityDetailToGraphVertex(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedGraphVertex;

    }
    /**
     * Purge an graphVertex identified by its GUID. Delete is a hard delete, this means that the graphVertex is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the graphVertex
     */
    public void purgeGraphVertex(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeGraphVertex";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GraphVertex type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GraphVertex");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"GraphVertex",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an GraphVertex identified by its GUID. Restore resurrects a soft deleted GraphVertex. When a GraphVertex was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the GraphVertex
     * @return  GraphVertex the restored GraphVertex
     */
    public GraphVertex restoreGraphVertex(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreGraphVertex";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        GraphVertex restoredGraphVertex =  GraphVertexMapper.mapOmrsEntityDetailToGraphVertex(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredGraphVertex;
    }    

    /**
     * Add classifications to the supplied graphVertex
     * @param userId user identity
     * @param entityGuid the GUID value for graphVertex
     * @param classifications the classifications to apply.
     * @return the graphVertex entity that has been classified
     */
     public GraphVertex addGraphVertexClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addGraphVertexClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         GraphVertex graphVertexClassificationBeans = GraphVertexMapper.mapOmrsEntityDetailToGraphVertex(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified GraphVertex=" +  graphVertexClassificationBeans);
         }
         return  graphVertexClassificationBeans;
    }

    /**
     * Updates classifications to an existing graphVertex represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the graphVertex
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given graphVertex guid
     */
    public GraphVertex updateGraphVertexClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateGraphVertexClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           GraphVertex  graphVertexClassificationBeans = GraphVertexMapper.mapOmrsEntityDetailToGraphVertex(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  graphVertexClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing graphVertex represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the graphVertex
     * @param name name of the classification
     * @return deleted GraphVertex  classification
     */
    public GraphVertex deleteGraphVertexClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteGraphVertexClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       GraphVertex declassifiedGraphVertex =  GraphVertexMapper.mapOmrsEntityDetailToGraphVertex(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedGraphVertex;
    }

    /**
      * Get the relationships associated with entity graphVertex represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the graphVertex
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getGraphVertexRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getGraphVertexRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an dataSourcePhysicalStatusAnnotation given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the dataSourcePhysicalStatusAnnotations relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return DataSourcePhysicalStatusAnnotation the DataSourcePhysicalStatusAnnotation entity with the requested GUID
     */
    public DataSourcePhysicalStatusAnnotation getDataSourcePhysicalStatusAnnotation(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getDataSourcePhysicalStatusAnnotation";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        DataSourcePhysicalStatusAnnotation gotdataSourcePhysicalStatusAnnotation = DataSourcePhysicalStatusAnnotationMapper.mapOmrsEntityDetailToDataSourcePhysicalStatusAnnotation(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotdataSourcePhysicalStatusAnnotation );
        }
        return gotdataSourcePhysicalStatusAnnotation;

    }
    /**
     * Create new dataSourcePhysicalStatusAnnotation.
     * @param userId user identity
     * @param dataSourcePhysicalStatusAnnotation the input entity with values.
     * @return DataSourcePhysicalStatusAnnotation the created entity.
     */

    public DataSourcePhysicalStatusAnnotation createDataSourcePhysicalStatusAnnotation(String userId,DataSourcePhysicalStatusAnnotation dataSourcePhysicalStatusAnnotation)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createDataSourcePhysicalStatusAnnotation";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = DataSourcePhysicalStatusAnnotationMapper.mapDataSourcePhysicalStatusAnnotationToOmrsEntityDetail(dataSourcePhysicalStatusAnnotation);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        DataSourcePhysicalStatusAnnotation createdDataSourcePhysicalStatusAnnotation =  DataSourcePhysicalStatusAnnotationMapper.mapOmrsEntityDetailToDataSourcePhysicalStatusAnnotation(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created DataSourcePhysicalStatusAnnotation="+ createdDataSourcePhysicalStatusAnnotation );
        }
        return createdDataSourcePhysicalStatusAnnotation;
    }
    /**
     * Update dataSourcePhysicalStatusAnnotation
     * @param userId user identity
     * @param dataSourcePhysicalStatusAnnotation   dataSourcePhysicalStatusAnnotation to update
     * @return DataSourcePhysicalStatusAnnotation the updated dataSourcePhysicalStatusAnnotation entity
     */
    public DataSourcePhysicalStatusAnnotation updateDataSourcePhysicalStatusAnnotation(String userId, DataSourcePhysicalStatusAnnotation dataSourcePhysicalStatusAnnotation)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateDataSourcePhysicalStatusAnnotation";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = DataSourcePhysicalStatusAnnotationMapper.mapDataSourcePhysicalStatusAnnotationToOmrsEntityDetail(dataSourcePhysicalStatusAnnotation);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            DataSourcePhysicalStatusAnnotation updatedDataSourcePhysicalStatusAnnotation =  DataSourcePhysicalStatusAnnotationMapper.mapOmrsEntityDetailToDataSourcePhysicalStatusAnnotation(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated DataSourcePhysicalStatusAnnotation="+ updatedDataSourcePhysicalStatusAnnotation );
            }
            return updatedDataSourcePhysicalStatusAnnotation;
        }

    /**
     * Delete an dataSourcePhysicalStatusAnnotation identified by its GUID. Delete is a soft delete, this means that the dataSourcePhysicalStatusAnnotation has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the dataSourcePhysicalStatusAnnotation
     * @return DataSourcePhysicalStatusAnnotation the deleted DataSourcePhysicalStatusAnnotation entity
     */

    public DataSourcePhysicalStatusAnnotation deleteDataSourcePhysicalStatusAnnotation(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteDataSourcePhysicalStatusAnnotation";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DataSourcePhysicalStatusAnnotation type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DataSourcePhysicalStatusAnnotation");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"DataSourcePhysicalStatusAnnotation",entityDef.getGUID(),entityGuid);
         DataSourcePhysicalStatusAnnotation deletedDataSourcePhysicalStatusAnnotation = DataSourcePhysicalStatusAnnotationMapper.mapOmrsEntityDetailToDataSourcePhysicalStatusAnnotation(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedDataSourcePhysicalStatusAnnotation;

    }
    /**
     * Purge an dataSourcePhysicalStatusAnnotation identified by its GUID. Delete is a hard delete, this means that the dataSourcePhysicalStatusAnnotation is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the dataSourcePhysicalStatusAnnotation
     */
    public void purgeDataSourcePhysicalStatusAnnotation(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeDataSourcePhysicalStatusAnnotation";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DataSourcePhysicalStatusAnnotation type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DataSourcePhysicalStatusAnnotation");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"DataSourcePhysicalStatusAnnotation",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an DataSourcePhysicalStatusAnnotation identified by its GUID. Restore resurrects a soft deleted DataSourcePhysicalStatusAnnotation. When a DataSourcePhysicalStatusAnnotation was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the DataSourcePhysicalStatusAnnotation
     * @return  DataSourcePhysicalStatusAnnotation the restored DataSourcePhysicalStatusAnnotation
     */
    public DataSourcePhysicalStatusAnnotation restoreDataSourcePhysicalStatusAnnotation(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreDataSourcePhysicalStatusAnnotation";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        DataSourcePhysicalStatusAnnotation restoredDataSourcePhysicalStatusAnnotation =  DataSourcePhysicalStatusAnnotationMapper.mapOmrsEntityDetailToDataSourcePhysicalStatusAnnotation(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredDataSourcePhysicalStatusAnnotation;
    }    

    /**
     * Add classifications to the supplied dataSourcePhysicalStatusAnnotation
     * @param userId user identity
     * @param entityGuid the GUID value for dataSourcePhysicalStatusAnnotation
     * @param classifications the classifications to apply.
     * @return the dataSourcePhysicalStatusAnnotation entity that has been classified
     */
     public DataSourcePhysicalStatusAnnotation addDataSourcePhysicalStatusAnnotationClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addDataSourcePhysicalStatusAnnotationClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         DataSourcePhysicalStatusAnnotation dataSourcePhysicalStatusAnnotationClassificationBeans = DataSourcePhysicalStatusAnnotationMapper.mapOmrsEntityDetailToDataSourcePhysicalStatusAnnotation(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified DataSourcePhysicalStatusAnnotation=" +  dataSourcePhysicalStatusAnnotationClassificationBeans);
         }
         return  dataSourcePhysicalStatusAnnotationClassificationBeans;
    }

    /**
     * Updates classifications to an existing dataSourcePhysicalStatusAnnotation represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the dataSourcePhysicalStatusAnnotation
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given dataSourcePhysicalStatusAnnotation guid
     */
    public DataSourcePhysicalStatusAnnotation updateDataSourcePhysicalStatusAnnotationClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateDataSourcePhysicalStatusAnnotationClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           DataSourcePhysicalStatusAnnotation  dataSourcePhysicalStatusAnnotationClassificationBeans = DataSourcePhysicalStatusAnnotationMapper.mapOmrsEntityDetailToDataSourcePhysicalStatusAnnotation(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  dataSourcePhysicalStatusAnnotationClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing dataSourcePhysicalStatusAnnotation represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the dataSourcePhysicalStatusAnnotation
     * @param name name of the classification
     * @return deleted DataSourcePhysicalStatusAnnotation  classification
     */
    public DataSourcePhysicalStatusAnnotation deleteDataSourcePhysicalStatusAnnotationClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteDataSourcePhysicalStatusAnnotationClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       DataSourcePhysicalStatusAnnotation declassifiedDataSourcePhysicalStatusAnnotation =  DataSourcePhysicalStatusAnnotationMapper.mapOmrsEntityDetailToDataSourcePhysicalStatusAnnotation(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedDataSourcePhysicalStatusAnnotation;
    }

    /**
      * Get the relationships associated with entity dataSourcePhysicalStatusAnnotation represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the dataSourcePhysicalStatusAnnotation
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getDataSourcePhysicalStatusAnnotationRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getDataSourcePhysicalStatusAnnotationRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an glossaryTerm given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the glossaryTerms relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return GlossaryTerm the GlossaryTerm entity with the requested GUID
     */
    public GlossaryTerm getGlossaryTerm(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getGlossaryTerm";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        GlossaryTerm gotglossaryTerm = GlossaryTermMapper.mapOmrsEntityDetailToGlossaryTerm(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotglossaryTerm );
        }
        return gotglossaryTerm;

    }
    /**
     * Create new glossaryTerm.
     * @param userId user identity
     * @param glossaryTerm the input entity with values.
     * @return GlossaryTerm the created entity.
     */

    public GlossaryTerm createGlossaryTerm(String userId,GlossaryTerm glossaryTerm)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createGlossaryTerm";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = GlossaryTermMapper.mapGlossaryTermToOmrsEntityDetail(glossaryTerm);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        GlossaryTerm createdGlossaryTerm =  GlossaryTermMapper.mapOmrsEntityDetailToGlossaryTerm(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created GlossaryTerm="+ createdGlossaryTerm );
        }
        return createdGlossaryTerm;
    }
    /**
     * Update glossaryTerm
     * @param userId user identity
     * @param glossaryTerm   glossaryTerm to update
     * @return GlossaryTerm the updated glossaryTerm entity
     */
    public GlossaryTerm updateGlossaryTerm(String userId, GlossaryTerm glossaryTerm)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateGlossaryTerm";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = GlossaryTermMapper.mapGlossaryTermToOmrsEntityDetail(glossaryTerm);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            GlossaryTerm updatedGlossaryTerm =  GlossaryTermMapper.mapOmrsEntityDetailToGlossaryTerm(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated GlossaryTerm="+ updatedGlossaryTerm );
            }
            return updatedGlossaryTerm;
        }

    /**
     * Delete an glossaryTerm identified by its GUID. Delete is a soft delete, this means that the glossaryTerm has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the glossaryTerm
     * @return GlossaryTerm the deleted GlossaryTerm entity
     */

    public GlossaryTerm deleteGlossaryTerm(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteGlossaryTerm";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GlossaryTerm type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GlossaryTerm");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"GlossaryTerm",entityDef.getGUID(),entityGuid);
         GlossaryTerm deletedGlossaryTerm = GlossaryTermMapper.mapOmrsEntityDetailToGlossaryTerm(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedGlossaryTerm;

    }
    /**
     * Purge an glossaryTerm identified by its GUID. Delete is a hard delete, this means that the glossaryTerm is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the glossaryTerm
     */
    public void purgeGlossaryTerm(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeGlossaryTerm";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GlossaryTerm type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GlossaryTerm");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"GlossaryTerm",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an GlossaryTerm identified by its GUID. Restore resurrects a soft deleted GlossaryTerm. When a GlossaryTerm was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the GlossaryTerm
     * @return  GlossaryTerm the restored GlossaryTerm
     */
    public GlossaryTerm restoreGlossaryTerm(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreGlossaryTerm";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        GlossaryTerm restoredGlossaryTerm =  GlossaryTermMapper.mapOmrsEntityDetailToGlossaryTerm(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredGlossaryTerm;
    }    

    /**
     * Add classifications to the supplied glossaryTerm
     * @param userId user identity
     * @param entityGuid the GUID value for glossaryTerm
     * @param classifications the classifications to apply.
     * @return the glossaryTerm entity that has been classified
     */
     public GlossaryTerm addGlossaryTermClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addGlossaryTermClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         GlossaryTerm glossaryTermClassificationBeans = GlossaryTermMapper.mapOmrsEntityDetailToGlossaryTerm(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified GlossaryTerm=" +  glossaryTermClassificationBeans);
         }
         return  glossaryTermClassificationBeans;
    }

    /**
     * Updates classifications to an existing glossaryTerm represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the glossaryTerm
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given glossaryTerm guid
     */
    public GlossaryTerm updateGlossaryTermClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateGlossaryTermClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           GlossaryTerm  glossaryTermClassificationBeans = GlossaryTermMapper.mapOmrsEntityDetailToGlossaryTerm(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  glossaryTermClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing glossaryTerm represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the glossaryTerm
     * @param name name of the classification
     * @return deleted GlossaryTerm  classification
     */
    public GlossaryTerm deleteGlossaryTermClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteGlossaryTermClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       GlossaryTerm declassifiedGlossaryTerm =  GlossaryTermMapper.mapOmrsEntityDetailToGlossaryTerm(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedGlossaryTerm;
    }

    /**
      * Get the relationships associated with entity glossaryTerm represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the glossaryTerm
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getGlossaryTermRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getGlossaryTermRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an metadataCollection given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the metadataCollections relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return MetadataCollection the MetadataCollection entity with the requested GUID
     */
    public MetadataCollection getMetadataCollection(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getMetadataCollection";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        MetadataCollection gotmetadataCollection = MetadataCollectionMapper.mapOmrsEntityDetailToMetadataCollection(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotmetadataCollection );
        }
        return gotmetadataCollection;

    }
    /**
     * Create new metadataCollection.
     * @param userId user identity
     * @param metadataCollection the input entity with values.
     * @return MetadataCollection the created entity.
     */

    public MetadataCollection createMetadataCollection(String userId,MetadataCollection metadataCollection)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createMetadataCollection";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = MetadataCollectionMapper.mapMetadataCollectionToOmrsEntityDetail(metadataCollection);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        MetadataCollection createdMetadataCollection =  MetadataCollectionMapper.mapOmrsEntityDetailToMetadataCollection(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created MetadataCollection="+ createdMetadataCollection );
        }
        return createdMetadataCollection;
    }
    /**
     * Update metadataCollection
     * @param userId user identity
     * @param metadataCollection   metadataCollection to update
     * @return MetadataCollection the updated metadataCollection entity
     */
    public MetadataCollection updateMetadataCollection(String userId, MetadataCollection metadataCollection)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateMetadataCollection";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = MetadataCollectionMapper.mapMetadataCollectionToOmrsEntityDetail(metadataCollection);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            MetadataCollection updatedMetadataCollection =  MetadataCollectionMapper.mapOmrsEntityDetailToMetadataCollection(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated MetadataCollection="+ updatedMetadataCollection );
            }
            return updatedMetadataCollection;
        }

    /**
     * Delete an metadataCollection identified by its GUID. Delete is a soft delete, this means that the metadataCollection has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the metadataCollection
     * @return MetadataCollection the deleted MetadataCollection entity
     */

    public MetadataCollection deleteMetadataCollection(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteMetadataCollection";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the MetadataCollection type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("MetadataCollection");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"MetadataCollection",entityDef.getGUID(),entityGuid);
         MetadataCollection deletedMetadataCollection = MetadataCollectionMapper.mapOmrsEntityDetailToMetadataCollection(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedMetadataCollection;

    }
    /**
     * Purge an metadataCollection identified by its GUID. Delete is a hard delete, this means that the metadataCollection is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the metadataCollection
     */
    public void purgeMetadataCollection(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeMetadataCollection";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the MetadataCollection type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("MetadataCollection");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"MetadataCollection",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an MetadataCollection identified by its GUID. Restore resurrects a soft deleted MetadataCollection. When a MetadataCollection was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the MetadataCollection
     * @return  MetadataCollection the restored MetadataCollection
     */
    public MetadataCollection restoreMetadataCollection(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreMetadataCollection";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        MetadataCollection restoredMetadataCollection =  MetadataCollectionMapper.mapOmrsEntityDetailToMetadataCollection(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredMetadataCollection;
    }    

    /**
     * Add classifications to the supplied metadataCollection
     * @param userId user identity
     * @param entityGuid the GUID value for metadataCollection
     * @param classifications the classifications to apply.
     * @return the metadataCollection entity that has been classified
     */
     public MetadataCollection addMetadataCollectionClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addMetadataCollectionClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         MetadataCollection metadataCollectionClassificationBeans = MetadataCollectionMapper.mapOmrsEntityDetailToMetadataCollection(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified MetadataCollection=" +  metadataCollectionClassificationBeans);
         }
         return  metadataCollectionClassificationBeans;
    }

    /**
     * Updates classifications to an existing metadataCollection represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the metadataCollection
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given metadataCollection guid
     */
    public MetadataCollection updateMetadataCollectionClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateMetadataCollectionClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           MetadataCollection  metadataCollectionClassificationBeans = MetadataCollectionMapper.mapOmrsEntityDetailToMetadataCollection(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  metadataCollectionClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing metadataCollection represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the metadataCollection
     * @param name name of the classification
     * @return deleted MetadataCollection  classification
     */
    public MetadataCollection deleteMetadataCollectionClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteMetadataCollectionClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       MetadataCollection declassifiedMetadataCollection =  MetadataCollectionMapper.mapOmrsEntityDetailToMetadataCollection(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedMetadataCollection;
    }

    /**
      * Get the relationships associated with entity metadataCollection represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the metadataCollection
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getMetadataCollectionRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getMetadataCollectionRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an governanceControl given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the governanceControls relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return GovernanceControl the GovernanceControl entity with the requested GUID
     */
    public GovernanceControl getGovernanceControl(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getGovernanceControl";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        GovernanceControl gotgovernanceControl = GovernanceControlMapper.mapOmrsEntityDetailToGovernanceControl(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotgovernanceControl );
        }
        return gotgovernanceControl;

    }
    /**
     * Create new governanceControl.
     * @param userId user identity
     * @param governanceControl the input entity with values.
     * @return GovernanceControl the created entity.
     */

    public GovernanceControl createGovernanceControl(String userId,GovernanceControl governanceControl)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createGovernanceControl";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = GovernanceControlMapper.mapGovernanceControlToOmrsEntityDetail(governanceControl);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        GovernanceControl createdGovernanceControl =  GovernanceControlMapper.mapOmrsEntityDetailToGovernanceControl(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created GovernanceControl="+ createdGovernanceControl );
        }
        return createdGovernanceControl;
    }
    /**
     * Update governanceControl
     * @param userId user identity
     * @param governanceControl   governanceControl to update
     * @return GovernanceControl the updated governanceControl entity
     */
    public GovernanceControl updateGovernanceControl(String userId, GovernanceControl governanceControl)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateGovernanceControl";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = GovernanceControlMapper.mapGovernanceControlToOmrsEntityDetail(governanceControl);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            GovernanceControl updatedGovernanceControl =  GovernanceControlMapper.mapOmrsEntityDetailToGovernanceControl(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated GovernanceControl="+ updatedGovernanceControl );
            }
            return updatedGovernanceControl;
        }

    /**
     * Delete an governanceControl identified by its GUID. Delete is a soft delete, this means that the governanceControl has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the governanceControl
     * @return GovernanceControl the deleted GovernanceControl entity
     */

    public GovernanceControl deleteGovernanceControl(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteGovernanceControl";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GovernanceControl type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GovernanceControl");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"GovernanceControl",entityDef.getGUID(),entityGuid);
         GovernanceControl deletedGovernanceControl = GovernanceControlMapper.mapOmrsEntityDetailToGovernanceControl(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedGovernanceControl;

    }
    /**
     * Purge an governanceControl identified by its GUID. Delete is a hard delete, this means that the governanceControl is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the governanceControl
     */
    public void purgeGovernanceControl(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeGovernanceControl";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GovernanceControl type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GovernanceControl");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"GovernanceControl",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an GovernanceControl identified by its GUID. Restore resurrects a soft deleted GovernanceControl. When a GovernanceControl was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the GovernanceControl
     * @return  GovernanceControl the restored GovernanceControl
     */
    public GovernanceControl restoreGovernanceControl(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreGovernanceControl";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        GovernanceControl restoredGovernanceControl =  GovernanceControlMapper.mapOmrsEntityDetailToGovernanceControl(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredGovernanceControl;
    }    

    /**
     * Add classifications to the supplied governanceControl
     * @param userId user identity
     * @param entityGuid the GUID value for governanceControl
     * @param classifications the classifications to apply.
     * @return the governanceControl entity that has been classified
     */
     public GovernanceControl addGovernanceControlClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addGovernanceControlClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         GovernanceControl governanceControlClassificationBeans = GovernanceControlMapper.mapOmrsEntityDetailToGovernanceControl(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified GovernanceControl=" +  governanceControlClassificationBeans);
         }
         return  governanceControlClassificationBeans;
    }

    /**
     * Updates classifications to an existing governanceControl represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the governanceControl
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given governanceControl guid
     */
    public GovernanceControl updateGovernanceControlClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateGovernanceControlClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           GovernanceControl  governanceControlClassificationBeans = GovernanceControlMapper.mapOmrsEntityDetailToGovernanceControl(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  governanceControlClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing governanceControl represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the governanceControl
     * @param name name of the classification
     * @return deleted GovernanceControl  classification
     */
    public GovernanceControl deleteGovernanceControlClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteGovernanceControlClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       GovernanceControl declassifiedGovernanceControl =  GovernanceControlMapper.mapOmrsEntityDetailToGovernanceControl(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedGovernanceControl;
    }

    /**
      * Get the relationships associated with entity governanceControl represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the governanceControl
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getGovernanceControlRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getGovernanceControlRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an topic given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the topics relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return Topic the Topic entity with the requested GUID
     */
    public Topic getTopic(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getTopic";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        Topic gottopic = TopicMapper.mapOmrsEntityDetailToTopic(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gottopic );
        }
        return gottopic;

    }
    /**
     * Create new topic.
     * @param userId user identity
     * @param topic the input entity with values.
     * @return Topic the created entity.
     */

    public Topic createTopic(String userId,Topic topic)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createTopic";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = TopicMapper.mapTopicToOmrsEntityDetail(topic);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        Topic createdTopic =  TopicMapper.mapOmrsEntityDetailToTopic(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created Topic="+ createdTopic );
        }
        return createdTopic;
    }
    /**
     * Update topic
     * @param userId user identity
     * @param topic   topic to update
     * @return Topic the updated topic entity
     */
    public Topic updateTopic(String userId, Topic topic)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateTopic";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = TopicMapper.mapTopicToOmrsEntityDetail(topic);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            Topic updatedTopic =  TopicMapper.mapOmrsEntityDetailToTopic(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated Topic="+ updatedTopic );
            }
            return updatedTopic;
        }

    /**
     * Delete an topic identified by its GUID. Delete is a soft delete, this means that the topic has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the topic
     * @return Topic the deleted Topic entity
     */

    public Topic deleteTopic(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteTopic";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Topic type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Topic");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"Topic",entityDef.getGUID(),entityGuid);
         Topic deletedTopic = TopicMapper.mapOmrsEntityDetailToTopic(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedTopic;

    }
    /**
     * Purge an topic identified by its GUID. Delete is a hard delete, this means that the topic is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the topic
     */
    public void purgeTopic(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeTopic";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Topic type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Topic");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"Topic",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an Topic identified by its GUID. Restore resurrects a soft deleted Topic. When a Topic was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the Topic
     * @return  Topic the restored Topic
     */
    public Topic restoreTopic(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreTopic";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        Topic restoredTopic =  TopicMapper.mapOmrsEntityDetailToTopic(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredTopic;
    }    

    /**
     * Add classifications to the supplied topic
     * @param userId user identity
     * @param entityGuid the GUID value for topic
     * @param classifications the classifications to apply.
     * @return the topic entity that has been classified
     */
     public Topic addTopicClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addTopicClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         Topic topicClassificationBeans = TopicMapper.mapOmrsEntityDetailToTopic(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified Topic=" +  topicClassificationBeans);
         }
         return  topicClassificationBeans;
    }

    /**
     * Updates classifications to an existing topic represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the topic
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given topic guid
     */
    public Topic updateTopicClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateTopicClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           Topic  topicClassificationBeans = TopicMapper.mapOmrsEntityDetailToTopic(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  topicClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing topic represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the topic
     * @param name name of the classification
     * @return deleted Topic  classification
     */
    public Topic deleteTopicClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteTopicClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       Topic declassifiedTopic =  TopicMapper.mapOmrsEntityDetailToTopic(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedTopic;
    }

    /**
      * Get the relationships associated with entity topic represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the topic
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getTopicRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getTopicRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an deployedDatabaseSchema given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the deployedDatabaseSchemas relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return DeployedDatabaseSchema the DeployedDatabaseSchema entity with the requested GUID
     */
    public DeployedDatabaseSchema getDeployedDatabaseSchema(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getDeployedDatabaseSchema";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        DeployedDatabaseSchema gotdeployedDatabaseSchema = DeployedDatabaseSchemaMapper.mapOmrsEntityDetailToDeployedDatabaseSchema(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotdeployedDatabaseSchema );
        }
        return gotdeployedDatabaseSchema;

    }
    /**
     * Create new deployedDatabaseSchema.
     * @param userId user identity
     * @param deployedDatabaseSchema the input entity with values.
     * @return DeployedDatabaseSchema the created entity.
     */

    public DeployedDatabaseSchema createDeployedDatabaseSchema(String userId,DeployedDatabaseSchema deployedDatabaseSchema)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createDeployedDatabaseSchema";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = DeployedDatabaseSchemaMapper.mapDeployedDatabaseSchemaToOmrsEntityDetail(deployedDatabaseSchema);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        DeployedDatabaseSchema createdDeployedDatabaseSchema =  DeployedDatabaseSchemaMapper.mapOmrsEntityDetailToDeployedDatabaseSchema(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created DeployedDatabaseSchema="+ createdDeployedDatabaseSchema );
        }
        return createdDeployedDatabaseSchema;
    }
    /**
     * Update deployedDatabaseSchema
     * @param userId user identity
     * @param deployedDatabaseSchema   deployedDatabaseSchema to update
     * @return DeployedDatabaseSchema the updated deployedDatabaseSchema entity
     */
    public DeployedDatabaseSchema updateDeployedDatabaseSchema(String userId, DeployedDatabaseSchema deployedDatabaseSchema)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateDeployedDatabaseSchema";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = DeployedDatabaseSchemaMapper.mapDeployedDatabaseSchemaToOmrsEntityDetail(deployedDatabaseSchema);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            DeployedDatabaseSchema updatedDeployedDatabaseSchema =  DeployedDatabaseSchemaMapper.mapOmrsEntityDetailToDeployedDatabaseSchema(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated DeployedDatabaseSchema="+ updatedDeployedDatabaseSchema );
            }
            return updatedDeployedDatabaseSchema;
        }

    /**
     * Delete an deployedDatabaseSchema identified by its GUID. Delete is a soft delete, this means that the deployedDatabaseSchema has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the deployedDatabaseSchema
     * @return DeployedDatabaseSchema the deleted DeployedDatabaseSchema entity
     */

    public DeployedDatabaseSchema deleteDeployedDatabaseSchema(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteDeployedDatabaseSchema";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DeployedDatabaseSchema type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DeployedDatabaseSchema");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"DeployedDatabaseSchema",entityDef.getGUID(),entityGuid);
         DeployedDatabaseSchema deletedDeployedDatabaseSchema = DeployedDatabaseSchemaMapper.mapOmrsEntityDetailToDeployedDatabaseSchema(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedDeployedDatabaseSchema;

    }
    /**
     * Purge an deployedDatabaseSchema identified by its GUID. Delete is a hard delete, this means that the deployedDatabaseSchema is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the deployedDatabaseSchema
     */
    public void purgeDeployedDatabaseSchema(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeDeployedDatabaseSchema";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DeployedDatabaseSchema type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DeployedDatabaseSchema");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"DeployedDatabaseSchema",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an DeployedDatabaseSchema identified by its GUID. Restore resurrects a soft deleted DeployedDatabaseSchema. When a DeployedDatabaseSchema was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the DeployedDatabaseSchema
     * @return  DeployedDatabaseSchema the restored DeployedDatabaseSchema
     */
    public DeployedDatabaseSchema restoreDeployedDatabaseSchema(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreDeployedDatabaseSchema";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        DeployedDatabaseSchema restoredDeployedDatabaseSchema =  DeployedDatabaseSchemaMapper.mapOmrsEntityDetailToDeployedDatabaseSchema(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredDeployedDatabaseSchema;
    }    

    /**
     * Add classifications to the supplied deployedDatabaseSchema
     * @param userId user identity
     * @param entityGuid the GUID value for deployedDatabaseSchema
     * @param classifications the classifications to apply.
     * @return the deployedDatabaseSchema entity that has been classified
     */
     public DeployedDatabaseSchema addDeployedDatabaseSchemaClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addDeployedDatabaseSchemaClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         DeployedDatabaseSchema deployedDatabaseSchemaClassificationBeans = DeployedDatabaseSchemaMapper.mapOmrsEntityDetailToDeployedDatabaseSchema(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified DeployedDatabaseSchema=" +  deployedDatabaseSchemaClassificationBeans);
         }
         return  deployedDatabaseSchemaClassificationBeans;
    }

    /**
     * Updates classifications to an existing deployedDatabaseSchema represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the deployedDatabaseSchema
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given deployedDatabaseSchema guid
     */
    public DeployedDatabaseSchema updateDeployedDatabaseSchemaClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateDeployedDatabaseSchemaClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           DeployedDatabaseSchema  deployedDatabaseSchemaClassificationBeans = DeployedDatabaseSchemaMapper.mapOmrsEntityDetailToDeployedDatabaseSchema(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  deployedDatabaseSchemaClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing deployedDatabaseSchema represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the deployedDatabaseSchema
     * @param name name of the classification
     * @return deleted DeployedDatabaseSchema  classification
     */
    public DeployedDatabaseSchema deleteDeployedDatabaseSchemaClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteDeployedDatabaseSchemaClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       DeployedDatabaseSchema declassifiedDeployedDatabaseSchema =  DeployedDatabaseSchemaMapper.mapOmrsEntityDetailToDeployedDatabaseSchema(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedDeployedDatabaseSchema;
    }

    /**
      * Get the relationships associated with entity deployedDatabaseSchema represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the deployedDatabaseSchema
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getDeployedDatabaseSchemaRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getDeployedDatabaseSchemaRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an deployedAPI given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the deployedAPIs relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return DeployedAPI the DeployedAPI entity with the requested GUID
     */
    public DeployedAPI getDeployedAPI(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getDeployedAPI";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        DeployedAPI gotdeployedAPI = DeployedAPIMapper.mapOmrsEntityDetailToDeployedAPI(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotdeployedAPI );
        }
        return gotdeployedAPI;

    }
    /**
     * Create new deployedAPI.
     * @param userId user identity
     * @param deployedAPI the input entity with values.
     * @return DeployedAPI the created entity.
     */

    public DeployedAPI createDeployedAPI(String userId,DeployedAPI deployedAPI)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createDeployedAPI";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = DeployedAPIMapper.mapDeployedAPIToOmrsEntityDetail(deployedAPI);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        DeployedAPI createdDeployedAPI =  DeployedAPIMapper.mapOmrsEntityDetailToDeployedAPI(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created DeployedAPI="+ createdDeployedAPI );
        }
        return createdDeployedAPI;
    }
    /**
     * Update deployedAPI
     * @param userId user identity
     * @param deployedAPI   deployedAPI to update
     * @return DeployedAPI the updated deployedAPI entity
     */
    public DeployedAPI updateDeployedAPI(String userId, DeployedAPI deployedAPI)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateDeployedAPI";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = DeployedAPIMapper.mapDeployedAPIToOmrsEntityDetail(deployedAPI);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            DeployedAPI updatedDeployedAPI =  DeployedAPIMapper.mapOmrsEntityDetailToDeployedAPI(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated DeployedAPI="+ updatedDeployedAPI );
            }
            return updatedDeployedAPI;
        }

    /**
     * Delete an deployedAPI identified by its GUID. Delete is a soft delete, this means that the deployedAPI has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the deployedAPI
     * @return DeployedAPI the deleted DeployedAPI entity
     */

    public DeployedAPI deleteDeployedAPI(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteDeployedAPI";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DeployedAPI type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DeployedAPI");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"DeployedAPI",entityDef.getGUID(),entityGuid);
         DeployedAPI deletedDeployedAPI = DeployedAPIMapper.mapOmrsEntityDetailToDeployedAPI(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedDeployedAPI;

    }
    /**
     * Purge an deployedAPI identified by its GUID. Delete is a hard delete, this means that the deployedAPI is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the deployedAPI
     */
    public void purgeDeployedAPI(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeDeployedAPI";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DeployedAPI type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DeployedAPI");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"DeployedAPI",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an DeployedAPI identified by its GUID. Restore resurrects a soft deleted DeployedAPI. When a DeployedAPI was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the DeployedAPI
     * @return  DeployedAPI the restored DeployedAPI
     */
    public DeployedAPI restoreDeployedAPI(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreDeployedAPI";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        DeployedAPI restoredDeployedAPI =  DeployedAPIMapper.mapOmrsEntityDetailToDeployedAPI(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredDeployedAPI;
    }    

    /**
     * Add classifications to the supplied deployedAPI
     * @param userId user identity
     * @param entityGuid the GUID value for deployedAPI
     * @param classifications the classifications to apply.
     * @return the deployedAPI entity that has been classified
     */
     public DeployedAPI addDeployedAPIClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addDeployedAPIClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         DeployedAPI deployedAPIClassificationBeans = DeployedAPIMapper.mapOmrsEntityDetailToDeployedAPI(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified DeployedAPI=" +  deployedAPIClassificationBeans);
         }
         return  deployedAPIClassificationBeans;
    }

    /**
     * Updates classifications to an existing deployedAPI represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the deployedAPI
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given deployedAPI guid
     */
    public DeployedAPI updateDeployedAPIClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateDeployedAPIClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           DeployedAPI  deployedAPIClassificationBeans = DeployedAPIMapper.mapOmrsEntityDetailToDeployedAPI(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  deployedAPIClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing deployedAPI represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the deployedAPI
     * @param name name of the classification
     * @return deleted DeployedAPI  classification
     */
    public DeployedAPI deleteDeployedAPIClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteDeployedAPIClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       DeployedAPI declassifiedDeployedAPI =  DeployedAPIMapper.mapOmrsEntityDetailToDeployedAPI(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedDeployedAPI;
    }

    /**
      * Get the relationships associated with entity deployedAPI represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the deployedAPI
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getDeployedAPIRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getDeployedAPIRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an comment given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the comments relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return Comment the Comment entity with the requested GUID
     */
    public Comment getComment(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getComment";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        Comment gotcomment = CommentMapper.mapOmrsEntityDetailToComment(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotcomment );
        }
        return gotcomment;

    }
    /**
     * Create new comment.
     * @param userId user identity
     * @param comment the input entity with values.
     * @return Comment the created entity.
     */

    public Comment createComment(String userId,Comment comment)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createComment";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = CommentMapper.mapCommentToOmrsEntityDetail(comment);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        Comment createdComment =  CommentMapper.mapOmrsEntityDetailToComment(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created Comment="+ createdComment );
        }
        return createdComment;
    }
    /**
     * Update comment
     * @param userId user identity
     * @param comment   comment to update
     * @return Comment the updated comment entity
     */
    public Comment updateComment(String userId, Comment comment)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateComment";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = CommentMapper.mapCommentToOmrsEntityDetail(comment);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            Comment updatedComment =  CommentMapper.mapOmrsEntityDetailToComment(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated Comment="+ updatedComment );
            }
            return updatedComment;
        }

    /**
     * Delete an comment identified by its GUID. Delete is a soft delete, this means that the comment has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the comment
     * @return Comment the deleted Comment entity
     */

    public Comment deleteComment(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteComment";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Comment type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Comment");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"Comment",entityDef.getGUID(),entityGuid);
         Comment deletedComment = CommentMapper.mapOmrsEntityDetailToComment(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedComment;

    }
    /**
     * Purge an comment identified by its GUID. Delete is a hard delete, this means that the comment is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the comment
     */
    public void purgeComment(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeComment";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Comment type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Comment");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"Comment",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an Comment identified by its GUID. Restore resurrects a soft deleted Comment. When a Comment was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the Comment
     * @return  Comment the restored Comment
     */
    public Comment restoreComment(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreComment";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        Comment restoredComment =  CommentMapper.mapOmrsEntityDetailToComment(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredComment;
    }    

    /**
     * Add classifications to the supplied comment
     * @param userId user identity
     * @param entityGuid the GUID value for comment
     * @param classifications the classifications to apply.
     * @return the comment entity that has been classified
     */
     public Comment addCommentClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addCommentClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         Comment commentClassificationBeans = CommentMapper.mapOmrsEntityDetailToComment(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified Comment=" +  commentClassificationBeans);
         }
         return  commentClassificationBeans;
    }

    /**
     * Updates classifications to an existing comment represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the comment
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given comment guid
     */
    public Comment updateCommentClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateCommentClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           Comment  commentClassificationBeans = CommentMapper.mapOmrsEntityDetailToComment(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  commentClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing comment represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the comment
     * @param name name of the classification
     * @return deleted Comment  classification
     */
    public Comment deleteCommentClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteCommentClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       Comment declassifiedComment =  CommentMapper.mapOmrsEntityDetailToComment(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedComment;
    }

    /**
      * Get the relationships associated with entity comment represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the comment
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getCommentRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getCommentRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an cohortMember given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the cohortMembers relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return CohortMember the CohortMember entity with the requested GUID
     */
    public CohortMember getCohortMember(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getCohortMember";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        CohortMember gotcohortMember = CohortMemberMapper.mapOmrsEntityDetailToCohortMember(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotcohortMember );
        }
        return gotcohortMember;

    }
    /**
     * Create new cohortMember.
     * @param userId user identity
     * @param cohortMember the input entity with values.
     * @return CohortMember the created entity.
     */

    public CohortMember createCohortMember(String userId,CohortMember cohortMember)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createCohortMember";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = CohortMemberMapper.mapCohortMemberToOmrsEntityDetail(cohortMember);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        CohortMember createdCohortMember =  CohortMemberMapper.mapOmrsEntityDetailToCohortMember(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created CohortMember="+ createdCohortMember );
        }
        return createdCohortMember;
    }
    /**
     * Update cohortMember
     * @param userId user identity
     * @param cohortMember   cohortMember to update
     * @return CohortMember the updated cohortMember entity
     */
    public CohortMember updateCohortMember(String userId, CohortMember cohortMember)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateCohortMember";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = CohortMemberMapper.mapCohortMemberToOmrsEntityDetail(cohortMember);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            CohortMember updatedCohortMember =  CohortMemberMapper.mapOmrsEntityDetailToCohortMember(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated CohortMember="+ updatedCohortMember );
            }
            return updatedCohortMember;
        }

    /**
     * Delete an cohortMember identified by its GUID. Delete is a soft delete, this means that the cohortMember has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the cohortMember
     * @return CohortMember the deleted CohortMember entity
     */

    public CohortMember deleteCohortMember(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteCohortMember";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the CohortMember type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("CohortMember");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"CohortMember",entityDef.getGUID(),entityGuid);
         CohortMember deletedCohortMember = CohortMemberMapper.mapOmrsEntityDetailToCohortMember(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedCohortMember;

    }
    /**
     * Purge an cohortMember identified by its GUID. Delete is a hard delete, this means that the cohortMember is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the cohortMember
     */
    public void purgeCohortMember(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeCohortMember";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the CohortMember type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("CohortMember");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"CohortMember",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an CohortMember identified by its GUID. Restore resurrects a soft deleted CohortMember. When a CohortMember was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the CohortMember
     * @return  CohortMember the restored CohortMember
     */
    public CohortMember restoreCohortMember(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreCohortMember";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        CohortMember restoredCohortMember =  CohortMemberMapper.mapOmrsEntityDetailToCohortMember(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredCohortMember;
    }    

    /**
     * Add classifications to the supplied cohortMember
     * @param userId user identity
     * @param entityGuid the GUID value for cohortMember
     * @param classifications the classifications to apply.
     * @return the cohortMember entity that has been classified
     */
     public CohortMember addCohortMemberClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addCohortMemberClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         CohortMember cohortMemberClassificationBeans = CohortMemberMapper.mapOmrsEntityDetailToCohortMember(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified CohortMember=" +  cohortMemberClassificationBeans);
         }
         return  cohortMemberClassificationBeans;
    }

    /**
     * Updates classifications to an existing cohortMember represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the cohortMember
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given cohortMember guid
     */
    public CohortMember updateCohortMemberClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateCohortMemberClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           CohortMember  cohortMemberClassificationBeans = CohortMemberMapper.mapOmrsEntityDetailToCohortMember(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  cohortMemberClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing cohortMember represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the cohortMember
     * @param name name of the classification
     * @return deleted CohortMember  classification
     */
    public CohortMember deleteCohortMemberClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteCohortMemberClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       CohortMember declassifiedCohortMember =  CohortMemberMapper.mapOmrsEntityDetailToCohortMember(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedCohortMember;
    }

    /**
      * Get the relationships associated with entity cohortMember represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the cohortMember
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getCohortMemberRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getCohortMemberRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an complexSchemaType given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the complexSchemaTypes relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return ComplexSchemaType the ComplexSchemaType entity with the requested GUID
     */
    public ComplexSchemaType getComplexSchemaType(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getComplexSchemaType";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        ComplexSchemaType gotcomplexSchemaType = ComplexSchemaTypeMapper.mapOmrsEntityDetailToComplexSchemaType(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotcomplexSchemaType );
        }
        return gotcomplexSchemaType;

    }
    /**
     * Create new complexSchemaType.
     * @param userId user identity
     * @param complexSchemaType the input entity with values.
     * @return ComplexSchemaType the created entity.
     */

    public ComplexSchemaType createComplexSchemaType(String userId,ComplexSchemaType complexSchemaType)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createComplexSchemaType";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = ComplexSchemaTypeMapper.mapComplexSchemaTypeToOmrsEntityDetail(complexSchemaType);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        ComplexSchemaType createdComplexSchemaType =  ComplexSchemaTypeMapper.mapOmrsEntityDetailToComplexSchemaType(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created ComplexSchemaType="+ createdComplexSchemaType );
        }
        return createdComplexSchemaType;
    }
    /**
     * Update complexSchemaType
     * @param userId user identity
     * @param complexSchemaType   complexSchemaType to update
     * @return ComplexSchemaType the updated complexSchemaType entity
     */
    public ComplexSchemaType updateComplexSchemaType(String userId, ComplexSchemaType complexSchemaType)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateComplexSchemaType";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = ComplexSchemaTypeMapper.mapComplexSchemaTypeToOmrsEntityDetail(complexSchemaType);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            ComplexSchemaType updatedComplexSchemaType =  ComplexSchemaTypeMapper.mapOmrsEntityDetailToComplexSchemaType(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated ComplexSchemaType="+ updatedComplexSchemaType );
            }
            return updatedComplexSchemaType;
        }

    /**
     * Delete an complexSchemaType identified by its GUID. Delete is a soft delete, this means that the complexSchemaType has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the complexSchemaType
     * @return ComplexSchemaType the deleted ComplexSchemaType entity
     */

    public ComplexSchemaType deleteComplexSchemaType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteComplexSchemaType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ComplexSchemaType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ComplexSchemaType");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"ComplexSchemaType",entityDef.getGUID(),entityGuid);
         ComplexSchemaType deletedComplexSchemaType = ComplexSchemaTypeMapper.mapOmrsEntityDetailToComplexSchemaType(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedComplexSchemaType;

    }
    /**
     * Purge an complexSchemaType identified by its GUID. Delete is a hard delete, this means that the complexSchemaType is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the complexSchemaType
     */
    public void purgeComplexSchemaType(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeComplexSchemaType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ComplexSchemaType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ComplexSchemaType");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"ComplexSchemaType",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an ComplexSchemaType identified by its GUID. Restore resurrects a soft deleted ComplexSchemaType. When a ComplexSchemaType was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the ComplexSchemaType
     * @return  ComplexSchemaType the restored ComplexSchemaType
     */
    public ComplexSchemaType restoreComplexSchemaType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreComplexSchemaType";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        ComplexSchemaType restoredComplexSchemaType =  ComplexSchemaTypeMapper.mapOmrsEntityDetailToComplexSchemaType(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredComplexSchemaType;
    }    

    /**
     * Add classifications to the supplied complexSchemaType
     * @param userId user identity
     * @param entityGuid the GUID value for complexSchemaType
     * @param classifications the classifications to apply.
     * @return the complexSchemaType entity that has been classified
     */
     public ComplexSchemaType addComplexSchemaTypeClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addComplexSchemaTypeClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         ComplexSchemaType complexSchemaTypeClassificationBeans = ComplexSchemaTypeMapper.mapOmrsEntityDetailToComplexSchemaType(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified ComplexSchemaType=" +  complexSchemaTypeClassificationBeans);
         }
         return  complexSchemaTypeClassificationBeans;
    }

    /**
     * Updates classifications to an existing complexSchemaType represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the complexSchemaType
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given complexSchemaType guid
     */
    public ComplexSchemaType updateComplexSchemaTypeClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateComplexSchemaTypeClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           ComplexSchemaType  complexSchemaTypeClassificationBeans = ComplexSchemaTypeMapper.mapOmrsEntityDetailToComplexSchemaType(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  complexSchemaTypeClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing complexSchemaType represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the complexSchemaType
     * @param name name of the classification
     * @return deleted ComplexSchemaType  classification
     */
    public ComplexSchemaType deleteComplexSchemaTypeClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteComplexSchemaTypeClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       ComplexSchemaType declassifiedComplexSchemaType =  ComplexSchemaTypeMapper.mapOmrsEntityDetailToComplexSchemaType(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedComplexSchemaType;
    }

    /**
      * Get the relationships associated with entity complexSchemaType represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the complexSchemaType
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getComplexSchemaTypeRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getComplexSchemaTypeRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an eventSet given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the eventSets relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return EventSet the EventSet entity with the requested GUID
     */
    public EventSet getEventSet(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getEventSet";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        EventSet goteventSet = EventSetMapper.mapOmrsEntityDetailToEventSet(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ goteventSet );
        }
        return goteventSet;

    }
    /**
     * Create new eventSet.
     * @param userId user identity
     * @param eventSet the input entity with values.
     * @return EventSet the created entity.
     */

    public EventSet createEventSet(String userId,EventSet eventSet)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createEventSet";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = EventSetMapper.mapEventSetToOmrsEntityDetail(eventSet);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        EventSet createdEventSet =  EventSetMapper.mapOmrsEntityDetailToEventSet(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created EventSet="+ createdEventSet );
        }
        return createdEventSet;
    }
    /**
     * Update eventSet
     * @param userId user identity
     * @param eventSet   eventSet to update
     * @return EventSet the updated eventSet entity
     */
    public EventSet updateEventSet(String userId, EventSet eventSet)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateEventSet";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = EventSetMapper.mapEventSetToOmrsEntityDetail(eventSet);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            EventSet updatedEventSet =  EventSetMapper.mapOmrsEntityDetailToEventSet(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated EventSet="+ updatedEventSet );
            }
            return updatedEventSet;
        }

    /**
     * Delete an eventSet identified by its GUID. Delete is a soft delete, this means that the eventSet has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the eventSet
     * @return EventSet the deleted EventSet entity
     */

    public EventSet deleteEventSet(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteEventSet";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the EventSet type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("EventSet");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"EventSet",entityDef.getGUID(),entityGuid);
         EventSet deletedEventSet = EventSetMapper.mapOmrsEntityDetailToEventSet(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedEventSet;

    }
    /**
     * Purge an eventSet identified by its GUID. Delete is a hard delete, this means that the eventSet is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the eventSet
     */
    public void purgeEventSet(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeEventSet";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the EventSet type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("EventSet");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"EventSet",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an EventSet identified by its GUID. Restore resurrects a soft deleted EventSet. When a EventSet was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the EventSet
     * @return  EventSet the restored EventSet
     */
    public EventSet restoreEventSet(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreEventSet";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        EventSet restoredEventSet =  EventSetMapper.mapOmrsEntityDetailToEventSet(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredEventSet;
    }    

    /**
     * Add classifications to the supplied eventSet
     * @param userId user identity
     * @param entityGuid the GUID value for eventSet
     * @param classifications the classifications to apply.
     * @return the eventSet entity that has been classified
     */
     public EventSet addEventSetClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addEventSetClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         EventSet eventSetClassificationBeans = EventSetMapper.mapOmrsEntityDetailToEventSet(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified EventSet=" +  eventSetClassificationBeans);
         }
         return  eventSetClassificationBeans;
    }

    /**
     * Updates classifications to an existing eventSet represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the eventSet
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given eventSet guid
     */
    public EventSet updateEventSetClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateEventSetClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           EventSet  eventSetClassificationBeans = EventSetMapper.mapOmrsEntityDetailToEventSet(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  eventSetClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing eventSet represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the eventSet
     * @param name name of the classification
     * @return deleted EventSet  classification
     */
    public EventSet deleteEventSetClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteEventSetClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       EventSet declassifiedEventSet =  EventSetMapper.mapOmrsEntityDetailToEventSet(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedEventSet;
    }

    /**
      * Get the relationships associated with entity eventSet represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the eventSet
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getEventSetRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getEventSetRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an externalId given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the externalIds relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return ExternalId the ExternalId entity with the requested GUID
     */
    public ExternalId getExternalId(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getExternalId";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        ExternalId gotexternalId = ExternalIdMapper.mapOmrsEntityDetailToExternalId(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotexternalId );
        }
        return gotexternalId;

    }
    /**
     * Create new externalId.
     * @param userId user identity
     * @param externalId the input entity with values.
     * @return ExternalId the created entity.
     */

    public ExternalId createExternalId(String userId,ExternalId externalId)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createExternalId";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = ExternalIdMapper.mapExternalIdToOmrsEntityDetail(externalId);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        ExternalId createdExternalId =  ExternalIdMapper.mapOmrsEntityDetailToExternalId(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created ExternalId="+ createdExternalId );
        }
        return createdExternalId;
    }
    /**
     * Update externalId
     * @param userId user identity
     * @param externalId   externalId to update
     * @return ExternalId the updated externalId entity
     */
    public ExternalId updateExternalId(String userId, ExternalId externalId)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateExternalId";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = ExternalIdMapper.mapExternalIdToOmrsEntityDetail(externalId);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            ExternalId updatedExternalId =  ExternalIdMapper.mapOmrsEntityDetailToExternalId(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated ExternalId="+ updatedExternalId );
            }
            return updatedExternalId;
        }

    /**
     * Delete an externalId identified by its GUID. Delete is a soft delete, this means that the externalId has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the externalId
     * @return ExternalId the deleted ExternalId entity
     */

    public ExternalId deleteExternalId(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteExternalId";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ExternalId type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ExternalId");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"ExternalId",entityDef.getGUID(),entityGuid);
         ExternalId deletedExternalId = ExternalIdMapper.mapOmrsEntityDetailToExternalId(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedExternalId;

    }
    /**
     * Purge an externalId identified by its GUID. Delete is a hard delete, this means that the externalId is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the externalId
     */
    public void purgeExternalId(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeExternalId";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ExternalId type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ExternalId");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"ExternalId",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an ExternalId identified by its GUID. Restore resurrects a soft deleted ExternalId. When a ExternalId was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the ExternalId
     * @return  ExternalId the restored ExternalId
     */
    public ExternalId restoreExternalId(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreExternalId";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        ExternalId restoredExternalId =  ExternalIdMapper.mapOmrsEntityDetailToExternalId(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredExternalId;
    }    

    /**
     * Add classifications to the supplied externalId
     * @param userId user identity
     * @param entityGuid the GUID value for externalId
     * @param classifications the classifications to apply.
     * @return the externalId entity that has been classified
     */
     public ExternalId addExternalIdClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addExternalIdClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         ExternalId externalIdClassificationBeans = ExternalIdMapper.mapOmrsEntityDetailToExternalId(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified ExternalId=" +  externalIdClassificationBeans);
         }
         return  externalIdClassificationBeans;
    }

    /**
     * Updates classifications to an existing externalId represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the externalId
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given externalId guid
     */
    public ExternalId updateExternalIdClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateExternalIdClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           ExternalId  externalIdClassificationBeans = ExternalIdMapper.mapOmrsEntityDetailToExternalId(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  externalIdClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing externalId represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the externalId
     * @param name name of the classification
     * @return deleted ExternalId  classification
     */
    public ExternalId deleteExternalIdClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteExternalIdClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       ExternalId declassifiedExternalId =  ExternalIdMapper.mapOmrsEntityDetailToExternalId(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedExternalId;
    }

    /**
      * Get the relationships associated with entity externalId represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the externalId
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getExternalIdRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getExternalIdRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an namingStandardRule given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the namingStandardRules relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return NamingStandardRule the NamingStandardRule entity with the requested GUID
     */
    public NamingStandardRule getNamingStandardRule(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getNamingStandardRule";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        NamingStandardRule gotnamingStandardRule = NamingStandardRuleMapper.mapOmrsEntityDetailToNamingStandardRule(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotnamingStandardRule );
        }
        return gotnamingStandardRule;

    }
    /**
     * Create new namingStandardRule.
     * @param userId user identity
     * @param namingStandardRule the input entity with values.
     * @return NamingStandardRule the created entity.
     */

    public NamingStandardRule createNamingStandardRule(String userId,NamingStandardRule namingStandardRule)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createNamingStandardRule";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = NamingStandardRuleMapper.mapNamingStandardRuleToOmrsEntityDetail(namingStandardRule);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        NamingStandardRule createdNamingStandardRule =  NamingStandardRuleMapper.mapOmrsEntityDetailToNamingStandardRule(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created NamingStandardRule="+ createdNamingStandardRule );
        }
        return createdNamingStandardRule;
    }
    /**
     * Update namingStandardRule
     * @param userId user identity
     * @param namingStandardRule   namingStandardRule to update
     * @return NamingStandardRule the updated namingStandardRule entity
     */
    public NamingStandardRule updateNamingStandardRule(String userId, NamingStandardRule namingStandardRule)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateNamingStandardRule";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = NamingStandardRuleMapper.mapNamingStandardRuleToOmrsEntityDetail(namingStandardRule);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            NamingStandardRule updatedNamingStandardRule =  NamingStandardRuleMapper.mapOmrsEntityDetailToNamingStandardRule(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated NamingStandardRule="+ updatedNamingStandardRule );
            }
            return updatedNamingStandardRule;
        }

    /**
     * Delete an namingStandardRule identified by its GUID. Delete is a soft delete, this means that the namingStandardRule has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the namingStandardRule
     * @return NamingStandardRule the deleted NamingStandardRule entity
     */

    public NamingStandardRule deleteNamingStandardRule(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteNamingStandardRule";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the NamingStandardRule type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("NamingStandardRule");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"NamingStandardRule",entityDef.getGUID(),entityGuid);
         NamingStandardRule deletedNamingStandardRule = NamingStandardRuleMapper.mapOmrsEntityDetailToNamingStandardRule(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedNamingStandardRule;

    }
    /**
     * Purge an namingStandardRule identified by its GUID. Delete is a hard delete, this means that the namingStandardRule is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the namingStandardRule
     */
    public void purgeNamingStandardRule(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeNamingStandardRule";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the NamingStandardRule type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("NamingStandardRule");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"NamingStandardRule",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an NamingStandardRule identified by its GUID. Restore resurrects a soft deleted NamingStandardRule. When a NamingStandardRule was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the NamingStandardRule
     * @return  NamingStandardRule the restored NamingStandardRule
     */
    public NamingStandardRule restoreNamingStandardRule(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreNamingStandardRule";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        NamingStandardRule restoredNamingStandardRule =  NamingStandardRuleMapper.mapOmrsEntityDetailToNamingStandardRule(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredNamingStandardRule;
    }    

    /**
     * Add classifications to the supplied namingStandardRule
     * @param userId user identity
     * @param entityGuid the GUID value for namingStandardRule
     * @param classifications the classifications to apply.
     * @return the namingStandardRule entity that has been classified
     */
     public NamingStandardRule addNamingStandardRuleClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addNamingStandardRuleClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         NamingStandardRule namingStandardRuleClassificationBeans = NamingStandardRuleMapper.mapOmrsEntityDetailToNamingStandardRule(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified NamingStandardRule=" +  namingStandardRuleClassificationBeans);
         }
         return  namingStandardRuleClassificationBeans;
    }

    /**
     * Updates classifications to an existing namingStandardRule represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the namingStandardRule
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given namingStandardRule guid
     */
    public NamingStandardRule updateNamingStandardRuleClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateNamingStandardRuleClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           NamingStandardRule  namingStandardRuleClassificationBeans = NamingStandardRuleMapper.mapOmrsEntityDetailToNamingStandardRule(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  namingStandardRuleClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing namingStandardRule represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the namingStandardRule
     * @param name name of the classification
     * @return deleted NamingStandardRule  classification
     */
    public NamingStandardRule deleteNamingStandardRuleClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteNamingStandardRuleClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       NamingStandardRule declassifiedNamingStandardRule =  NamingStandardRuleMapper.mapOmrsEntityDetailToNamingStandardRule(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedNamingStandardRule;
    }

    /**
      * Get the relationships associated with entity namingStandardRule represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the namingStandardRule
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getNamingStandardRuleRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getNamingStandardRuleRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an governanceRole given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the governanceRoles relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return GovernanceRole the GovernanceRole entity with the requested GUID
     */
    public GovernanceRole getGovernanceRole(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getGovernanceRole";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        GovernanceRole gotgovernanceRole = GovernanceRoleMapper.mapOmrsEntityDetailToGovernanceRole(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotgovernanceRole );
        }
        return gotgovernanceRole;

    }
    /**
     * Create new governanceRole.
     * @param userId user identity
     * @param governanceRole the input entity with values.
     * @return GovernanceRole the created entity.
     */

    public GovernanceRole createGovernanceRole(String userId,GovernanceRole governanceRole)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createGovernanceRole";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = GovernanceRoleMapper.mapGovernanceRoleToOmrsEntityDetail(governanceRole);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        GovernanceRole createdGovernanceRole =  GovernanceRoleMapper.mapOmrsEntityDetailToGovernanceRole(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created GovernanceRole="+ createdGovernanceRole );
        }
        return createdGovernanceRole;
    }
    /**
     * Update governanceRole
     * @param userId user identity
     * @param governanceRole   governanceRole to update
     * @return GovernanceRole the updated governanceRole entity
     */
    public GovernanceRole updateGovernanceRole(String userId, GovernanceRole governanceRole)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateGovernanceRole";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = GovernanceRoleMapper.mapGovernanceRoleToOmrsEntityDetail(governanceRole);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            GovernanceRole updatedGovernanceRole =  GovernanceRoleMapper.mapOmrsEntityDetailToGovernanceRole(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated GovernanceRole="+ updatedGovernanceRole );
            }
            return updatedGovernanceRole;
        }

    /**
     * Delete an governanceRole identified by its GUID. Delete is a soft delete, this means that the governanceRole has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the governanceRole
     * @return GovernanceRole the deleted GovernanceRole entity
     */

    public GovernanceRole deleteGovernanceRole(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteGovernanceRole";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GovernanceRole type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GovernanceRole");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"GovernanceRole",entityDef.getGUID(),entityGuid);
         GovernanceRole deletedGovernanceRole = GovernanceRoleMapper.mapOmrsEntityDetailToGovernanceRole(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedGovernanceRole;

    }
    /**
     * Purge an governanceRole identified by its GUID. Delete is a hard delete, this means that the governanceRole is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the governanceRole
     */
    public void purgeGovernanceRole(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeGovernanceRole";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GovernanceRole type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GovernanceRole");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"GovernanceRole",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an GovernanceRole identified by its GUID. Restore resurrects a soft deleted GovernanceRole. When a GovernanceRole was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the GovernanceRole
     * @return  GovernanceRole the restored GovernanceRole
     */
    public GovernanceRole restoreGovernanceRole(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreGovernanceRole";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        GovernanceRole restoredGovernanceRole =  GovernanceRoleMapper.mapOmrsEntityDetailToGovernanceRole(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredGovernanceRole;
    }    

    /**
     * Add classifications to the supplied governanceRole
     * @param userId user identity
     * @param entityGuid the GUID value for governanceRole
     * @param classifications the classifications to apply.
     * @return the governanceRole entity that has been classified
     */
     public GovernanceRole addGovernanceRoleClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addGovernanceRoleClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         GovernanceRole governanceRoleClassificationBeans = GovernanceRoleMapper.mapOmrsEntityDetailToGovernanceRole(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified GovernanceRole=" +  governanceRoleClassificationBeans);
         }
         return  governanceRoleClassificationBeans;
    }

    /**
     * Updates classifications to an existing governanceRole represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the governanceRole
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given governanceRole guid
     */
    public GovernanceRole updateGovernanceRoleClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateGovernanceRoleClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           GovernanceRole  governanceRoleClassificationBeans = GovernanceRoleMapper.mapOmrsEntityDetailToGovernanceRole(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  governanceRoleClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing governanceRole represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the governanceRole
     * @param name name of the classification
     * @return deleted GovernanceRole  classification
     */
    public GovernanceRole deleteGovernanceRoleClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteGovernanceRoleClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       GovernanceRole declassifiedGovernanceRole =  GovernanceRoleMapper.mapOmrsEntityDetailToGovernanceRole(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedGovernanceRole;
    }

    /**
      * Get the relationships associated with entity governanceRole represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the governanceRole
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getGovernanceRoleRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getGovernanceRoleRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an host given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the hosts relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return Host the Host entity with the requested GUID
     */
    public Host getHost(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getHost";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        Host gothost = HostMapper.mapOmrsEntityDetailToHost(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gothost );
        }
        return gothost;

    }
    /**
     * Create new host.
     * @param userId user identity
     * @param host the input entity with values.
     * @return Host the created entity.
     */

    public Host createHost(String userId,Host host)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createHost";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = HostMapper.mapHostToOmrsEntityDetail(host);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        Host createdHost =  HostMapper.mapOmrsEntityDetailToHost(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created Host="+ createdHost );
        }
        return createdHost;
    }
    /**
     * Update host
     * @param userId user identity
     * @param host   host to update
     * @return Host the updated host entity
     */
    public Host updateHost(String userId, Host host)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateHost";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = HostMapper.mapHostToOmrsEntityDetail(host);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            Host updatedHost =  HostMapper.mapOmrsEntityDetailToHost(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated Host="+ updatedHost );
            }
            return updatedHost;
        }

    /**
     * Delete an host identified by its GUID. Delete is a soft delete, this means that the host has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the host
     * @return Host the deleted Host entity
     */

    public Host deleteHost(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteHost";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Host type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Host");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"Host",entityDef.getGUID(),entityGuid);
         Host deletedHost = HostMapper.mapOmrsEntityDetailToHost(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedHost;

    }
    /**
     * Purge an host identified by its GUID. Delete is a hard delete, this means that the host is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the host
     */
    public void purgeHost(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeHost";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Host type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Host");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"Host",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an Host identified by its GUID. Restore resurrects a soft deleted Host. When a Host was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the Host
     * @return  Host the restored Host
     */
    public Host restoreHost(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreHost";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        Host restoredHost =  HostMapper.mapOmrsEntityDetailToHost(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredHost;
    }    

    /**
     * Add classifications to the supplied host
     * @param userId user identity
     * @param entityGuid the GUID value for host
     * @param classifications the classifications to apply.
     * @return the host entity that has been classified
     */
     public Host addHostClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addHostClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         Host hostClassificationBeans = HostMapper.mapOmrsEntityDetailToHost(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified Host=" +  hostClassificationBeans);
         }
         return  hostClassificationBeans;
    }

    /**
     * Updates classifications to an existing host represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the host
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given host guid
     */
    public Host updateHostClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateHostClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           Host  hostClassificationBeans = HostMapper.mapOmrsEntityDetailToHost(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  hostClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing host represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the host
     * @param name name of the classification
     * @return deleted Host  classification
     */
    public Host deleteHostClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteHostClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       Host declassifiedHost =  HostMapper.mapOmrsEntityDetailToHost(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedHost;
    }

    /**
      * Get the relationships associated with entity host represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the host
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getHostRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getHostRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an informationView given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the informationViews relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return InformationView the InformationView entity with the requested GUID
     */
    public InformationView getInformationView(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getInformationView";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        InformationView gotinformationView = InformationViewMapper.mapOmrsEntityDetailToInformationView(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotinformationView );
        }
        return gotinformationView;

    }
    /**
     * Create new informationView.
     * @param userId user identity
     * @param informationView the input entity with values.
     * @return InformationView the created entity.
     */

    public InformationView createInformationView(String userId,InformationView informationView)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createInformationView";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = InformationViewMapper.mapInformationViewToOmrsEntityDetail(informationView);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        InformationView createdInformationView =  InformationViewMapper.mapOmrsEntityDetailToInformationView(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created InformationView="+ createdInformationView );
        }
        return createdInformationView;
    }
    /**
     * Update informationView
     * @param userId user identity
     * @param informationView   informationView to update
     * @return InformationView the updated informationView entity
     */
    public InformationView updateInformationView(String userId, InformationView informationView)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateInformationView";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = InformationViewMapper.mapInformationViewToOmrsEntityDetail(informationView);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            InformationView updatedInformationView =  InformationViewMapper.mapOmrsEntityDetailToInformationView(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated InformationView="+ updatedInformationView );
            }
            return updatedInformationView;
        }

    /**
     * Delete an informationView identified by its GUID. Delete is a soft delete, this means that the informationView has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the informationView
     * @return InformationView the deleted InformationView entity
     */

    public InformationView deleteInformationView(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteInformationView";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the InformationView type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("InformationView");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"InformationView",entityDef.getGUID(),entityGuid);
         InformationView deletedInformationView = InformationViewMapper.mapOmrsEntityDetailToInformationView(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedInformationView;

    }
    /**
     * Purge an informationView identified by its GUID. Delete is a hard delete, this means that the informationView is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the informationView
     */
    public void purgeInformationView(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeInformationView";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the InformationView type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("InformationView");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"InformationView",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an InformationView identified by its GUID. Restore resurrects a soft deleted InformationView. When a InformationView was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the InformationView
     * @return  InformationView the restored InformationView
     */
    public InformationView restoreInformationView(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreInformationView";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        InformationView restoredInformationView =  InformationViewMapper.mapOmrsEntityDetailToInformationView(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredInformationView;
    }    

    /**
     * Add classifications to the supplied informationView
     * @param userId user identity
     * @param entityGuid the GUID value for informationView
     * @param classifications the classifications to apply.
     * @return the informationView entity that has been classified
     */
     public InformationView addInformationViewClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addInformationViewClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         InformationView informationViewClassificationBeans = InformationViewMapper.mapOmrsEntityDetailToInformationView(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified InformationView=" +  informationViewClassificationBeans);
         }
         return  informationViewClassificationBeans;
    }

    /**
     * Updates classifications to an existing informationView represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the informationView
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given informationView guid
     */
    public InformationView updateInformationViewClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateInformationViewClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           InformationView  informationViewClassificationBeans = InformationViewMapper.mapOmrsEntityDetailToInformationView(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  informationViewClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing informationView represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the informationView
     * @param name name of the classification
     * @return deleted InformationView  classification
     */
    public InformationView deleteInformationViewClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteInformationViewClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       InformationView declassifiedInformationView =  InformationViewMapper.mapOmrsEntityDetailToInformationView(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedInformationView;
    }

    /**
      * Get the relationships associated with entity informationView represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the informationView
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getInformationViewRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getInformationViewRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an organizationalControl given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the organizationalControls relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return OrganizationalControl the OrganizationalControl entity with the requested GUID
     */
    public OrganizationalControl getOrganizationalControl(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getOrganizationalControl";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        OrganizationalControl gotorganizationalControl = OrganizationalControlMapper.mapOmrsEntityDetailToOrganizationalControl(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotorganizationalControl );
        }
        return gotorganizationalControl;

    }
    /**
     * Create new organizationalControl.
     * @param userId user identity
     * @param organizationalControl the input entity with values.
     * @return OrganizationalControl the created entity.
     */

    public OrganizationalControl createOrganizationalControl(String userId,OrganizationalControl organizationalControl)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createOrganizationalControl";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = OrganizationalControlMapper.mapOrganizationalControlToOmrsEntityDetail(organizationalControl);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        OrganizationalControl createdOrganizationalControl =  OrganizationalControlMapper.mapOmrsEntityDetailToOrganizationalControl(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created OrganizationalControl="+ createdOrganizationalControl );
        }
        return createdOrganizationalControl;
    }
    /**
     * Update organizationalControl
     * @param userId user identity
     * @param organizationalControl   organizationalControl to update
     * @return OrganizationalControl the updated organizationalControl entity
     */
    public OrganizationalControl updateOrganizationalControl(String userId, OrganizationalControl organizationalControl)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateOrganizationalControl";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = OrganizationalControlMapper.mapOrganizationalControlToOmrsEntityDetail(organizationalControl);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            OrganizationalControl updatedOrganizationalControl =  OrganizationalControlMapper.mapOmrsEntityDetailToOrganizationalControl(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated OrganizationalControl="+ updatedOrganizationalControl );
            }
            return updatedOrganizationalControl;
        }

    /**
     * Delete an organizationalControl identified by its GUID. Delete is a soft delete, this means that the organizationalControl has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the organizationalControl
     * @return OrganizationalControl the deleted OrganizationalControl entity
     */

    public OrganizationalControl deleteOrganizationalControl(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteOrganizationalControl";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the OrganizationalControl type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("OrganizationalControl");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"OrganizationalControl",entityDef.getGUID(),entityGuid);
         OrganizationalControl deletedOrganizationalControl = OrganizationalControlMapper.mapOmrsEntityDetailToOrganizationalControl(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedOrganizationalControl;

    }
    /**
     * Purge an organizationalControl identified by its GUID. Delete is a hard delete, this means that the organizationalControl is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the organizationalControl
     */
    public void purgeOrganizationalControl(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeOrganizationalControl";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the OrganizationalControl type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("OrganizationalControl");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"OrganizationalControl",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an OrganizationalControl identified by its GUID. Restore resurrects a soft deleted OrganizationalControl. When a OrganizationalControl was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the OrganizationalControl
     * @return  OrganizationalControl the restored OrganizationalControl
     */
    public OrganizationalControl restoreOrganizationalControl(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreOrganizationalControl";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        OrganizationalControl restoredOrganizationalControl =  OrganizationalControlMapper.mapOmrsEntityDetailToOrganizationalControl(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredOrganizationalControl;
    }    

    /**
     * Add classifications to the supplied organizationalControl
     * @param userId user identity
     * @param entityGuid the GUID value for organizationalControl
     * @param classifications the classifications to apply.
     * @return the organizationalControl entity that has been classified
     */
     public OrganizationalControl addOrganizationalControlClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addOrganizationalControlClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         OrganizationalControl organizationalControlClassificationBeans = OrganizationalControlMapper.mapOmrsEntityDetailToOrganizationalControl(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified OrganizationalControl=" +  organizationalControlClassificationBeans);
         }
         return  organizationalControlClassificationBeans;
    }

    /**
     * Updates classifications to an existing organizationalControl represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the organizationalControl
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given organizationalControl guid
     */
    public OrganizationalControl updateOrganizationalControlClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateOrganizationalControlClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           OrganizationalControl  organizationalControlClassificationBeans = OrganizationalControlMapper.mapOmrsEntityDetailToOrganizationalControl(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  organizationalControlClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing organizationalControl represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the organizationalControl
     * @param name name of the classification
     * @return deleted OrganizationalControl  classification
     */
    public OrganizationalControl deleteOrganizationalControlClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteOrganizationalControlClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       OrganizationalControl declassifiedOrganizationalControl =  OrganizationalControlMapper.mapOmrsEntityDetailToOrganizationalControl(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedOrganizationalControl;
    }

    /**
      * Get the relationships associated with entity organizationalControl represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the organizationalControl
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getOrganizationalControlRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getOrganizationalControlRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an subscriberList given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the subscriberLists relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return SubscriberList the SubscriberList entity with the requested GUID
     */
    public SubscriberList getSubscriberList(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getSubscriberList";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        SubscriberList gotsubscriberList = SubscriberListMapper.mapOmrsEntityDetailToSubscriberList(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotsubscriberList );
        }
        return gotsubscriberList;

    }
    /**
     * Create new subscriberList.
     * @param userId user identity
     * @param subscriberList the input entity with values.
     * @return SubscriberList the created entity.
     */

    public SubscriberList createSubscriberList(String userId,SubscriberList subscriberList)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createSubscriberList";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = SubscriberListMapper.mapSubscriberListToOmrsEntityDetail(subscriberList);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        SubscriberList createdSubscriberList =  SubscriberListMapper.mapOmrsEntityDetailToSubscriberList(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created SubscriberList="+ createdSubscriberList );
        }
        return createdSubscriberList;
    }
    /**
     * Update subscriberList
     * @param userId user identity
     * @param subscriberList   subscriberList to update
     * @return SubscriberList the updated subscriberList entity
     */
    public SubscriberList updateSubscriberList(String userId, SubscriberList subscriberList)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateSubscriberList";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = SubscriberListMapper.mapSubscriberListToOmrsEntityDetail(subscriberList);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            SubscriberList updatedSubscriberList =  SubscriberListMapper.mapOmrsEntityDetailToSubscriberList(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated SubscriberList="+ updatedSubscriberList );
            }
            return updatedSubscriberList;
        }

    /**
     * Delete an subscriberList identified by its GUID. Delete is a soft delete, this means that the subscriberList has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the subscriberList
     * @return SubscriberList the deleted SubscriberList entity
     */

    public SubscriberList deleteSubscriberList(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteSubscriberList";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the SubscriberList type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("SubscriberList");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"SubscriberList",entityDef.getGUID(),entityGuid);
         SubscriberList deletedSubscriberList = SubscriberListMapper.mapOmrsEntityDetailToSubscriberList(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedSubscriberList;

    }
    /**
     * Purge an subscriberList identified by its GUID. Delete is a hard delete, this means that the subscriberList is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the subscriberList
     */
    public void purgeSubscriberList(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeSubscriberList";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the SubscriberList type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("SubscriberList");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"SubscriberList",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an SubscriberList identified by its GUID. Restore resurrects a soft deleted SubscriberList. When a SubscriberList was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the SubscriberList
     * @return  SubscriberList the restored SubscriberList
     */
    public SubscriberList restoreSubscriberList(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreSubscriberList";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        SubscriberList restoredSubscriberList =  SubscriberListMapper.mapOmrsEntityDetailToSubscriberList(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredSubscriberList;
    }    

    /**
     * Add classifications to the supplied subscriberList
     * @param userId user identity
     * @param entityGuid the GUID value for subscriberList
     * @param classifications the classifications to apply.
     * @return the subscriberList entity that has been classified
     */
     public SubscriberList addSubscriberListClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addSubscriberListClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         SubscriberList subscriberListClassificationBeans = SubscriberListMapper.mapOmrsEntityDetailToSubscriberList(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified SubscriberList=" +  subscriberListClassificationBeans);
         }
         return  subscriberListClassificationBeans;
    }

    /**
     * Updates classifications to an existing subscriberList represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the subscriberList
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given subscriberList guid
     */
    public SubscriberList updateSubscriberListClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateSubscriberListClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           SubscriberList  subscriberListClassificationBeans = SubscriberListMapper.mapOmrsEntityDetailToSubscriberList(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  subscriberListClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing subscriberList represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the subscriberList
     * @param name name of the classification
     * @return deleted SubscriberList  classification
     */
    public SubscriberList deleteSubscriberListClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteSubscriberListClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       SubscriberList declassifiedSubscriberList =  SubscriberListMapper.mapOmrsEntityDetailToSubscriberList(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedSubscriberList;
    }

    /**
      * Get the relationships associated with entity subscriberList represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the subscriberList
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getSubscriberListRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getSubscriberListRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an teamMember given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the teamMembers relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return TeamMember the TeamMember entity with the requested GUID
     */
    public TeamMember getTeamMember(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getTeamMember";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        TeamMember gotteamMember = TeamMemberMapper.mapOmrsEntityDetailToTeamMember(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotteamMember );
        }
        return gotteamMember;

    }
    /**
     * Create new teamMember.
     * @param userId user identity
     * @param teamMember the input entity with values.
     * @return TeamMember the created entity.
     */

    public TeamMember createTeamMember(String userId,TeamMember teamMember)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createTeamMember";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = TeamMemberMapper.mapTeamMemberToOmrsEntityDetail(teamMember);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        TeamMember createdTeamMember =  TeamMemberMapper.mapOmrsEntityDetailToTeamMember(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created TeamMember="+ createdTeamMember );
        }
        return createdTeamMember;
    }
    /**
     * Update teamMember
     * @param userId user identity
     * @param teamMember   teamMember to update
     * @return TeamMember the updated teamMember entity
     */
    public TeamMember updateTeamMember(String userId, TeamMember teamMember)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateTeamMember";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = TeamMemberMapper.mapTeamMemberToOmrsEntityDetail(teamMember);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            TeamMember updatedTeamMember =  TeamMemberMapper.mapOmrsEntityDetailToTeamMember(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated TeamMember="+ updatedTeamMember );
            }
            return updatedTeamMember;
        }

    /**
     * Delete an teamMember identified by its GUID. Delete is a soft delete, this means that the teamMember has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the teamMember
     * @return TeamMember the deleted TeamMember entity
     */

    public TeamMember deleteTeamMember(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteTeamMember";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the TeamMember type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("TeamMember");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"TeamMember",entityDef.getGUID(),entityGuid);
         TeamMember deletedTeamMember = TeamMemberMapper.mapOmrsEntityDetailToTeamMember(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedTeamMember;

    }
    /**
     * Purge an teamMember identified by its GUID. Delete is a hard delete, this means that the teamMember is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the teamMember
     */
    public void purgeTeamMember(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeTeamMember";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the TeamMember type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("TeamMember");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"TeamMember",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an TeamMember identified by its GUID. Restore resurrects a soft deleted TeamMember. When a TeamMember was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the TeamMember
     * @return  TeamMember the restored TeamMember
     */
    public TeamMember restoreTeamMember(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreTeamMember";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        TeamMember restoredTeamMember =  TeamMemberMapper.mapOmrsEntityDetailToTeamMember(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredTeamMember;
    }    

    /**
     * Add classifications to the supplied teamMember
     * @param userId user identity
     * @param entityGuid the GUID value for teamMember
     * @param classifications the classifications to apply.
     * @return the teamMember entity that has been classified
     */
     public TeamMember addTeamMemberClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addTeamMemberClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         TeamMember teamMemberClassificationBeans = TeamMemberMapper.mapOmrsEntityDetailToTeamMember(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified TeamMember=" +  teamMemberClassificationBeans);
         }
         return  teamMemberClassificationBeans;
    }

    /**
     * Updates classifications to an existing teamMember represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the teamMember
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given teamMember guid
     */
    public TeamMember updateTeamMemberClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateTeamMemberClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           TeamMember  teamMemberClassificationBeans = TeamMemberMapper.mapOmrsEntityDetailToTeamMember(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  teamMemberClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing teamMember represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the teamMember
     * @param name name of the classification
     * @return deleted TeamMember  classification
     */
    public TeamMember deleteTeamMemberClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteTeamMemberClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       TeamMember declassifiedTeamMember =  TeamMemberMapper.mapOmrsEntityDetailToTeamMember(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedTeamMember;
    }

    /**
      * Get the relationships associated with entity teamMember represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the teamMember
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getTeamMemberRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getTeamMemberRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an communityMember given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the communityMembers relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return CommunityMember the CommunityMember entity with the requested GUID
     */
    public CommunityMember getCommunityMember(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getCommunityMember";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        CommunityMember gotcommunityMember = CommunityMemberMapper.mapOmrsEntityDetailToCommunityMember(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotcommunityMember );
        }
        return gotcommunityMember;

    }
    /**
     * Create new communityMember.
     * @param userId user identity
     * @param communityMember the input entity with values.
     * @return CommunityMember the created entity.
     */

    public CommunityMember createCommunityMember(String userId,CommunityMember communityMember)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createCommunityMember";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = CommunityMemberMapper.mapCommunityMemberToOmrsEntityDetail(communityMember);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        CommunityMember createdCommunityMember =  CommunityMemberMapper.mapOmrsEntityDetailToCommunityMember(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created CommunityMember="+ createdCommunityMember );
        }
        return createdCommunityMember;
    }
    /**
     * Update communityMember
     * @param userId user identity
     * @param communityMember   communityMember to update
     * @return CommunityMember the updated communityMember entity
     */
    public CommunityMember updateCommunityMember(String userId, CommunityMember communityMember)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateCommunityMember";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = CommunityMemberMapper.mapCommunityMemberToOmrsEntityDetail(communityMember);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            CommunityMember updatedCommunityMember =  CommunityMemberMapper.mapOmrsEntityDetailToCommunityMember(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated CommunityMember="+ updatedCommunityMember );
            }
            return updatedCommunityMember;
        }

    /**
     * Delete an communityMember identified by its GUID. Delete is a soft delete, this means that the communityMember has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the communityMember
     * @return CommunityMember the deleted CommunityMember entity
     */

    public CommunityMember deleteCommunityMember(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteCommunityMember";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the CommunityMember type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("CommunityMember");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"CommunityMember",entityDef.getGUID(),entityGuid);
         CommunityMember deletedCommunityMember = CommunityMemberMapper.mapOmrsEntityDetailToCommunityMember(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedCommunityMember;

    }
    /**
     * Purge an communityMember identified by its GUID. Delete is a hard delete, this means that the communityMember is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the communityMember
     */
    public void purgeCommunityMember(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeCommunityMember";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the CommunityMember type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("CommunityMember");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"CommunityMember",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an CommunityMember identified by its GUID. Restore resurrects a soft deleted CommunityMember. When a CommunityMember was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the CommunityMember
     * @return  CommunityMember the restored CommunityMember
     */
    public CommunityMember restoreCommunityMember(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreCommunityMember";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        CommunityMember restoredCommunityMember =  CommunityMemberMapper.mapOmrsEntityDetailToCommunityMember(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredCommunityMember;
    }    

    /**
     * Add classifications to the supplied communityMember
     * @param userId user identity
     * @param entityGuid the GUID value for communityMember
     * @param classifications the classifications to apply.
     * @return the communityMember entity that has been classified
     */
     public CommunityMember addCommunityMemberClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addCommunityMemberClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         CommunityMember communityMemberClassificationBeans = CommunityMemberMapper.mapOmrsEntityDetailToCommunityMember(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified CommunityMember=" +  communityMemberClassificationBeans);
         }
         return  communityMemberClassificationBeans;
    }

    /**
     * Updates classifications to an existing communityMember represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the communityMember
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given communityMember guid
     */
    public CommunityMember updateCommunityMemberClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateCommunityMemberClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           CommunityMember  communityMemberClassificationBeans = CommunityMemberMapper.mapOmrsEntityDetailToCommunityMember(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  communityMemberClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing communityMember represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the communityMember
     * @param name name of the classification
     * @return deleted CommunityMember  classification
     */
    public CommunityMember deleteCommunityMemberClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteCommunityMemberClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       CommunityMember declassifiedCommunityMember =  CommunityMemberMapper.mapOmrsEntityDetailToCommunityMember(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedCommunityMember;
    }

    /**
      * Get the relationships associated with entity communityMember represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the communityMember
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getCommunityMemberRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getCommunityMemberRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an openDiscoveryPipeline given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the openDiscoveryPipelines relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return OpenDiscoveryPipeline the OpenDiscoveryPipeline entity with the requested GUID
     */
    public OpenDiscoveryPipeline getOpenDiscoveryPipeline(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getOpenDiscoveryPipeline";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        OpenDiscoveryPipeline gotopenDiscoveryPipeline = OpenDiscoveryPipelineMapper.mapOmrsEntityDetailToOpenDiscoveryPipeline(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotopenDiscoveryPipeline );
        }
        return gotopenDiscoveryPipeline;

    }
    /**
     * Create new openDiscoveryPipeline.
     * @param userId user identity
     * @param openDiscoveryPipeline the input entity with values.
     * @return OpenDiscoveryPipeline the created entity.
     */

    public OpenDiscoveryPipeline createOpenDiscoveryPipeline(String userId,OpenDiscoveryPipeline openDiscoveryPipeline)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createOpenDiscoveryPipeline";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = OpenDiscoveryPipelineMapper.mapOpenDiscoveryPipelineToOmrsEntityDetail(openDiscoveryPipeline);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        OpenDiscoveryPipeline createdOpenDiscoveryPipeline =  OpenDiscoveryPipelineMapper.mapOmrsEntityDetailToOpenDiscoveryPipeline(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created OpenDiscoveryPipeline="+ createdOpenDiscoveryPipeline );
        }
        return createdOpenDiscoveryPipeline;
    }
    /**
     * Update openDiscoveryPipeline
     * @param userId user identity
     * @param openDiscoveryPipeline   openDiscoveryPipeline to update
     * @return OpenDiscoveryPipeline the updated openDiscoveryPipeline entity
     */
    public OpenDiscoveryPipeline updateOpenDiscoveryPipeline(String userId, OpenDiscoveryPipeline openDiscoveryPipeline)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateOpenDiscoveryPipeline";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = OpenDiscoveryPipelineMapper.mapOpenDiscoveryPipelineToOmrsEntityDetail(openDiscoveryPipeline);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            OpenDiscoveryPipeline updatedOpenDiscoveryPipeline =  OpenDiscoveryPipelineMapper.mapOmrsEntityDetailToOpenDiscoveryPipeline(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated OpenDiscoveryPipeline="+ updatedOpenDiscoveryPipeline );
            }
            return updatedOpenDiscoveryPipeline;
        }

    /**
     * Delete an openDiscoveryPipeline identified by its GUID. Delete is a soft delete, this means that the openDiscoveryPipeline has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the openDiscoveryPipeline
     * @return OpenDiscoveryPipeline the deleted OpenDiscoveryPipeline entity
     */

    public OpenDiscoveryPipeline deleteOpenDiscoveryPipeline(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteOpenDiscoveryPipeline";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the OpenDiscoveryPipeline type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("OpenDiscoveryPipeline");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"OpenDiscoveryPipeline",entityDef.getGUID(),entityGuid);
         OpenDiscoveryPipeline deletedOpenDiscoveryPipeline = OpenDiscoveryPipelineMapper.mapOmrsEntityDetailToOpenDiscoveryPipeline(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedOpenDiscoveryPipeline;

    }
    /**
     * Purge an openDiscoveryPipeline identified by its GUID. Delete is a hard delete, this means that the openDiscoveryPipeline is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the openDiscoveryPipeline
     */
    public void purgeOpenDiscoveryPipeline(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeOpenDiscoveryPipeline";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the OpenDiscoveryPipeline type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("OpenDiscoveryPipeline");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"OpenDiscoveryPipeline",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an OpenDiscoveryPipeline identified by its GUID. Restore resurrects a soft deleted OpenDiscoveryPipeline. When a OpenDiscoveryPipeline was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the OpenDiscoveryPipeline
     * @return  OpenDiscoveryPipeline the restored OpenDiscoveryPipeline
     */
    public OpenDiscoveryPipeline restoreOpenDiscoveryPipeline(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreOpenDiscoveryPipeline";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        OpenDiscoveryPipeline restoredOpenDiscoveryPipeline =  OpenDiscoveryPipelineMapper.mapOmrsEntityDetailToOpenDiscoveryPipeline(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredOpenDiscoveryPipeline;
    }    

    /**
     * Add classifications to the supplied openDiscoveryPipeline
     * @param userId user identity
     * @param entityGuid the GUID value for openDiscoveryPipeline
     * @param classifications the classifications to apply.
     * @return the openDiscoveryPipeline entity that has been classified
     */
     public OpenDiscoveryPipeline addOpenDiscoveryPipelineClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addOpenDiscoveryPipelineClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         OpenDiscoveryPipeline openDiscoveryPipelineClassificationBeans = OpenDiscoveryPipelineMapper.mapOmrsEntityDetailToOpenDiscoveryPipeline(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified OpenDiscoveryPipeline=" +  openDiscoveryPipelineClassificationBeans);
         }
         return  openDiscoveryPipelineClassificationBeans;
    }

    /**
     * Updates classifications to an existing openDiscoveryPipeline represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the openDiscoveryPipeline
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given openDiscoveryPipeline guid
     */
    public OpenDiscoveryPipeline updateOpenDiscoveryPipelineClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateOpenDiscoveryPipelineClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           OpenDiscoveryPipeline  openDiscoveryPipelineClassificationBeans = OpenDiscoveryPipelineMapper.mapOmrsEntityDetailToOpenDiscoveryPipeline(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  openDiscoveryPipelineClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing openDiscoveryPipeline represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the openDiscoveryPipeline
     * @param name name of the classification
     * @return deleted OpenDiscoveryPipeline  classification
     */
    public OpenDiscoveryPipeline deleteOpenDiscoveryPipelineClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteOpenDiscoveryPipelineClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       OpenDiscoveryPipeline declassifiedOpenDiscoveryPipeline =  OpenDiscoveryPipelineMapper.mapOmrsEntityDetailToOpenDiscoveryPipeline(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedOpenDiscoveryPipeline;
    }

    /**
      * Get the relationships associated with entity openDiscoveryPipeline represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the openDiscoveryPipeline
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getOpenDiscoveryPipelineRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getOpenDiscoveryPipelineRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an noteLog given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the noteLogs relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return NoteLog the NoteLog entity with the requested GUID
     */
    public NoteLog getNoteLog(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getNoteLog";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        NoteLog gotnoteLog = NoteLogMapper.mapOmrsEntityDetailToNoteLog(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotnoteLog );
        }
        return gotnoteLog;

    }
    /**
     * Create new noteLog.
     * @param userId user identity
     * @param noteLog the input entity with values.
     * @return NoteLog the created entity.
     */

    public NoteLog createNoteLog(String userId,NoteLog noteLog)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createNoteLog";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = NoteLogMapper.mapNoteLogToOmrsEntityDetail(noteLog);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        NoteLog createdNoteLog =  NoteLogMapper.mapOmrsEntityDetailToNoteLog(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created NoteLog="+ createdNoteLog );
        }
        return createdNoteLog;
    }
    /**
     * Update noteLog
     * @param userId user identity
     * @param noteLog   noteLog to update
     * @return NoteLog the updated noteLog entity
     */
    public NoteLog updateNoteLog(String userId, NoteLog noteLog)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateNoteLog";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = NoteLogMapper.mapNoteLogToOmrsEntityDetail(noteLog);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            NoteLog updatedNoteLog =  NoteLogMapper.mapOmrsEntityDetailToNoteLog(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated NoteLog="+ updatedNoteLog );
            }
            return updatedNoteLog;
        }

    /**
     * Delete an noteLog identified by its GUID. Delete is a soft delete, this means that the noteLog has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the noteLog
     * @return NoteLog the deleted NoteLog entity
     */

    public NoteLog deleteNoteLog(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteNoteLog";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the NoteLog type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("NoteLog");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"NoteLog",entityDef.getGUID(),entityGuid);
         NoteLog deletedNoteLog = NoteLogMapper.mapOmrsEntityDetailToNoteLog(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedNoteLog;

    }
    /**
     * Purge an noteLog identified by its GUID. Delete is a hard delete, this means that the noteLog is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the noteLog
     */
    public void purgeNoteLog(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeNoteLog";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the NoteLog type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("NoteLog");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"NoteLog",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an NoteLog identified by its GUID. Restore resurrects a soft deleted NoteLog. When a NoteLog was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the NoteLog
     * @return  NoteLog the restored NoteLog
     */
    public NoteLog restoreNoteLog(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreNoteLog";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        NoteLog restoredNoteLog =  NoteLogMapper.mapOmrsEntityDetailToNoteLog(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredNoteLog;
    }    

    /**
     * Add classifications to the supplied noteLog
     * @param userId user identity
     * @param entityGuid the GUID value for noteLog
     * @param classifications the classifications to apply.
     * @return the noteLog entity that has been classified
     */
     public NoteLog addNoteLogClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addNoteLogClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         NoteLog noteLogClassificationBeans = NoteLogMapper.mapOmrsEntityDetailToNoteLog(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified NoteLog=" +  noteLogClassificationBeans);
         }
         return  noteLogClassificationBeans;
    }

    /**
     * Updates classifications to an existing noteLog represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the noteLog
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given noteLog guid
     */
    public NoteLog updateNoteLogClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateNoteLogClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           NoteLog  noteLogClassificationBeans = NoteLogMapper.mapOmrsEntityDetailToNoteLog(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  noteLogClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing noteLog represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the noteLog
     * @param name name of the classification
     * @return deleted NoteLog  classification
     */
    public NoteLog deleteNoteLogClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteNoteLogClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       NoteLog declassifiedNoteLog =  NoteLogMapper.mapOmrsEntityDetailToNoteLog(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedNoteLog;
    }

    /**
      * Get the relationships associated with entity noteLog represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the noteLog
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getNoteLogRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getNoteLogRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an controlledGlossaryTerm given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the controlledGlossaryTerms relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return ControlledGlossaryTerm the ControlledGlossaryTerm entity with the requested GUID
     */
    public ControlledGlossaryTerm getControlledGlossaryTerm(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getControlledGlossaryTerm";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        ControlledGlossaryTerm gotcontrolledGlossaryTerm = ControlledGlossaryTermMapper.mapOmrsEntityDetailToControlledGlossaryTerm(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotcontrolledGlossaryTerm );
        }
        return gotcontrolledGlossaryTerm;

    }
    /**
     * Create new controlledGlossaryTerm.
     * @param userId user identity
     * @param controlledGlossaryTerm the input entity with values.
     * @return ControlledGlossaryTerm the created entity.
     */

    public ControlledGlossaryTerm createControlledGlossaryTerm(String userId,ControlledGlossaryTerm controlledGlossaryTerm)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createControlledGlossaryTerm";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = ControlledGlossaryTermMapper.mapControlledGlossaryTermToOmrsEntityDetail(controlledGlossaryTerm);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        ControlledGlossaryTerm createdControlledGlossaryTerm =  ControlledGlossaryTermMapper.mapOmrsEntityDetailToControlledGlossaryTerm(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created ControlledGlossaryTerm="+ createdControlledGlossaryTerm );
        }
        return createdControlledGlossaryTerm;
    }
    /**
     * Update controlledGlossaryTerm
     * @param userId user identity
     * @param controlledGlossaryTerm   controlledGlossaryTerm to update
     * @return ControlledGlossaryTerm the updated controlledGlossaryTerm entity
     */
    public ControlledGlossaryTerm updateControlledGlossaryTerm(String userId, ControlledGlossaryTerm controlledGlossaryTerm)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateControlledGlossaryTerm";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = ControlledGlossaryTermMapper.mapControlledGlossaryTermToOmrsEntityDetail(controlledGlossaryTerm);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            ControlledGlossaryTerm updatedControlledGlossaryTerm =  ControlledGlossaryTermMapper.mapOmrsEntityDetailToControlledGlossaryTerm(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated ControlledGlossaryTerm="+ updatedControlledGlossaryTerm );
            }
            return updatedControlledGlossaryTerm;
        }

    /**
     * Delete an controlledGlossaryTerm identified by its GUID. Delete is a soft delete, this means that the controlledGlossaryTerm has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the controlledGlossaryTerm
     * @return ControlledGlossaryTerm the deleted ControlledGlossaryTerm entity
     */

    public ControlledGlossaryTerm deleteControlledGlossaryTerm(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteControlledGlossaryTerm";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ControlledGlossaryTerm type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ControlledGlossaryTerm");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"ControlledGlossaryTerm",entityDef.getGUID(),entityGuid);
         ControlledGlossaryTerm deletedControlledGlossaryTerm = ControlledGlossaryTermMapper.mapOmrsEntityDetailToControlledGlossaryTerm(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedControlledGlossaryTerm;

    }
    /**
     * Purge an controlledGlossaryTerm identified by its GUID. Delete is a hard delete, this means that the controlledGlossaryTerm is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the controlledGlossaryTerm
     */
    public void purgeControlledGlossaryTerm(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeControlledGlossaryTerm";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ControlledGlossaryTerm type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ControlledGlossaryTerm");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"ControlledGlossaryTerm",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an ControlledGlossaryTerm identified by its GUID. Restore resurrects a soft deleted ControlledGlossaryTerm. When a ControlledGlossaryTerm was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the ControlledGlossaryTerm
     * @return  ControlledGlossaryTerm the restored ControlledGlossaryTerm
     */
    public ControlledGlossaryTerm restoreControlledGlossaryTerm(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreControlledGlossaryTerm";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        ControlledGlossaryTerm restoredControlledGlossaryTerm =  ControlledGlossaryTermMapper.mapOmrsEntityDetailToControlledGlossaryTerm(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredControlledGlossaryTerm;
    }    

    /**
     * Add classifications to the supplied controlledGlossaryTerm
     * @param userId user identity
     * @param entityGuid the GUID value for controlledGlossaryTerm
     * @param classifications the classifications to apply.
     * @return the controlledGlossaryTerm entity that has been classified
     */
     public ControlledGlossaryTerm addControlledGlossaryTermClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addControlledGlossaryTermClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         ControlledGlossaryTerm controlledGlossaryTermClassificationBeans = ControlledGlossaryTermMapper.mapOmrsEntityDetailToControlledGlossaryTerm(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified ControlledGlossaryTerm=" +  controlledGlossaryTermClassificationBeans);
         }
         return  controlledGlossaryTermClassificationBeans;
    }

    /**
     * Updates classifications to an existing controlledGlossaryTerm represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the controlledGlossaryTerm
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given controlledGlossaryTerm guid
     */
    public ControlledGlossaryTerm updateControlledGlossaryTermClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateControlledGlossaryTermClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           ControlledGlossaryTerm  controlledGlossaryTermClassificationBeans = ControlledGlossaryTermMapper.mapOmrsEntityDetailToControlledGlossaryTerm(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  controlledGlossaryTermClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing controlledGlossaryTerm represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the controlledGlossaryTerm
     * @param name name of the classification
     * @return deleted ControlledGlossaryTerm  classification
     */
    public ControlledGlossaryTerm deleteControlledGlossaryTermClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteControlledGlossaryTermClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       ControlledGlossaryTerm declassifiedControlledGlossaryTerm =  ControlledGlossaryTermMapper.mapOmrsEntityDetailToControlledGlossaryTerm(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedControlledGlossaryTerm;
    }

    /**
      * Get the relationships associated with entity controlledGlossaryTerm represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the controlledGlossaryTerm
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getControlledGlossaryTermRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getControlledGlossaryTermRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an relationalColumnType given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the relationalColumnTypes relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return RelationalColumnType the RelationalColumnType entity with the requested GUID
     */
    public RelationalColumnType getRelationalColumnType(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getRelationalColumnType";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        RelationalColumnType gotrelationalColumnType = RelationalColumnTypeMapper.mapOmrsEntityDetailToRelationalColumnType(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotrelationalColumnType );
        }
        return gotrelationalColumnType;

    }
    /**
     * Create new relationalColumnType.
     * @param userId user identity
     * @param relationalColumnType the input entity with values.
     * @return RelationalColumnType the created entity.
     */

    public RelationalColumnType createRelationalColumnType(String userId,RelationalColumnType relationalColumnType)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createRelationalColumnType";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = RelationalColumnTypeMapper.mapRelationalColumnTypeToOmrsEntityDetail(relationalColumnType);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        RelationalColumnType createdRelationalColumnType =  RelationalColumnTypeMapper.mapOmrsEntityDetailToRelationalColumnType(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created RelationalColumnType="+ createdRelationalColumnType );
        }
        return createdRelationalColumnType;
    }
    /**
     * Update relationalColumnType
     * @param userId user identity
     * @param relationalColumnType   relationalColumnType to update
     * @return RelationalColumnType the updated relationalColumnType entity
     */
    public RelationalColumnType updateRelationalColumnType(String userId, RelationalColumnType relationalColumnType)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateRelationalColumnType";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = RelationalColumnTypeMapper.mapRelationalColumnTypeToOmrsEntityDetail(relationalColumnType);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            RelationalColumnType updatedRelationalColumnType =  RelationalColumnTypeMapper.mapOmrsEntityDetailToRelationalColumnType(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated RelationalColumnType="+ updatedRelationalColumnType );
            }
            return updatedRelationalColumnType;
        }

    /**
     * Delete an relationalColumnType identified by its GUID. Delete is a soft delete, this means that the relationalColumnType has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the relationalColumnType
     * @return RelationalColumnType the deleted RelationalColumnType entity
     */

    public RelationalColumnType deleteRelationalColumnType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteRelationalColumnType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the RelationalColumnType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("RelationalColumnType");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"RelationalColumnType",entityDef.getGUID(),entityGuid);
         RelationalColumnType deletedRelationalColumnType = RelationalColumnTypeMapper.mapOmrsEntityDetailToRelationalColumnType(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedRelationalColumnType;

    }
    /**
     * Purge an relationalColumnType identified by its GUID. Delete is a hard delete, this means that the relationalColumnType is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the relationalColumnType
     */
    public void purgeRelationalColumnType(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeRelationalColumnType";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the RelationalColumnType type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("RelationalColumnType");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"RelationalColumnType",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an RelationalColumnType identified by its GUID. Restore resurrects a soft deleted RelationalColumnType. When a RelationalColumnType was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the RelationalColumnType
     * @return  RelationalColumnType the restored RelationalColumnType
     */
    public RelationalColumnType restoreRelationalColumnType(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreRelationalColumnType";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        RelationalColumnType restoredRelationalColumnType =  RelationalColumnTypeMapper.mapOmrsEntityDetailToRelationalColumnType(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredRelationalColumnType;
    }    

    /**
     * Add classifications to the supplied relationalColumnType
     * @param userId user identity
     * @param entityGuid the GUID value for relationalColumnType
     * @param classifications the classifications to apply.
     * @return the relationalColumnType entity that has been classified
     */
     public RelationalColumnType addRelationalColumnTypeClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addRelationalColumnTypeClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         RelationalColumnType relationalColumnTypeClassificationBeans = RelationalColumnTypeMapper.mapOmrsEntityDetailToRelationalColumnType(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified RelationalColumnType=" +  relationalColumnTypeClassificationBeans);
         }
         return  relationalColumnTypeClassificationBeans;
    }

    /**
     * Updates classifications to an existing relationalColumnType represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the relationalColumnType
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given relationalColumnType guid
     */
    public RelationalColumnType updateRelationalColumnTypeClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateRelationalColumnTypeClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           RelationalColumnType  relationalColumnTypeClassificationBeans = RelationalColumnTypeMapper.mapOmrsEntityDetailToRelationalColumnType(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  relationalColumnTypeClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing relationalColumnType represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the relationalColumnType
     * @param name name of the classification
     * @return deleted RelationalColumnType  classification
     */
    public RelationalColumnType deleteRelationalColumnTypeClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteRelationalColumnTypeClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       RelationalColumnType declassifiedRelationalColumnType =  RelationalColumnTypeMapper.mapOmrsEntityDetailToRelationalColumnType(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedRelationalColumnType;
    }

    /**
      * Get the relationships associated with entity relationalColumnType represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the relationalColumnType
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getRelationalColumnTypeRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getRelationalColumnTypeRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an externalGlossaryLink given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the externalGlossaryLinks relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return ExternalGlossaryLink the ExternalGlossaryLink entity with the requested GUID
     */
    public ExternalGlossaryLink getExternalGlossaryLink(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getExternalGlossaryLink";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        ExternalGlossaryLink gotexternalGlossaryLink = ExternalGlossaryLinkMapper.mapOmrsEntityDetailToExternalGlossaryLink(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotexternalGlossaryLink );
        }
        return gotexternalGlossaryLink;

    }
    /**
     * Create new externalGlossaryLink.
     * @param userId user identity
     * @param externalGlossaryLink the input entity with values.
     * @return ExternalGlossaryLink the created entity.
     */

    public ExternalGlossaryLink createExternalGlossaryLink(String userId,ExternalGlossaryLink externalGlossaryLink)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createExternalGlossaryLink";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = ExternalGlossaryLinkMapper.mapExternalGlossaryLinkToOmrsEntityDetail(externalGlossaryLink);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        ExternalGlossaryLink createdExternalGlossaryLink =  ExternalGlossaryLinkMapper.mapOmrsEntityDetailToExternalGlossaryLink(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created ExternalGlossaryLink="+ createdExternalGlossaryLink );
        }
        return createdExternalGlossaryLink;
    }
    /**
     * Update externalGlossaryLink
     * @param userId user identity
     * @param externalGlossaryLink   externalGlossaryLink to update
     * @return ExternalGlossaryLink the updated externalGlossaryLink entity
     */
    public ExternalGlossaryLink updateExternalGlossaryLink(String userId, ExternalGlossaryLink externalGlossaryLink)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateExternalGlossaryLink";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = ExternalGlossaryLinkMapper.mapExternalGlossaryLinkToOmrsEntityDetail(externalGlossaryLink);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            ExternalGlossaryLink updatedExternalGlossaryLink =  ExternalGlossaryLinkMapper.mapOmrsEntityDetailToExternalGlossaryLink(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated ExternalGlossaryLink="+ updatedExternalGlossaryLink );
            }
            return updatedExternalGlossaryLink;
        }

    /**
     * Delete an externalGlossaryLink identified by its GUID. Delete is a soft delete, this means that the externalGlossaryLink has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the externalGlossaryLink
     * @return ExternalGlossaryLink the deleted ExternalGlossaryLink entity
     */

    public ExternalGlossaryLink deleteExternalGlossaryLink(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteExternalGlossaryLink";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ExternalGlossaryLink type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ExternalGlossaryLink");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"ExternalGlossaryLink",entityDef.getGUID(),entityGuid);
         ExternalGlossaryLink deletedExternalGlossaryLink = ExternalGlossaryLinkMapper.mapOmrsEntityDetailToExternalGlossaryLink(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedExternalGlossaryLink;

    }
    /**
     * Purge an externalGlossaryLink identified by its GUID. Delete is a hard delete, this means that the externalGlossaryLink is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the externalGlossaryLink
     */
    public void purgeExternalGlossaryLink(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeExternalGlossaryLink";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the ExternalGlossaryLink type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("ExternalGlossaryLink");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"ExternalGlossaryLink",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an ExternalGlossaryLink identified by its GUID. Restore resurrects a soft deleted ExternalGlossaryLink. When a ExternalGlossaryLink was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the ExternalGlossaryLink
     * @return  ExternalGlossaryLink the restored ExternalGlossaryLink
     */
    public ExternalGlossaryLink restoreExternalGlossaryLink(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreExternalGlossaryLink";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        ExternalGlossaryLink restoredExternalGlossaryLink =  ExternalGlossaryLinkMapper.mapOmrsEntityDetailToExternalGlossaryLink(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredExternalGlossaryLink;
    }    

    /**
     * Add classifications to the supplied externalGlossaryLink
     * @param userId user identity
     * @param entityGuid the GUID value for externalGlossaryLink
     * @param classifications the classifications to apply.
     * @return the externalGlossaryLink entity that has been classified
     */
     public ExternalGlossaryLink addExternalGlossaryLinkClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addExternalGlossaryLinkClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         ExternalGlossaryLink externalGlossaryLinkClassificationBeans = ExternalGlossaryLinkMapper.mapOmrsEntityDetailToExternalGlossaryLink(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified ExternalGlossaryLink=" +  externalGlossaryLinkClassificationBeans);
         }
         return  externalGlossaryLinkClassificationBeans;
    }

    /**
     * Updates classifications to an existing externalGlossaryLink represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the externalGlossaryLink
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given externalGlossaryLink guid
     */
    public ExternalGlossaryLink updateExternalGlossaryLinkClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateExternalGlossaryLinkClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           ExternalGlossaryLink  externalGlossaryLinkClassificationBeans = ExternalGlossaryLinkMapper.mapOmrsEntityDetailToExternalGlossaryLink(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  externalGlossaryLinkClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing externalGlossaryLink represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the externalGlossaryLink
     * @param name name of the classification
     * @return deleted ExternalGlossaryLink  classification
     */
    public ExternalGlossaryLink deleteExternalGlossaryLinkClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteExternalGlossaryLinkClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       ExternalGlossaryLink declassifiedExternalGlossaryLink =  ExternalGlossaryLinkMapper.mapOmrsEntityDetailToExternalGlossaryLink(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedExternalGlossaryLink;
    }

    /**
      * Get the relationships associated with entity externalGlossaryLink represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the externalGlossaryLink
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getExternalGlossaryLinkRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getExternalGlossaryLinkRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an dataClass given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the dataClasses relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return DataClass the DataClass entity with the requested GUID
     */
    public DataClass getDataClass(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getDataClass";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        DataClass gotdataClass = DataClassMapper.mapOmrsEntityDetailToDataClass(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotdataClass );
        }
        return gotdataClass;

    }
    /**
     * Create new dataClass.
     * @param userId user identity
     * @param dataClass the input entity with values.
     * @return DataClass the created entity.
     */

    public DataClass createDataClass(String userId,DataClass dataClass)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createDataClass";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = DataClassMapper.mapDataClassToOmrsEntityDetail(dataClass);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        DataClass createdDataClass =  DataClassMapper.mapOmrsEntityDetailToDataClass(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created DataClass="+ createdDataClass );
        }
        return createdDataClass;
    }
    /**
     * Update dataClass
     * @param userId user identity
     * @param dataClass   dataClass to update
     * @return DataClass the updated dataClass entity
     */
    public DataClass updateDataClass(String userId, DataClass dataClass)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateDataClass";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = DataClassMapper.mapDataClassToOmrsEntityDetail(dataClass);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            DataClass updatedDataClass =  DataClassMapper.mapOmrsEntityDetailToDataClass(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated DataClass="+ updatedDataClass );
            }
            return updatedDataClass;
        }

    /**
     * Delete an dataClass identified by its GUID. Delete is a soft delete, this means that the dataClass has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the dataClass
     * @return DataClass the deleted DataClass entity
     */

    public DataClass deleteDataClass(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteDataClass";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DataClass type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DataClass");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"DataClass",entityDef.getGUID(),entityGuid);
         DataClass deletedDataClass = DataClassMapper.mapOmrsEntityDetailToDataClass(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedDataClass;

    }
    /**
     * Purge an dataClass identified by its GUID. Delete is a hard delete, this means that the dataClass is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the dataClass
     */
    public void purgeDataClass(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeDataClass";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the DataClass type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("DataClass");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"DataClass",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an DataClass identified by its GUID. Restore resurrects a soft deleted DataClass. When a DataClass was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the DataClass
     * @return  DataClass the restored DataClass
     */
    public DataClass restoreDataClass(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreDataClass";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        DataClass restoredDataClass =  DataClassMapper.mapOmrsEntityDetailToDataClass(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredDataClass;
    }    

    /**
     * Add classifications to the supplied dataClass
     * @param userId user identity
     * @param entityGuid the GUID value for dataClass
     * @param classifications the classifications to apply.
     * @return the dataClass entity that has been classified
     */
     public DataClass addDataClassClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addDataClassClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         DataClass dataClassClassificationBeans = DataClassMapper.mapOmrsEntityDetailToDataClass(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified DataClass=" +  dataClassClassificationBeans);
         }
         return  dataClassClassificationBeans;
    }

    /**
     * Updates classifications to an existing dataClass represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the dataClass
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given dataClass guid
     */
    public DataClass updateDataClassClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateDataClassClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           DataClass  dataClassClassificationBeans = DataClassMapper.mapOmrsEntityDetailToDataClass(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  dataClassClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing dataClass represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the dataClass
     * @param name name of the classification
     * @return deleted DataClass  classification
     */
    public DataClass deleteDataClassClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteDataClassClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       DataClass declassifiedDataClass =  DataClassMapper.mapOmrsEntityDetailToDataClass(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedDataClass;
    }

    /**
      * Get the relationships associated with entity dataClass represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the dataClass
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getDataClassRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getDataClassRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an regulation given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the regulations relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return Regulation the Regulation entity with the requested GUID
     */
    public Regulation getRegulation(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getRegulation";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        Regulation gotregulation = RegulationMapper.mapOmrsEntityDetailToRegulation(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotregulation );
        }
        return gotregulation;

    }
    /**
     * Create new regulation.
     * @param userId user identity
     * @param regulation the input entity with values.
     * @return Regulation the created entity.
     */

    public Regulation createRegulation(String userId,Regulation regulation)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createRegulation";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = RegulationMapper.mapRegulationToOmrsEntityDetail(regulation);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        Regulation createdRegulation =  RegulationMapper.mapOmrsEntityDetailToRegulation(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created Regulation="+ createdRegulation );
        }
        return createdRegulation;
    }
    /**
     * Update regulation
     * @param userId user identity
     * @param regulation   regulation to update
     * @return Regulation the updated regulation entity
     */
    public Regulation updateRegulation(String userId, Regulation regulation)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateRegulation";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = RegulationMapper.mapRegulationToOmrsEntityDetail(regulation);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            Regulation updatedRegulation =  RegulationMapper.mapOmrsEntityDetailToRegulation(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated Regulation="+ updatedRegulation );
            }
            return updatedRegulation;
        }

    /**
     * Delete an regulation identified by its GUID. Delete is a soft delete, this means that the regulation has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the regulation
     * @return Regulation the deleted Regulation entity
     */

    public Regulation deleteRegulation(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteRegulation";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Regulation type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Regulation");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"Regulation",entityDef.getGUID(),entityGuid);
         Regulation deletedRegulation = RegulationMapper.mapOmrsEntityDetailToRegulation(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedRegulation;

    }
    /**
     * Purge an regulation identified by its GUID. Delete is a hard delete, this means that the regulation is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the regulation
     */
    public void purgeRegulation(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeRegulation";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Regulation type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Regulation");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"Regulation",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an Regulation identified by its GUID. Restore resurrects a soft deleted Regulation. When a Regulation was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the Regulation
     * @return  Regulation the restored Regulation
     */
    public Regulation restoreRegulation(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreRegulation";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        Regulation restoredRegulation =  RegulationMapper.mapOmrsEntityDetailToRegulation(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredRegulation;
    }    

    /**
     * Add classifications to the supplied regulation
     * @param userId user identity
     * @param entityGuid the GUID value for regulation
     * @param classifications the classifications to apply.
     * @return the regulation entity that has been classified
     */
     public Regulation addRegulationClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addRegulationClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         Regulation regulationClassificationBeans = RegulationMapper.mapOmrsEntityDetailToRegulation(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified Regulation=" +  regulationClassificationBeans);
         }
         return  regulationClassificationBeans;
    }

    /**
     * Updates classifications to an existing regulation represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the regulation
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given regulation guid
     */
    public Regulation updateRegulationClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateRegulationClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           Regulation  regulationClassificationBeans = RegulationMapper.mapOmrsEntityDetailToRegulation(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  regulationClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing regulation represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the regulation
     * @param name name of the classification
     * @return deleted Regulation  classification
     */
    public Regulation deleteRegulationClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteRegulationClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       Regulation declassifiedRegulation =  RegulationMapper.mapOmrsEntityDetailToRegulation(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedRegulation;
    }

    /**
      * Get the relationships associated with entity regulation represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the regulation
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getRegulationRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getRegulationRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an qualityAnnotation given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the qualityAnnotations relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return QualityAnnotation the QualityAnnotation entity with the requested GUID
     */
    public QualityAnnotation getQualityAnnotation(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getQualityAnnotation";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        QualityAnnotation gotqualityAnnotation = QualityAnnotationMapper.mapOmrsEntityDetailToQualityAnnotation(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotqualityAnnotation );
        }
        return gotqualityAnnotation;

    }
    /**
     * Create new qualityAnnotation.
     * @param userId user identity
     * @param qualityAnnotation the input entity with values.
     * @return QualityAnnotation the created entity.
     */

    public QualityAnnotation createQualityAnnotation(String userId,QualityAnnotation qualityAnnotation)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createQualityAnnotation";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = QualityAnnotationMapper.mapQualityAnnotationToOmrsEntityDetail(qualityAnnotation);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        QualityAnnotation createdQualityAnnotation =  QualityAnnotationMapper.mapOmrsEntityDetailToQualityAnnotation(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created QualityAnnotation="+ createdQualityAnnotation );
        }
        return createdQualityAnnotation;
    }
    /**
     * Update qualityAnnotation
     * @param userId user identity
     * @param qualityAnnotation   qualityAnnotation to update
     * @return QualityAnnotation the updated qualityAnnotation entity
     */
    public QualityAnnotation updateQualityAnnotation(String userId, QualityAnnotation qualityAnnotation)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateQualityAnnotation";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = QualityAnnotationMapper.mapQualityAnnotationToOmrsEntityDetail(qualityAnnotation);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            QualityAnnotation updatedQualityAnnotation =  QualityAnnotationMapper.mapOmrsEntityDetailToQualityAnnotation(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated QualityAnnotation="+ updatedQualityAnnotation );
            }
            return updatedQualityAnnotation;
        }

    /**
     * Delete an qualityAnnotation identified by its GUID. Delete is a soft delete, this means that the qualityAnnotation has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the qualityAnnotation
     * @return QualityAnnotation the deleted QualityAnnotation entity
     */

    public QualityAnnotation deleteQualityAnnotation(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteQualityAnnotation";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the QualityAnnotation type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("QualityAnnotation");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"QualityAnnotation",entityDef.getGUID(),entityGuid);
         QualityAnnotation deletedQualityAnnotation = QualityAnnotationMapper.mapOmrsEntityDetailToQualityAnnotation(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedQualityAnnotation;

    }
    /**
     * Purge an qualityAnnotation identified by its GUID. Delete is a hard delete, this means that the qualityAnnotation is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the qualityAnnotation
     */
    public void purgeQualityAnnotation(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeQualityAnnotation";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the QualityAnnotation type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("QualityAnnotation");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"QualityAnnotation",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an QualityAnnotation identified by its GUID. Restore resurrects a soft deleted QualityAnnotation. When a QualityAnnotation was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the QualityAnnotation
     * @return  QualityAnnotation the restored QualityAnnotation
     */
    public QualityAnnotation restoreQualityAnnotation(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreQualityAnnotation";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        QualityAnnotation restoredQualityAnnotation =  QualityAnnotationMapper.mapOmrsEntityDetailToQualityAnnotation(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredQualityAnnotation;
    }    

    /**
     * Add classifications to the supplied qualityAnnotation
     * @param userId user identity
     * @param entityGuid the GUID value for qualityAnnotation
     * @param classifications the classifications to apply.
     * @return the qualityAnnotation entity that has been classified
     */
     public QualityAnnotation addQualityAnnotationClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addQualityAnnotationClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         QualityAnnotation qualityAnnotationClassificationBeans = QualityAnnotationMapper.mapOmrsEntityDetailToQualityAnnotation(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified QualityAnnotation=" +  qualityAnnotationClassificationBeans);
         }
         return  qualityAnnotationClassificationBeans;
    }

    /**
     * Updates classifications to an existing qualityAnnotation represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the qualityAnnotation
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given qualityAnnotation guid
     */
    public QualityAnnotation updateQualityAnnotationClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateQualityAnnotationClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           QualityAnnotation  qualityAnnotationClassificationBeans = QualityAnnotationMapper.mapOmrsEntityDetailToQualityAnnotation(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  qualityAnnotationClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing qualityAnnotation represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the qualityAnnotation
     * @param name name of the classification
     * @return deleted QualityAnnotation  classification
     */
    public QualityAnnotation deleteQualityAnnotationClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteQualityAnnotationClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       QualityAnnotation declassifiedQualityAnnotation =  QualityAnnotationMapper.mapOmrsEntityDetailToQualityAnnotation(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedQualityAnnotation;
    }

    /**
      * Get the relationships associated with entity qualityAnnotation represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the qualityAnnotation
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getQualityAnnotationRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getQualityAnnotationRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an governanceProcess given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the governanceProcesses relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return GovernanceProcess the GovernanceProcess entity with the requested GUID
     */
    public GovernanceProcess getGovernanceProcess(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getGovernanceProcess";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        GovernanceProcess gotgovernanceProcess = GovernanceProcessMapper.mapOmrsEntityDetailToGovernanceProcess(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotgovernanceProcess );
        }
        return gotgovernanceProcess;

    }
    /**
     * Create new governanceProcess.
     * @param userId user identity
     * @param governanceProcess the input entity with values.
     * @return GovernanceProcess the created entity.
     */

    public GovernanceProcess createGovernanceProcess(String userId,GovernanceProcess governanceProcess)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createGovernanceProcess";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = GovernanceProcessMapper.mapGovernanceProcessToOmrsEntityDetail(governanceProcess);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        GovernanceProcess createdGovernanceProcess =  GovernanceProcessMapper.mapOmrsEntityDetailToGovernanceProcess(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created GovernanceProcess="+ createdGovernanceProcess );
        }
        return createdGovernanceProcess;
    }
    /**
     * Update governanceProcess
     * @param userId user identity
     * @param governanceProcess   governanceProcess to update
     * @return GovernanceProcess the updated governanceProcess entity
     */
    public GovernanceProcess updateGovernanceProcess(String userId, GovernanceProcess governanceProcess)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateGovernanceProcess";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = GovernanceProcessMapper.mapGovernanceProcessToOmrsEntityDetail(governanceProcess);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            GovernanceProcess updatedGovernanceProcess =  GovernanceProcessMapper.mapOmrsEntityDetailToGovernanceProcess(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated GovernanceProcess="+ updatedGovernanceProcess );
            }
            return updatedGovernanceProcess;
        }

    /**
     * Delete an governanceProcess identified by its GUID. Delete is a soft delete, this means that the governanceProcess has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the governanceProcess
     * @return GovernanceProcess the deleted GovernanceProcess entity
     */

    public GovernanceProcess deleteGovernanceProcess(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteGovernanceProcess";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GovernanceProcess type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GovernanceProcess");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"GovernanceProcess",entityDef.getGUID(),entityGuid);
         GovernanceProcess deletedGovernanceProcess = GovernanceProcessMapper.mapOmrsEntityDetailToGovernanceProcess(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedGovernanceProcess;

    }
    /**
     * Purge an governanceProcess identified by its GUID. Delete is a hard delete, this means that the governanceProcess is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the governanceProcess
     */
    public void purgeGovernanceProcess(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeGovernanceProcess";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the GovernanceProcess type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("GovernanceProcess");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"GovernanceProcess",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an GovernanceProcess identified by its GUID. Restore resurrects a soft deleted GovernanceProcess. When a GovernanceProcess was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the GovernanceProcess
     * @return  GovernanceProcess the restored GovernanceProcess
     */
    public GovernanceProcess restoreGovernanceProcess(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreGovernanceProcess";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        GovernanceProcess restoredGovernanceProcess =  GovernanceProcessMapper.mapOmrsEntityDetailToGovernanceProcess(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredGovernanceProcess;
    }    

    /**
     * Add classifications to the supplied governanceProcess
     * @param userId user identity
     * @param entityGuid the GUID value for governanceProcess
     * @param classifications the classifications to apply.
     * @return the governanceProcess entity that has been classified
     */
     public GovernanceProcess addGovernanceProcessClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addGovernanceProcessClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         GovernanceProcess governanceProcessClassificationBeans = GovernanceProcessMapper.mapOmrsEntityDetailToGovernanceProcess(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified GovernanceProcess=" +  governanceProcessClassificationBeans);
         }
         return  governanceProcessClassificationBeans;
    }

    /**
     * Updates classifications to an existing governanceProcess represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the governanceProcess
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given governanceProcess guid
     */
    public GovernanceProcess updateGovernanceProcessClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateGovernanceProcessClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           GovernanceProcess  governanceProcessClassificationBeans = GovernanceProcessMapper.mapOmrsEntityDetailToGovernanceProcess(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  governanceProcessClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing governanceProcess represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the governanceProcess
     * @param name name of the classification
     * @return deleted GovernanceProcess  classification
     */
    public GovernanceProcess deleteGovernanceProcessClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteGovernanceProcessClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       GovernanceProcess declassifiedGovernanceProcess =  GovernanceProcessMapper.mapOmrsEntityDetailToGovernanceProcess(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedGovernanceProcess;
    }

    /**
      * Get the relationships associated with entity governanceProcess represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the governanceProcess
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getGovernanceProcessRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getGovernanceProcessRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an community given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the communities relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return Community the Community entity with the requested GUID
     */
    public Community getCommunity(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getCommunity";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        Community gotcommunity = CommunityMapper.mapOmrsEntityDetailToCommunity(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotcommunity );
        }
        return gotcommunity;

    }
    /**
     * Create new community.
     * @param userId user identity
     * @param community the input entity with values.
     * @return Community the created entity.
     */

    public Community createCommunity(String userId,Community community)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createCommunity";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = CommunityMapper.mapCommunityToOmrsEntityDetail(community);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        Community createdCommunity =  CommunityMapper.mapOmrsEntityDetailToCommunity(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created Community="+ createdCommunity );
        }
        return createdCommunity;
    }
    /**
     * Update community
     * @param userId user identity
     * @param community   community to update
     * @return Community the updated community entity
     */
    public Community updateCommunity(String userId, Community community)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateCommunity";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = CommunityMapper.mapCommunityToOmrsEntityDetail(community);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            Community updatedCommunity =  CommunityMapper.mapOmrsEntityDetailToCommunity(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated Community="+ updatedCommunity );
            }
            return updatedCommunity;
        }

    /**
     * Delete an community identified by its GUID. Delete is a soft delete, this means that the community has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the community
     * @return Community the deleted Community entity
     */

    public Community deleteCommunity(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteCommunity";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Community type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Community");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"Community",entityDef.getGUID(),entityGuid);
         Community deletedCommunity = CommunityMapper.mapOmrsEntityDetailToCommunity(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedCommunity;

    }
    /**
     * Purge an community identified by its GUID. Delete is a hard delete, this means that the community is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the community
     */
    public void purgeCommunity(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeCommunity";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Community type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Community");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"Community",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an Community identified by its GUID. Restore resurrects a soft deleted Community. When a Community was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the Community
     * @return  Community the restored Community
     */
    public Community restoreCommunity(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreCommunity";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        Community restoredCommunity =  CommunityMapper.mapOmrsEntityDetailToCommunity(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredCommunity;
    }    

    /**
     * Add classifications to the supplied community
     * @param userId user identity
     * @param entityGuid the GUID value for community
     * @param classifications the classifications to apply.
     * @return the community entity that has been classified
     */
     public Community addCommunityClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addCommunityClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         Community communityClassificationBeans = CommunityMapper.mapOmrsEntityDetailToCommunity(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified Community=" +  communityClassificationBeans);
         }
         return  communityClassificationBeans;
    }

    /**
     * Updates classifications to an existing community represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the community
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given community guid
     */
    public Community updateCommunityClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateCommunityClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           Community  communityClassificationBeans = CommunityMapper.mapOmrsEntityDetailToCommunity(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  communityClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing community represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the community
     * @param name name of the classification
     * @return deleted Community  classification
     */
    public Community deleteCommunityClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteCommunityClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       Community declassifiedCommunity =  CommunityMapper.mapOmrsEntityDetailToCommunity(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedCommunity;
    }

    /**
      * Get the relationships associated with entity community represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the community
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getCommunityRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getCommunityRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an location given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the locations relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return Location the Location entity with the requested GUID
     */
    public Location getLocation(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getLocation";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        Location gotlocation = LocationMapper.mapOmrsEntityDetailToLocation(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotlocation );
        }
        return gotlocation;

    }
    /**
     * Create new location.
     * @param userId user identity
     * @param location the input entity with values.
     * @return Location the created entity.
     */

    public Location createLocation(String userId,Location location)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createLocation";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = LocationMapper.mapLocationToOmrsEntityDetail(location);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        Location createdLocation =  LocationMapper.mapOmrsEntityDetailToLocation(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created Location="+ createdLocation );
        }
        return createdLocation;
    }
    /**
     * Update location
     * @param userId user identity
     * @param location   location to update
     * @return Location the updated location entity
     */
    public Location updateLocation(String userId, Location location)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateLocation";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = LocationMapper.mapLocationToOmrsEntityDetail(location);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            Location updatedLocation =  LocationMapper.mapOmrsEntityDetailToLocation(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated Location="+ updatedLocation );
            }
            return updatedLocation;
        }

    /**
     * Delete an location identified by its GUID. Delete is a soft delete, this means that the location has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the location
     * @return Location the deleted Location entity
     */

    public Location deleteLocation(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteLocation";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Location type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Location");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"Location",entityDef.getGUID(),entityGuid);
         Location deletedLocation = LocationMapper.mapOmrsEntityDetailToLocation(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedLocation;

    }
    /**
     * Purge an location identified by its GUID. Delete is a hard delete, this means that the location is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the location
     */
    public void purgeLocation(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeLocation";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the Location type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("Location");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"Location",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an Location identified by its GUID. Restore resurrects a soft deleted Location. When a Location was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the Location
     * @return  Location the restored Location
     */
    public Location restoreLocation(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreLocation";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        Location restoredLocation =  LocationMapper.mapOmrsEntityDetailToLocation(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredLocation;
    }    

    /**
     * Add classifications to the supplied location
     * @param userId user identity
     * @param entityGuid the GUID value for location
     * @param classifications the classifications to apply.
     * @return the location entity that has been classified
     */
     public Location addLocationClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addLocationClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         Location locationClassificationBeans = LocationMapper.mapOmrsEntityDetailToLocation(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified Location=" +  locationClassificationBeans);
         }
         return  locationClassificationBeans;
    }

    /**
     * Updates classifications to an existing location represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the location
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given location guid
     */
    public Location updateLocationClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateLocationClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           Location  locationClassificationBeans = LocationMapper.mapOmrsEntityDetailToLocation(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  locationClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing location represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the location
     * @param name name of the classification
     * @return deleted Location  classification
     */
    public Location deleteLocationClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteLocationClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       Location declassifiedLocation =  LocationMapper.mapOmrsEntityDetailToLocation(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedLocation;
    }

    /**
      * Get the relationships associated with entity location represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the location
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getLocationRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getLocationRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
    /**
     * Fetch complete definition of an schemaLinkElement given its GUID.
     * The limit and offset paging parameters limit the number elements returned in each of the schemaLinkElements relationships.
     * @param userId user identity
     * @param entityGuid GUID for the entity
     * @return SchemaLinkElement the SchemaLinkElement entity with the requested GUID
     */
    public SchemaLinkElement getSchemaLinkElement(String userId,String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException
    {
        final String methodName = "getSchemaLinkElement";
        if (log.isDebugEnabled()) {
          log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
            
        SchemaLinkElement gotschemaLinkElement = SchemaLinkElementMapper.mapOmrsEntityDetailToSchemaLinkElement(omrsEntityDetail);
        if (log.isDebugEnabled()) {
         
             log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid+",entity="+ gotschemaLinkElement );
        }
        return gotschemaLinkElement;

    }
    /**
     * Create new schemaLinkElement.
     * @param userId user identity
     * @param schemaLinkElement the input entity with values.
     * @return SchemaLinkElement the created entity.
     */

    public SchemaLinkElement createSchemaLinkElement(String userId,SchemaLinkElement schemaLinkElement)
        throws ClassificationErrorException, StatusNotSupportedException, UserNotAuthorizedException,
           FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException

    {
        final String methodName = "createSchemaLinkElement";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId=" + userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
        EntityDetail entityDetails = SchemaLinkElementMapper.mapSchemaLinkElementToOmrsEntityDetail(schemaLinkElement);
        EntityDetail addedOMRSEntityDetail = oMRSAPIHelper.callOMRSAddEntity(userId,entityDetails);

        SchemaLinkElement createdSchemaLinkElement =  SchemaLinkElementMapper.mapOmrsEntityDetailToSchemaLinkElement(addedOMRSEntityDetail);
        if (log.isDebugEnabled()) {
              log.debug("<== successful method : " + methodName + ",userId="+userId+", created SchemaLinkElement="+ createdSchemaLinkElement );
        }
        return createdSchemaLinkElement;
    }
    /**
     * Update schemaLinkElement
     * @param userId user identity
     * @param schemaLinkElement   schemaLinkElement to update
     * @return SchemaLinkElement the updated schemaLinkElement entity
     */
    public SchemaLinkElement updateSchemaLinkElement(String userId, SchemaLinkElement schemaLinkElement)
              throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException
    {

            final String methodName = "updateSchemaLinkElement";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId=" + userId);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
            EntityDetail entityDetails = SchemaLinkElementMapper.mapSchemaLinkElementToOmrsEntityDetail(schemaLinkElement);
           //InputValidator.validateGUIDNotNull(className,methodName,entityDetails.getGUID(),"guid");
            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSUpdateEntity(userId,entityDetails);

            SchemaLinkElement updatedSchemaLinkElement =  SchemaLinkElementMapper.mapOmrsEntityDetailToSchemaLinkElement(updatedOMRSEntityDetail);
            if (log.isDebugEnabled()) {
                    log.debug("<== successful method: " + methodName + ",userId=" + userId + ",updated SchemaLinkElement="+ updatedSchemaLinkElement );
            }
            return updatedSchemaLinkElement;
        }

    /**
     * Delete an schemaLinkElement identified by its GUID. Delete is a soft delete, this means that the schemaLinkElement has its status changed to
     * deleted. Soft deletion support os optional, so this call may fail. Soft deletes can be undone using the restore call.
     * If it is required that an entity is really deleted (a hard delete) then the purge call should be used.
     *
     * @param userId user identity
     * @param  entityGuid GUID for the schemaLinkElement
     * @return SchemaLinkElement the deleted SchemaLinkElement entity
     */

    public SchemaLinkElement deleteSchemaLinkElement(String userId,final String entityGuid)
       throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException, InvalidParameterException, FunctionNotSupportedException
    {
         final String methodName = "deleteSchemaLinkElement";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the SchemaLinkElement type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("SchemaLinkElement");
         EntityDetail deletedOmrsEntityDetail = oMRSAPIHelper.callOMRSDeleteEntity(userId,"SchemaLinkElement",entityDef.getGUID(),entityGuid);
         SchemaLinkElement deletedSchemaLinkElement = SchemaLinkElementMapper.mapOmrsEntityDetailToSchemaLinkElement(deletedOmrsEntityDetail);

         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
         return deletedSchemaLinkElement;

    }
    /**
     * Purge an schemaLinkElement identified by its GUID. Delete is a hard delete, this means that the schemaLinkElement is really
     * deleted .
     * @param userId user identity
     * @param  entityGuid GUID for the schemaLinkElement
     */
    public void purgeSchemaLinkElement(String userId,final String entityGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, EntityNotKnownException,
       InvalidParameterException, FunctionNotSupportedException,  EntityNotDeletedException
    {
        final String methodName = "purgeSchemaLinkElement";
         if (log.isDebugEnabled()) {
              log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);
        //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

         // get the SchemaLinkElement type guid
         OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
         EntityDef entityDef = archiveAccessor.getEntityDefByName("SchemaLinkElement");
         oMRSAPIHelper.callOMRSPurgeEntity(userId,"SchemaLinkElement",entityDef.getGUID(),entityGuid);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
    }
    /**
     * Restore an SchemaLinkElement identified by its GUID. Restore resurrects a soft deleted SchemaLinkElement. When a SchemaLinkElement was incorrectly deleted, the delete can be undone using the restore..
     * @param userId user identity
     * @param entityGuid GUID for the SchemaLinkElement
     * @return  SchemaLinkElement the restored SchemaLinkElement
     */
    public SchemaLinkElement restoreSchemaLinkElement(String userId,final String entityGuid)
       throws UserNotAuthorizedException, EntityNotKnownException, EntityNotDeletedException, InvalidParameterException, RepositoryErrorException, FunctionNotSupportedException
    {
        final String methodName = "restoreSchemaLinkElement";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");
        EntityDetail omrsEntity =  oMRSAPIHelper.callOMRSRestoreEntity(userId,entityGuid);
        SchemaLinkElement restoredSchemaLinkElement =  SchemaLinkElementMapper.mapOmrsEntityDetailToSchemaLinkElement(omrsEntity);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return restoredSchemaLinkElement;
    }    

    /**
     * Add classifications to the supplied schemaLinkElement
     * @param userId user identity
     * @param entityGuid the GUID value for schemaLinkElement
     * @param classifications the classifications to apply.
     * @return the schemaLinkElement entity that has been classified
     */
     public SchemaLinkElement addSchemaLinkElementClassificationBeans(String userId,final String entityGuid, List<ClassificationBean> classifications)
       throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, PropertyErrorException, EntityProxyOnlyException
     {
        final String methodName = "addSchemaLinkElementClassificationBeans";
         if (log.isDebugEnabled()) {
             log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
         }
        //InputValidator.validateUserIdNotNull(className,methodName,userId);


         for (ClassificationBean classification:classifications) {
             InstanceProperties instanceProperties = classification.obtainInstanceProperties();
             String name =classification.getClassificationName();
            //InputValidator.validateNameNotNull(className,methodName,name,"classifications");
             oMRSAPIHelper.callOMRSClassifyEntity(userId,
                 entityGuid,
                 name,
                 instanceProperties);
         }

         EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

         SchemaLinkElement schemaLinkElementClassificationBeans = SchemaLinkElementMapper.mapOmrsEntityDetailToSchemaLinkElement(omrsEntityDetail);
         if (log.isDebugEnabled()) {
             log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",classified SchemaLinkElement=" +  schemaLinkElementClassificationBeans);
         }
         return  schemaLinkElementClassificationBeans;
    }

    /**
     * Updates classifications to an existing schemaLinkElement represented by a guid.
     * @param userId user identity
     * @param  entityGuid globally unique identifier for the schemaLinkElement
     * @param classificationsToUpdate List of classifications to update entity with
     * @return classification for the given schemaLinkElement guid
     */
    public SchemaLinkElement updateSchemaLinkElementClassificationBean(String userId, final String entityGuid, List<ClassificationBean> classificationsToUpdate)
          throws UserNotAuthorizedException, RepositoryErrorException, EntityProxyOnlyException, InvalidParameterException, EntityNotKnownException,
                ClassificationErrorException, FunctionNotSupportedException, PropertyErrorException
    {
        final String methodName = "updateSchemaLinkElementClassificationBeans";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

            EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);

            List<String> existingClassificationBeanNames = omrsEntityDetail.getClassifications().stream().map(x -> x.getName()).collect(Collectors.toList());
            for (ClassificationBean classification:classificationsToUpdate) {
                 String name = classification.getClassificationName();
                 // Only allow updates of classifications that already exist.
                 if (!existingClassificationBeanNames.contains(name)) {
                    // @TODO ?
                 }
            }
            for (ClassificationBean classification:classificationsToUpdate) {
                 InstanceProperties instanceProperties = classification.obtainInstanceProperties();
                 String name =classification.getClassificationName();
                 //remove existing classification
                 oMRSAPIHelper.callOMRSDeClassifyEntity(userId,
                     entityGuid,
                     name);
                 // re-add with the new properties.
                 oMRSAPIHelper.callOMRSClassifyEntity(userId,
                     entityGuid,
                     name,
                     instanceProperties);
            }

            EntityDetail updatedOMRSEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
           SchemaLinkElement  schemaLinkElementClassificationBeans = SchemaLinkElementMapper.mapOmrsEntityDetailToSchemaLinkElement(updatedOMRSEntityDetail);

            if (log.isDebugEnabled()) {
                   log.debug("<== Method: " + methodName + ",userId="+userId+",guid="+entityGuid);
            }
             return  schemaLinkElementClassificationBeans;
    }

    /**
     * Deletes a given classification from an existing schemaLinkElement represented by a guid.
     * @param userId user identity
     * @param entityGuid  globally unique identifier for the schemaLinkElement
     * @param name name of the classification
     * @return deleted SchemaLinkElement  classification
     */
    public SchemaLinkElement deleteSchemaLinkElementClassificationBean(String userId,String entityGuid, final String name)
          throws ClassificationErrorException, UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException,
                InvalidParameterException, RepositoryErrorException, EntityProxyOnlyException
    {
       final String methodName = "deleteSchemaLinkElementClassificationBean";
       if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
      //InputValidator.validateUserIdNotNull(className,methodName,userId);
      //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");


       oMRSAPIHelper.callOMRSDeClassifyEntity(userId, entityGuid,name);
       EntityDetail omrsEntityDetail = oMRSAPIHelper.callOMRSGetEntityByGuid(userId,entityGuid);
       SchemaLinkElement declassifiedSchemaLinkElement =  SchemaLinkElementMapper.mapOmrsEntityDetailToSchemaLinkElement(omrsEntityDetail);
       if (log.isDebugEnabled()) {
           log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+entityGuid+",name="+name);
       }
       return declassifiedSchemaLinkElement;
    }

    /**
      * Get the relationships associated with entity schemaLinkElement represented by a guid.
      * @param userId user identity
      * @param entityGuid  globally unique identifier for the schemaLinkElement
      * @param relationshipTypeGuid the guid of the relationships type to restrict the relationships returned to this type. null means return all relationships types.
      * @param fromRelationshipElement the starting element number of the relationships to return.
      *                                This is used when retrieving elements
      *                                beyond the first page of results. Zero means start from the first element.
      * @param asOfTime Date return relationships as they were at some time in the past. null indicates to return relationships as they are now.
      * @param sequencingProperty String name of the property that is to be used to sequence the results.
      *                           Null means do not sequence on a property name (see SequencingOrder).
      * @param sequencingOrder Enum defining how the results should be ordered.
      * @param pageSize  the maximum number of result classifications that can be returned on this request.  Zero means
      *                 unrestricted return results size.
      * @return {@code List<Line> }
      */
     public Set<Line> getSchemaLinkElementRelationships(
                        String                     userId,
                        String                     entityGuid,
                        String                     relationshipTypeGuid,
                        int                        fromRelationshipElement,
                        Date                       asOfTime,
                        String                     sequencingProperty,
                        SequencingOrder            sequencingOrder,
                        int                        pageSize)
             throws UserNotAuthorizedException, EntityNotKnownException, FunctionNotSupportedException, InvalidParameterException,
                  RepositoryErrorException, PropertyErrorException, TypeErrorException, PagingErrorException
     {
        final String methodName = "getSchemaLinkElementRelationships";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",entity guid="+entityGuid + ",relationships Type Guid="+relationshipTypeGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,entityGuid,"entityGuid");

        Set<Line> lines = null;

        List<Relationship> omrsRelationships = oMRSAPIHelper.callGetRelationshipsForEntity( userId,
                    entityGuid,
                    relationshipTypeGuid,
                    fromRelationshipElement,
                    asOfTime,
                    sequencingProperty,
                    sequencingOrder,
                    pageSize);
        if (omrsRelationships !=null) {
            lines =  OMRSRelationshipToLines.convert(omrsRelationships);
        }
        if (log.isDebugEnabled()) {
            log.debug("<== successful method : " + methodName + ",userId="+userId+",guid="+entityGuid);
        }
        return lines;
    }
     // Relationships

    /**
      * Create UsedInContext relationships
      * @param userId user identity
      * @param relationships UsedInContext relationships to create
      * @return created UsedInContext relationships
      */
    public UsedInContext createUsedInContextRelationship(String userId,UsedInContext relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createUsedInContextRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = UsedInContextMapper.mapUsedInContextToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        UsedInContext returnedUsedInContext =  UsedInContextMapper.mapOmrsRelationshipToUsedInContext(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedUsedInContext;
    }
    /**
      * Get UsedInContext relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return UsedInContext relationships
      */
    public UsedInContext getUsedInContextRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getUsedInContextRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            UsedInContext gotUsedInContext = UsedInContextMapper.mapOmrsRelationshipToUsedInContext(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotUsedInContext;
      }
    /**
      * Update UsedInContext relationships
      * @param userId user identity
      * @param usedInContext relationships
      * @return  UsedInContext relationships
      */
      public UsedInContext updateUsedInContextRelationship(String userId,UsedInContext usedInContext)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateUsedInContextRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = UsedInContextMapper.mapUsedInContextToOmrsRelationship(usedInContext);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        UsedInContext updatedUsedInContext = UsedInContextMapper.mapOmrsRelationshipToUsedInContext(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedUsedInContext;
    }
    /**
      * Create AttachedComment relationships
      * @param userId user identity
      * @param relationships AttachedComment relationships to create
      * @return created AttachedComment relationships
      */
    public AttachedComment createAttachedCommentRelationship(String userId,AttachedComment relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createAttachedCommentRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = AttachedCommentMapper.mapAttachedCommentToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        AttachedComment returnedAttachedComment =  AttachedCommentMapper.mapOmrsRelationshipToAttachedComment(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedAttachedComment;
    }
    /**
      * Get AttachedComment relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return AttachedComment relationships
      */
    public AttachedComment getAttachedCommentRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getAttachedCommentRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            AttachedComment gotAttachedComment = AttachedCommentMapper.mapOmrsRelationshipToAttachedComment(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotAttachedComment;
      }
    /**
      * Update AttachedComment relationships
      * @param userId user identity
      * @param attachedComment relationships
      * @return  AttachedComment relationships
      */
      public AttachedComment updateAttachedCommentRelationship(String userId,AttachedComment attachedComment)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateAttachedCommentRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = AttachedCommentMapper.mapAttachedCommentToOmrsRelationship(attachedComment);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        AttachedComment updatedAttachedComment = AttachedCommentMapper.mapOmrsRelationshipToAttachedComment(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedAttachedComment;
    }
    /**
      * Create ContactThrough relationships
      * @param userId user identity
      * @param relationships ContactThrough relationships to create
      * @return created ContactThrough relationships
      */
    public ContactThrough createContactThroughRelationship(String userId,ContactThrough relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createContactThroughRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = ContactThroughMapper.mapContactThroughToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        ContactThrough returnedContactThrough =  ContactThroughMapper.mapOmrsRelationshipToContactThrough(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedContactThrough;
    }
    /**
      * Get ContactThrough relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return ContactThrough relationships
      */
    public ContactThrough getContactThroughRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getContactThroughRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            ContactThrough gotContactThrough = ContactThroughMapper.mapOmrsRelationshipToContactThrough(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotContactThrough;
      }
    /**
      * Update ContactThrough relationships
      * @param userId user identity
      * @param contactThrough relationships
      * @return  ContactThrough relationships
      */
      public ContactThrough updateContactThroughRelationship(String userId,ContactThrough contactThrough)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateContactThroughRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = ContactThroughMapper.mapContactThroughToOmrsRelationship(contactThrough);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        ContactThrough updatedContactThrough = ContactThroughMapper.mapOmrsRelationshipToContactThrough(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedContactThrough;
    }
    /**
      * Create License relationships
      * @param userId user identity
      * @param relationships License relationships to create
      * @return created License relationships
      */
    public License createLicenseRelationship(String userId,License relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createLicenseRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = LicenseMapper.mapLicenseToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        License returnedLicense =  LicenseMapper.mapOmrsRelationshipToLicense(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedLicense;
    }
    /**
      * Get License relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return License relationships
      */
    public License getLicenseRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getLicenseRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            License gotLicense = LicenseMapper.mapOmrsRelationshipToLicense(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotLicense;
      }
    /**
      * Update License relationships
      * @param userId user identity
      * @param license relationships
      * @return  License relationships
      */
      public License updateLicenseRelationship(String userId,License license)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateLicenseRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = LicenseMapper.mapLicenseToOmrsRelationship(license);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        License updatedLicense = LicenseMapper.mapOmrsRelationshipToLicense(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedLicense;
    }
    /**
      * Create ZoneGovernance relationships
      * @param userId user identity
      * @param relationships ZoneGovernance relationships to create
      * @return created ZoneGovernance relationships
      */
    public ZoneGovernance createZoneGovernanceRelationship(String userId,ZoneGovernance relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createZoneGovernanceRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = ZoneGovernanceMapper.mapZoneGovernanceToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        ZoneGovernance returnedZoneGovernance =  ZoneGovernanceMapper.mapOmrsRelationshipToZoneGovernance(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedZoneGovernance;
    }
    /**
      * Get ZoneGovernance relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return ZoneGovernance relationships
      */
    public ZoneGovernance getZoneGovernanceRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getZoneGovernanceRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            ZoneGovernance gotZoneGovernance = ZoneGovernanceMapper.mapOmrsRelationshipToZoneGovernance(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotZoneGovernance;
      }
    /**
      * Update ZoneGovernance relationships
      * @param userId user identity
      * @param zoneGovernance relationships
      * @return  ZoneGovernance relationships
      */
      public ZoneGovernance updateZoneGovernanceRelationship(String userId,ZoneGovernance zoneGovernance)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateZoneGovernanceRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = ZoneGovernanceMapper.mapZoneGovernanceToOmrsRelationship(zoneGovernance);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        ZoneGovernance updatedZoneGovernance = ZoneGovernanceMapper.mapOmrsRelationshipToZoneGovernance(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedZoneGovernance;
    }
    /**
      * Create ProcessPort relationships
      * @param userId user identity
      * @param relationships ProcessPort relationships to create
      * @return created ProcessPort relationships
      */
    public ProcessPort createProcessPortRelationship(String userId,ProcessPort relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createProcessPortRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = ProcessPortMapper.mapProcessPortToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        ProcessPort returnedProcessPort =  ProcessPortMapper.mapOmrsRelationshipToProcessPort(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedProcessPort;
    }
    /**
      * Get ProcessPort relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return ProcessPort relationships
      */
    public ProcessPort getProcessPortRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getProcessPortRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            ProcessPort gotProcessPort = ProcessPortMapper.mapOmrsRelationshipToProcessPort(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotProcessPort;
      }
    /**
      * Update ProcessPort relationships
      * @param userId user identity
      * @param processPort relationships
      * @return  ProcessPort relationships
      */
      public ProcessPort updateProcessPortRelationship(String userId,ProcessPort processPort)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateProcessPortRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = ProcessPortMapper.mapProcessPortToOmrsRelationship(processPort);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        ProcessPort updatedProcessPort = ProcessPortMapper.mapOmrsRelationshipToProcessPort(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedProcessPort;
    }
    /**
      * Create DataFieldAnalysis relationships
      * @param userId user identity
      * @param relationships DataFieldAnalysis relationships to create
      * @return created DataFieldAnalysis relationships
      */
    public DataFieldAnalysis createDataFieldAnalysisRelationship(String userId,DataFieldAnalysis relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createDataFieldAnalysisRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = DataFieldAnalysisMapper.mapDataFieldAnalysisToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        DataFieldAnalysis returnedDataFieldAnalysis =  DataFieldAnalysisMapper.mapOmrsRelationshipToDataFieldAnalysis(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedDataFieldAnalysis;
    }
    /**
      * Get DataFieldAnalysis relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return DataFieldAnalysis relationships
      */
    public DataFieldAnalysis getDataFieldAnalysisRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getDataFieldAnalysisRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            DataFieldAnalysis gotDataFieldAnalysis = DataFieldAnalysisMapper.mapOmrsRelationshipToDataFieldAnalysis(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotDataFieldAnalysis;
      }
    /**
      * Update DataFieldAnalysis relationships
      * @param userId user identity
      * @param dataFieldAnalysis relationships
      * @return  DataFieldAnalysis relationships
      */
      public DataFieldAnalysis updateDataFieldAnalysisRelationship(String userId,DataFieldAnalysis dataFieldAnalysis)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateDataFieldAnalysisRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = DataFieldAnalysisMapper.mapDataFieldAnalysisToOmrsRelationship(dataFieldAnalysis);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        DataFieldAnalysis updatedDataFieldAnalysis = DataFieldAnalysisMapper.mapOmrsRelationshipToDataFieldAnalysis(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedDataFieldAnalysis;
    }
    /**
      * Create DiscoveryServiceImplementation relationships
      * @param userId user identity
      * @param relationships DiscoveryServiceImplementation relationships to create
      * @return created DiscoveryServiceImplementation relationships
      */
    public DiscoveryServiceImplementation createDiscoveryServiceImplementationRelationship(String userId,DiscoveryServiceImplementation relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createDiscoveryServiceImplementationRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = DiscoveryServiceImplementationMapper.mapDiscoveryServiceImplementationToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        DiscoveryServiceImplementation returnedDiscoveryServiceImplementation =  DiscoveryServiceImplementationMapper.mapOmrsRelationshipToDiscoveryServiceImplementation(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedDiscoveryServiceImplementation;
    }
    /**
      * Get DiscoveryServiceImplementation relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return DiscoveryServiceImplementation relationships
      */
    public DiscoveryServiceImplementation getDiscoveryServiceImplementationRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getDiscoveryServiceImplementationRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            DiscoveryServiceImplementation gotDiscoveryServiceImplementation = DiscoveryServiceImplementationMapper.mapOmrsRelationshipToDiscoveryServiceImplementation(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotDiscoveryServiceImplementation;
      }
    /**
      * Update DiscoveryServiceImplementation relationships
      * @param userId user identity
      * @param discoveryServiceImplementation relationships
      * @return  DiscoveryServiceImplementation relationships
      */
      public DiscoveryServiceImplementation updateDiscoveryServiceImplementationRelationship(String userId,DiscoveryServiceImplementation discoveryServiceImplementation)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateDiscoveryServiceImplementationRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = DiscoveryServiceImplementationMapper.mapDiscoveryServiceImplementationToOmrsRelationship(discoveryServiceImplementation);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        DiscoveryServiceImplementation updatedDiscoveryServiceImplementation = DiscoveryServiceImplementationMapper.mapOmrsRelationshipToDiscoveryServiceImplementation(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedDiscoveryServiceImplementation;
    }
    /**
      * Create SoftwareServerPlatformDeployment relationships
      * @param userId user identity
      * @param relationships SoftwareServerPlatformDeployment relationships to create
      * @return created SoftwareServerPlatformDeployment relationships
      */
    public SoftwareServerPlatformDeployment createSoftwareServerPlatformDeploymentRelationship(String userId,SoftwareServerPlatformDeployment relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createSoftwareServerPlatformDeploymentRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = SoftwareServerPlatformDeploymentMapper.mapSoftwareServerPlatformDeploymentToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        SoftwareServerPlatformDeployment returnedSoftwareServerPlatformDeployment =  SoftwareServerPlatformDeploymentMapper.mapOmrsRelationshipToSoftwareServerPlatformDeployment(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedSoftwareServerPlatformDeployment;
    }
    /**
      * Get SoftwareServerPlatformDeployment relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return SoftwareServerPlatformDeployment relationships
      */
    public SoftwareServerPlatformDeployment getSoftwareServerPlatformDeploymentRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getSoftwareServerPlatformDeploymentRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            SoftwareServerPlatformDeployment gotSoftwareServerPlatformDeployment = SoftwareServerPlatformDeploymentMapper.mapOmrsRelationshipToSoftwareServerPlatformDeployment(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotSoftwareServerPlatformDeployment;
      }
    /**
      * Update SoftwareServerPlatformDeployment relationships
      * @param userId user identity
      * @param softwareServerPlatformDeployment relationships
      * @return  SoftwareServerPlatformDeployment relationships
      */
      public SoftwareServerPlatformDeployment updateSoftwareServerPlatformDeploymentRelationship(String userId,SoftwareServerPlatformDeployment softwareServerPlatformDeployment)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateSoftwareServerPlatformDeploymentRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = SoftwareServerPlatformDeploymentMapper.mapSoftwareServerPlatformDeploymentToOmrsRelationship(softwareServerPlatformDeployment);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        SoftwareServerPlatformDeployment updatedSoftwareServerPlatformDeployment = SoftwareServerPlatformDeploymentMapper.mapOmrsRelationshipToSoftwareServerPlatformDeployment(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedSoftwareServerPlatformDeployment;
    }
    /**
      * Create FolderHierarchy relationships
      * @param userId user identity
      * @param relationships FolderHierarchy relationships to create
      * @return created FolderHierarchy relationships
      */
    public FolderHierarchy createFolderHierarchyRelationship(String userId,FolderHierarchy relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createFolderHierarchyRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = FolderHierarchyMapper.mapFolderHierarchyToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        FolderHierarchy returnedFolderHierarchy =  FolderHierarchyMapper.mapOmrsRelationshipToFolderHierarchy(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedFolderHierarchy;
    }
    /**
      * Get FolderHierarchy relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return FolderHierarchy relationships
      */
    public FolderHierarchy getFolderHierarchyRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getFolderHierarchyRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            FolderHierarchy gotFolderHierarchy = FolderHierarchyMapper.mapOmrsRelationshipToFolderHierarchy(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotFolderHierarchy;
      }
    /**
      * Update FolderHierarchy relationships
      * @param userId user identity
      * @param folderHierarchy relationships
      * @return  FolderHierarchy relationships
      */
      public FolderHierarchy updateFolderHierarchyRelationship(String userId,FolderHierarchy folderHierarchy)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateFolderHierarchyRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = FolderHierarchyMapper.mapFolderHierarchyToOmrsRelationship(folderHierarchy);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        FolderHierarchy updatedFolderHierarchy = FolderHierarchyMapper.mapOmrsRelationshipToFolderHierarchy(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedFolderHierarchy;
    }
    /**
      * Create HostClusterMember relationships
      * @param userId user identity
      * @param relationships HostClusterMember relationships to create
      * @return created HostClusterMember relationships
      */
    public HostClusterMember createHostClusterMemberRelationship(String userId,HostClusterMember relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createHostClusterMemberRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = HostClusterMemberMapper.mapHostClusterMemberToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        HostClusterMember returnedHostClusterMember =  HostClusterMemberMapper.mapOmrsRelationshipToHostClusterMember(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedHostClusterMember;
    }
    /**
      * Get HostClusterMember relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return HostClusterMember relationships
      */
    public HostClusterMember getHostClusterMemberRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getHostClusterMemberRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            HostClusterMember gotHostClusterMember = HostClusterMemberMapper.mapOmrsRelationshipToHostClusterMember(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotHostClusterMember;
      }
    /**
      * Update HostClusterMember relationships
      * @param userId user identity
      * @param hostClusterMember relationships
      * @return  HostClusterMember relationships
      */
      public HostClusterMember updateHostClusterMemberRelationship(String userId,HostClusterMember hostClusterMember)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateHostClusterMemberRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = HostClusterMemberMapper.mapHostClusterMemberToOmrsRelationship(hostClusterMember);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        HostClusterMember updatedHostClusterMember = HostClusterMemberMapper.mapOmrsRelationshipToHostClusterMember(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedHostClusterMember;
    }
    /**
      * Create AnnotationReviewLink relationships
      * @param userId user identity
      * @param relationships AnnotationReviewLink relationships to create
      * @return created AnnotationReviewLink relationships
      */
    public AnnotationReviewLink createAnnotationReviewLinkRelationship(String userId,AnnotationReviewLink relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createAnnotationReviewLinkRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = AnnotationReviewLinkMapper.mapAnnotationReviewLinkToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        AnnotationReviewLink returnedAnnotationReviewLink =  AnnotationReviewLinkMapper.mapOmrsRelationshipToAnnotationReviewLink(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedAnnotationReviewLink;
    }
    /**
      * Get AnnotationReviewLink relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return AnnotationReviewLink relationships
      */
    public AnnotationReviewLink getAnnotationReviewLinkRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getAnnotationReviewLinkRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            AnnotationReviewLink gotAnnotationReviewLink = AnnotationReviewLinkMapper.mapOmrsRelationshipToAnnotationReviewLink(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotAnnotationReviewLink;
      }
    /**
      * Update AnnotationReviewLink relationships
      * @param userId user identity
      * @param annotationReviewLink relationships
      * @return  AnnotationReviewLink relationships
      */
      public AnnotationReviewLink updateAnnotationReviewLinkRelationship(String userId,AnnotationReviewLink annotationReviewLink)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateAnnotationReviewLinkRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = AnnotationReviewLinkMapper.mapAnnotationReviewLinkToOmrsRelationship(annotationReviewLink);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        AnnotationReviewLink updatedAnnotationReviewLink = AnnotationReviewLinkMapper.mapOmrsRelationshipToAnnotationReviewLink(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedAnnotationReviewLink;
    }
    /**
      * Create LibraryCategoryReference relationships
      * @param userId user identity
      * @param relationships LibraryCategoryReference relationships to create
      * @return created LibraryCategoryReference relationships
      */
    public LibraryCategoryReference createLibraryCategoryReferenceRelationship(String userId,LibraryCategoryReference relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createLibraryCategoryReferenceRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = LibraryCategoryReferenceMapper.mapLibraryCategoryReferenceToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        LibraryCategoryReference returnedLibraryCategoryReference =  LibraryCategoryReferenceMapper.mapOmrsRelationshipToLibraryCategoryReference(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedLibraryCategoryReference;
    }
    /**
      * Get LibraryCategoryReference relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return LibraryCategoryReference relationships
      */
    public LibraryCategoryReference getLibraryCategoryReferenceRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getLibraryCategoryReferenceRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            LibraryCategoryReference gotLibraryCategoryReference = LibraryCategoryReferenceMapper.mapOmrsRelationshipToLibraryCategoryReference(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotLibraryCategoryReference;
      }
    /**
      * Update LibraryCategoryReference relationships
      * @param userId user identity
      * @param libraryCategoryReference relationships
      * @return  LibraryCategoryReference relationships
      */
      public LibraryCategoryReference updateLibraryCategoryReferenceRelationship(String userId,LibraryCategoryReference libraryCategoryReference)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateLibraryCategoryReferenceRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = LibraryCategoryReferenceMapper.mapLibraryCategoryReferenceToOmrsRelationship(libraryCategoryReference);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        LibraryCategoryReference updatedLibraryCategoryReference = LibraryCategoryReferenceMapper.mapOmrsRelationshipToLibraryCategoryReference(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedLibraryCategoryReference;
    }
    /**
      * Create ProjectCharterLink relationships
      * @param userId user identity
      * @param relationships ProjectCharterLink relationships to create
      * @return created ProjectCharterLink relationships
      */
    public ProjectCharterLink createProjectCharterLinkRelationship(String userId,ProjectCharterLink relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createProjectCharterLinkRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = ProjectCharterLinkMapper.mapProjectCharterLinkToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        ProjectCharterLink returnedProjectCharterLink =  ProjectCharterLinkMapper.mapOmrsRelationshipToProjectCharterLink(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedProjectCharterLink;
    }
    /**
      * Get ProjectCharterLink relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return ProjectCharterLink relationships
      */
    public ProjectCharterLink getProjectCharterLinkRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getProjectCharterLinkRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            ProjectCharterLink gotProjectCharterLink = ProjectCharterLinkMapper.mapOmrsRelationshipToProjectCharterLink(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotProjectCharterLink;
      }
    /**
      * Update ProjectCharterLink relationships
      * @param userId user identity
      * @param projectCharterLink relationships
      * @return  ProjectCharterLink relationships
      */
      public ProjectCharterLink updateProjectCharterLinkRelationship(String userId,ProjectCharterLink projectCharterLink)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateProjectCharterLinkRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = ProjectCharterLinkMapper.mapProjectCharterLinkToOmrsRelationship(projectCharterLink);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        ProjectCharterLink updatedProjectCharterLink = ProjectCharterLinkMapper.mapOmrsRelationshipToProjectCharterLink(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedProjectCharterLink;
    }
    /**
      * Create ProfileIdentity relationships
      * @param userId user identity
      * @param relationships ProfileIdentity relationships to create
      * @return created ProfileIdentity relationships
      */
    public ProfileIdentity createProfileIdentityRelationship(String userId,ProfileIdentity relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createProfileIdentityRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = ProfileIdentityMapper.mapProfileIdentityToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        ProfileIdentity returnedProfileIdentity =  ProfileIdentityMapper.mapOmrsRelationshipToProfileIdentity(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedProfileIdentity;
    }
    /**
      * Get ProfileIdentity relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return ProfileIdentity relationships
      */
    public ProfileIdentity getProfileIdentityRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getProfileIdentityRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            ProfileIdentity gotProfileIdentity = ProfileIdentityMapper.mapOmrsRelationshipToProfileIdentity(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotProfileIdentity;
      }
    /**
      * Update ProfileIdentity relationships
      * @param userId user identity
      * @param profileIdentity relationships
      * @return  ProfileIdentity relationships
      */
      public ProfileIdentity updateProfileIdentityRelationship(String userId,ProfileIdentity profileIdentity)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateProfileIdentityRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = ProfileIdentityMapper.mapProfileIdentityToOmrsRelationship(profileIdentity);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        ProfileIdentity updatedProfileIdentity = ProfileIdentityMapper.mapOmrsRelationshipToProfileIdentity(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedProfileIdentity;
    }
    /**
      * Create ToDoSource relationships
      * @param userId user identity
      * @param relationships ToDoSource relationships to create
      * @return created ToDoSource relationships
      */
    public ToDoSource createToDoSourceRelationship(String userId,ToDoSource relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createToDoSourceRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = ToDoSourceMapper.mapToDoSourceToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        ToDoSource returnedToDoSource =  ToDoSourceMapper.mapOmrsRelationshipToToDoSource(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedToDoSource;
    }
    /**
      * Get ToDoSource relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return ToDoSource relationships
      */
    public ToDoSource getToDoSourceRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getToDoSourceRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            ToDoSource gotToDoSource = ToDoSourceMapper.mapOmrsRelationshipToToDoSource(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotToDoSource;
      }
    /**
      * Update ToDoSource relationships
      * @param userId user identity
      * @param toDoSource relationships
      * @return  ToDoSource relationships
      */
      public ToDoSource updateToDoSourceRelationship(String userId,ToDoSource toDoSource)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateToDoSourceRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = ToDoSourceMapper.mapToDoSourceToOmrsRelationship(toDoSource);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        ToDoSource updatedToDoSource = ToDoSourceMapper.mapOmrsRelationshipToToDoSource(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedToDoSource;
    }
    /**
      * Create DataClassComposition relationships
      * @param userId user identity
      * @param relationships DataClassComposition relationships to create
      * @return created DataClassComposition relationships
      */
    public DataClassComposition createDataClassCompositionRelationship(String userId,DataClassComposition relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createDataClassCompositionRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = DataClassCompositionMapper.mapDataClassCompositionToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        DataClassComposition returnedDataClassComposition =  DataClassCompositionMapper.mapOmrsRelationshipToDataClassComposition(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedDataClassComposition;
    }
    /**
      * Get DataClassComposition relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return DataClassComposition relationships
      */
    public DataClassComposition getDataClassCompositionRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getDataClassCompositionRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            DataClassComposition gotDataClassComposition = DataClassCompositionMapper.mapOmrsRelationshipToDataClassComposition(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotDataClassComposition;
      }
    /**
      * Update DataClassComposition relationships
      * @param userId user identity
      * @param dataClassComposition relationships
      * @return  DataClassComposition relationships
      */
      public DataClassComposition updateDataClassCompositionRelationship(String userId,DataClassComposition dataClassComposition)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateDataClassCompositionRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = DataClassCompositionMapper.mapDataClassCompositionToOmrsRelationship(dataClassComposition);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        DataClassComposition updatedDataClassComposition = DataClassCompositionMapper.mapOmrsRelationshipToDataClassComposition(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedDataClassComposition;
    }
    /**
      * Create Translation relationships
      * @param userId user identity
      * @param relationships Translation relationships to create
      * @return created Translation relationships
      */
    public Translation createTranslationRelationship(String userId,Translation relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createTranslationRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = TranslationMapper.mapTranslationToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        Translation returnedTranslation =  TranslationMapper.mapOmrsRelationshipToTranslation(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedTranslation;
    }
    /**
      * Get Translation relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return Translation relationships
      */
    public Translation getTranslationRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getTranslationRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            Translation gotTranslation = TranslationMapper.mapOmrsRelationshipToTranslation(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotTranslation;
      }
    /**
      * Update Translation relationships
      * @param userId user identity
      * @param translation relationships
      * @return  Translation relationships
      */
      public Translation updateTranslationRelationship(String userId,Translation translation)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateTranslationRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = TranslationMapper.mapTranslationToOmrsRelationship(translation);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        Translation updatedTranslation = TranslationMapper.mapOmrsRelationshipToTranslation(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedTranslation;
    }
    /**
      * Create SchemaLinkToType relationships
      * @param userId user identity
      * @param relationships SchemaLinkToType relationships to create
      * @return created SchemaLinkToType relationships
      */
    public SchemaLinkToType createSchemaLinkToTypeRelationship(String userId,SchemaLinkToType relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createSchemaLinkToTypeRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = SchemaLinkToTypeMapper.mapSchemaLinkToTypeToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        SchemaLinkToType returnedSchemaLinkToType =  SchemaLinkToTypeMapper.mapOmrsRelationshipToSchemaLinkToType(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedSchemaLinkToType;
    }
    /**
      * Get SchemaLinkToType relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return SchemaLinkToType relationships
      */
    public SchemaLinkToType getSchemaLinkToTypeRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getSchemaLinkToTypeRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            SchemaLinkToType gotSchemaLinkToType = SchemaLinkToTypeMapper.mapOmrsRelationshipToSchemaLinkToType(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotSchemaLinkToType;
      }
    /**
      * Update SchemaLinkToType relationships
      * @param userId user identity
      * @param schemaLinkToType relationships
      * @return  SchemaLinkToType relationships
      */
      public SchemaLinkToType updateSchemaLinkToTypeRelationship(String userId,SchemaLinkToType schemaLinkToType)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateSchemaLinkToTypeRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = SchemaLinkToTypeMapper.mapSchemaLinkToTypeToOmrsRelationship(schemaLinkToType);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        SchemaLinkToType updatedSchemaLinkToType = SchemaLinkToTypeMapper.mapOmrsRelationshipToSchemaLinkToType(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedSchemaLinkToType;
    }
    /**
      * Create DiscoveredNestedDataField relationships
      * @param userId user identity
      * @param relationships DiscoveredNestedDataField relationships to create
      * @return created DiscoveredNestedDataField relationships
      */
    public DiscoveredNestedDataField createDiscoveredNestedDataFieldRelationship(String userId,DiscoveredNestedDataField relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createDiscoveredNestedDataFieldRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = DiscoveredNestedDataFieldMapper.mapDiscoveredNestedDataFieldToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        DiscoveredNestedDataField returnedDiscoveredNestedDataField =  DiscoveredNestedDataFieldMapper.mapOmrsRelationshipToDiscoveredNestedDataField(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedDiscoveredNestedDataField;
    }
    /**
      * Get DiscoveredNestedDataField relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return DiscoveredNestedDataField relationships
      */
    public DiscoveredNestedDataField getDiscoveredNestedDataFieldRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getDiscoveredNestedDataFieldRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            DiscoveredNestedDataField gotDiscoveredNestedDataField = DiscoveredNestedDataFieldMapper.mapOmrsRelationshipToDiscoveredNestedDataField(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotDiscoveredNestedDataField;
      }
    /**
      * Update DiscoveredNestedDataField relationships
      * @param userId user identity
      * @param discoveredNestedDataField relationships
      * @return  DiscoveredNestedDataField relationships
      */
      public DiscoveredNestedDataField updateDiscoveredNestedDataFieldRelationship(String userId,DiscoveredNestedDataField discoveredNestedDataField)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateDiscoveredNestedDataFieldRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = DiscoveredNestedDataFieldMapper.mapDiscoveredNestedDataFieldToOmrsRelationship(discoveredNestedDataField);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        DiscoveredNestedDataField updatedDiscoveredNestedDataField = DiscoveredNestedDataFieldMapper.mapOmrsRelationshipToDiscoveredNestedDataField(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedDiscoveredNestedDataField;
    }
    /**
      * Create TeamMembership relationships
      * @param userId user identity
      * @param relationships TeamMembership relationships to create
      * @return created TeamMembership relationships
      */
    public TeamMembership createTeamMembershipRelationship(String userId,TeamMembership relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createTeamMembershipRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = TeamMembershipMapper.mapTeamMembershipToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        TeamMembership returnedTeamMembership =  TeamMembershipMapper.mapOmrsRelationshipToTeamMembership(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedTeamMembership;
    }
    /**
      * Get TeamMembership relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return TeamMembership relationships
      */
    public TeamMembership getTeamMembershipRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getTeamMembershipRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            TeamMembership gotTeamMembership = TeamMembershipMapper.mapOmrsRelationshipToTeamMembership(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotTeamMembership;
      }
    /**
      * Update TeamMembership relationships
      * @param userId user identity
      * @param teamMembership relationships
      * @return  TeamMembership relationships
      */
      public TeamMembership updateTeamMembershipRelationship(String userId,TeamMembership teamMembership)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateTeamMembershipRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = TeamMembershipMapper.mapTeamMembershipToOmrsRelationship(teamMembership);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        TeamMembership updatedTeamMembership = TeamMembershipMapper.mapOmrsRelationshipToTeamMembership(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedTeamMembership;
    }
    /**
      * Create Actions relationships
      * @param userId user identity
      * @param relationships Actions relationships to create
      * @return created Actions relationships
      */
    public Actions createActionsRelationship(String userId,Actions relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createActionsRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = ActionsMapper.mapActionsToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        Actions returnedActions =  ActionsMapper.mapOmrsRelationshipToActions(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedActions;
    }
    /**
      * Get Actions relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return Actions relationships
      */
    public Actions getActionsRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getActionsRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            Actions gotActions = ActionsMapper.mapOmrsRelationshipToActions(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotActions;
      }
    /**
      * Update Actions relationships
      * @param userId user identity
      * @param actions relationships
      * @return  Actions relationships
      */
      public Actions updateActionsRelationship(String userId,Actions actions)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateActionsRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = ActionsMapper.mapActionsToOmrsRelationship(actions);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        Actions updatedActions = ActionsMapper.mapOmrsRelationshipToActions(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedActions;
    }
    /**
      * Create PersonalContribution relationships
      * @param userId user identity
      * @param relationships PersonalContribution relationships to create
      * @return created PersonalContribution relationships
      */
    public PersonalContribution createPersonalContributionRelationship(String userId,PersonalContribution relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createPersonalContributionRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = PersonalContributionMapper.mapPersonalContributionToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        PersonalContribution returnedPersonalContribution =  PersonalContributionMapper.mapOmrsRelationshipToPersonalContribution(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedPersonalContribution;
    }
    /**
      * Get PersonalContribution relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return PersonalContribution relationships
      */
    public PersonalContribution getPersonalContributionRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getPersonalContributionRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            PersonalContribution gotPersonalContribution = PersonalContributionMapper.mapOmrsRelationshipToPersonalContribution(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotPersonalContribution;
      }
    /**
      * Update PersonalContribution relationships
      * @param userId user identity
      * @param personalContribution relationships
      * @return  PersonalContribution relationships
      */
      public PersonalContribution updatePersonalContributionRelationship(String userId,PersonalContribution personalContribution)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updatePersonalContributionRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = PersonalContributionMapper.mapPersonalContributionToOmrsRelationship(personalContribution);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        PersonalContribution updatedPersonalContribution = PersonalContributionMapper.mapOmrsRelationshipToPersonalContribution(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedPersonalContribution;
    }
    /**
      * Create DataContentForDataSet relationships
      * @param userId user identity
      * @param relationships DataContentForDataSet relationships to create
      * @return created DataContentForDataSet relationships
      */
    public DataContentForDataSet createDataContentForDataSetRelationship(String userId,DataContentForDataSet relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createDataContentForDataSetRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = DataContentForDataSetMapper.mapDataContentForDataSetToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        DataContentForDataSet returnedDataContentForDataSet =  DataContentForDataSetMapper.mapOmrsRelationshipToDataContentForDataSet(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedDataContentForDataSet;
    }
    /**
      * Get DataContentForDataSet relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return DataContentForDataSet relationships
      */
    public DataContentForDataSet getDataContentForDataSetRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getDataContentForDataSetRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            DataContentForDataSet gotDataContentForDataSet = DataContentForDataSetMapper.mapOmrsRelationshipToDataContentForDataSet(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotDataContentForDataSet;
      }
    /**
      * Update DataContentForDataSet relationships
      * @param userId user identity
      * @param dataContentForDataSet relationships
      * @return  DataContentForDataSet relationships
      */
      public DataContentForDataSet updateDataContentForDataSetRelationship(String userId,DataContentForDataSet dataContentForDataSet)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateDataContentForDataSetRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = DataContentForDataSetMapper.mapDataContentForDataSetToOmrsRelationship(dataContentForDataSet);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        DataContentForDataSet updatedDataContentForDataSet = DataContentForDataSetMapper.mapOmrsRelationshipToDataContentForDataSet(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedDataContentForDataSet;
    }
    /**
      * Create TeamLeadership relationships
      * @param userId user identity
      * @param relationships TeamLeadership relationships to create
      * @return created TeamLeadership relationships
      */
    public TeamLeadership createTeamLeadershipRelationship(String userId,TeamLeadership relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createTeamLeadershipRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = TeamLeadershipMapper.mapTeamLeadershipToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        TeamLeadership returnedTeamLeadership =  TeamLeadershipMapper.mapOmrsRelationshipToTeamLeadership(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedTeamLeadership;
    }
    /**
      * Get TeamLeadership relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return TeamLeadership relationships
      */
    public TeamLeadership getTeamLeadershipRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getTeamLeadershipRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            TeamLeadership gotTeamLeadership = TeamLeadershipMapper.mapOmrsRelationshipToTeamLeadership(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotTeamLeadership;
      }
    /**
      * Update TeamLeadership relationships
      * @param userId user identity
      * @param teamLeadership relationships
      * @return  TeamLeadership relationships
      */
      public TeamLeadership updateTeamLeadershipRelationship(String userId,TeamLeadership teamLeadership)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateTeamLeadershipRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = TeamLeadershipMapper.mapTeamLeadershipToOmrsRelationship(teamLeadership);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        TeamLeadership updatedTeamLeadership = TeamLeadershipMapper.mapOmrsRelationshipToTeamLeadership(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedTeamLeadership;
    }
    /**
      * Create BusinessCapabilityControls relationships
      * @param userId user identity
      * @param relationships BusinessCapabilityControls relationships to create
      * @return created BusinessCapabilityControls relationships
      */
    public BusinessCapabilityControls createBusinessCapabilityControlsRelationship(String userId,BusinessCapabilityControls relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createBusinessCapabilityControlsRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = BusinessCapabilityControlsMapper.mapBusinessCapabilityControlsToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        BusinessCapabilityControls returnedBusinessCapabilityControls =  BusinessCapabilityControlsMapper.mapOmrsRelationshipToBusinessCapabilityControls(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedBusinessCapabilityControls;
    }
    /**
      * Get BusinessCapabilityControls relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return BusinessCapabilityControls relationships
      */
    public BusinessCapabilityControls getBusinessCapabilityControlsRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getBusinessCapabilityControlsRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            BusinessCapabilityControls gotBusinessCapabilityControls = BusinessCapabilityControlsMapper.mapOmrsRelationshipToBusinessCapabilityControls(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotBusinessCapabilityControls;
      }
    /**
      * Update BusinessCapabilityControls relationships
      * @param userId user identity
      * @param businessCapabilityControls relationships
      * @return  BusinessCapabilityControls relationships
      */
      public BusinessCapabilityControls updateBusinessCapabilityControlsRelationship(String userId,BusinessCapabilityControls businessCapabilityControls)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateBusinessCapabilityControlsRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = BusinessCapabilityControlsMapper.mapBusinessCapabilityControlsToOmrsRelationship(businessCapabilityControls);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        BusinessCapabilityControls updatedBusinessCapabilityControls = BusinessCapabilityControlsMapper.mapOmrsRelationshipToBusinessCapabilityControls(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedBusinessCapabilityControls;
    }
    /**
      * Create ServerEndpoint relationships
      * @param userId user identity
      * @param relationships ServerEndpoint relationships to create
      * @return created ServerEndpoint relationships
      */
    public ServerEndpoint createServerEndpointRelationship(String userId,ServerEndpoint relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createServerEndpointRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = ServerEndpointMapper.mapServerEndpointToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        ServerEndpoint returnedServerEndpoint =  ServerEndpointMapper.mapOmrsRelationshipToServerEndpoint(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedServerEndpoint;
    }
    /**
      * Get ServerEndpoint relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return ServerEndpoint relationships
      */
    public ServerEndpoint getServerEndpointRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getServerEndpointRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            ServerEndpoint gotServerEndpoint = ServerEndpointMapper.mapOmrsRelationshipToServerEndpoint(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotServerEndpoint;
      }
    /**
      * Update ServerEndpoint relationships
      * @param userId user identity
      * @param serverEndpoint relationships
      * @return  ServerEndpoint relationships
      */
      public ServerEndpoint updateServerEndpointRelationship(String userId,ServerEndpoint serverEndpoint)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateServerEndpointRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = ServerEndpointMapper.mapServerEndpointToOmrsRelationship(serverEndpoint);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        ServerEndpoint updatedServerEndpoint = ServerEndpointMapper.mapOmrsRelationshipToServerEndpoint(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedServerEndpoint;
    }
    /**
      * Create DiscoveryInvocationReport relationships
      * @param userId user identity
      * @param relationships DiscoveryInvocationReport relationships to create
      * @return created DiscoveryInvocationReport relationships
      */
    public DiscoveryInvocationReport createDiscoveryInvocationReportRelationship(String userId,DiscoveryInvocationReport relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createDiscoveryInvocationReportRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = DiscoveryInvocationReportMapper.mapDiscoveryInvocationReportToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        DiscoveryInvocationReport returnedDiscoveryInvocationReport =  DiscoveryInvocationReportMapper.mapOmrsRelationshipToDiscoveryInvocationReport(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedDiscoveryInvocationReport;
    }
    /**
      * Get DiscoveryInvocationReport relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return DiscoveryInvocationReport relationships
      */
    public DiscoveryInvocationReport getDiscoveryInvocationReportRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getDiscoveryInvocationReportRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            DiscoveryInvocationReport gotDiscoveryInvocationReport = DiscoveryInvocationReportMapper.mapOmrsRelationshipToDiscoveryInvocationReport(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotDiscoveryInvocationReport;
      }
    /**
      * Update DiscoveryInvocationReport relationships
      * @param userId user identity
      * @param discoveryInvocationReport relationships
      * @return  DiscoveryInvocationReport relationships
      */
      public DiscoveryInvocationReport updateDiscoveryInvocationReportRelationship(String userId,DiscoveryInvocationReport discoveryInvocationReport)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateDiscoveryInvocationReportRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = DiscoveryInvocationReportMapper.mapDiscoveryInvocationReportToOmrsRelationship(discoveryInvocationReport);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        DiscoveryInvocationReport updatedDiscoveryInvocationReport = DiscoveryInvocationReportMapper.mapOmrsRelationshipToDiscoveryInvocationReport(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedDiscoveryInvocationReport;
    }
    /**
      * Create ExternalIdLink relationships
      * @param userId user identity
      * @param relationships ExternalIdLink relationships to create
      * @return created ExternalIdLink relationships
      */
    public ExternalIdLink createExternalIdLinkRelationship(String userId,ExternalIdLink relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createExternalIdLinkRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = ExternalIdLinkMapper.mapExternalIdLinkToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        ExternalIdLink returnedExternalIdLink =  ExternalIdLinkMapper.mapOmrsRelationshipToExternalIdLink(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedExternalIdLink;
    }
    /**
      * Get ExternalIdLink relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return ExternalIdLink relationships
      */
    public ExternalIdLink getExternalIdLinkRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getExternalIdLinkRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            ExternalIdLink gotExternalIdLink = ExternalIdLinkMapper.mapOmrsRelationshipToExternalIdLink(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotExternalIdLink;
      }
    /**
      * Update ExternalIdLink relationships
      * @param userId user identity
      * @param externalIdLink relationships
      * @return  ExternalIdLink relationships
      */
      public ExternalIdLink updateExternalIdLinkRelationship(String userId,ExternalIdLink externalIdLink)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateExternalIdLinkRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = ExternalIdLinkMapper.mapExternalIdLinkToOmrsRelationship(externalIdLink);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        ExternalIdLink updatedExternalIdLink = ExternalIdLinkMapper.mapOmrsRelationshipToExternalIdLink(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedExternalIdLink;
    }
    /**
      * Create ResourceList relationships
      * @param userId user identity
      * @param relationships ResourceList relationships to create
      * @return created ResourceList relationships
      */
    public ResourceList createResourceListRelationship(String userId,ResourceList relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createResourceListRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = ResourceListMapper.mapResourceListToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        ResourceList returnedResourceList =  ResourceListMapper.mapOmrsRelationshipToResourceList(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedResourceList;
    }
    /**
      * Get ResourceList relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return ResourceList relationships
      */
    public ResourceList getResourceListRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getResourceListRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            ResourceList gotResourceList = ResourceListMapper.mapOmrsRelationshipToResourceList(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotResourceList;
      }
    /**
      * Update ResourceList relationships
      * @param userId user identity
      * @param resourceList relationships
      * @return  ResourceList relationships
      */
      public ResourceList updateResourceListRelationship(String userId,ResourceList resourceList)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateResourceListRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = ResourceListMapper.mapResourceListToOmrsRelationship(resourceList);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        ResourceList updatedResourceList = ResourceListMapper.mapOmrsRelationshipToResourceList(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedResourceList;
    }
    /**
      * Create CategoryHierarchyLink relationships
      * @param userId user identity
      * @param relationships CategoryHierarchyLink relationships to create
      * @return created CategoryHierarchyLink relationships
      */
    public CategoryHierarchyLink createCategoryHierarchyLinkRelationship(String userId,CategoryHierarchyLink relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createCategoryHierarchyLinkRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = CategoryHierarchyLinkMapper.mapCategoryHierarchyLinkToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        CategoryHierarchyLink returnedCategoryHierarchyLink =  CategoryHierarchyLinkMapper.mapOmrsRelationshipToCategoryHierarchyLink(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedCategoryHierarchyLink;
    }
    /**
      * Get CategoryHierarchyLink relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return CategoryHierarchyLink relationships
      */
    public CategoryHierarchyLink getCategoryHierarchyLinkRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getCategoryHierarchyLinkRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            CategoryHierarchyLink gotCategoryHierarchyLink = CategoryHierarchyLinkMapper.mapOmrsRelationshipToCategoryHierarchyLink(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotCategoryHierarchyLink;
      }
    /**
      * Update CategoryHierarchyLink relationships
      * @param userId user identity
      * @param categoryHierarchyLink relationships
      * @return  CategoryHierarchyLink relationships
      */
      public CategoryHierarchyLink updateCategoryHierarchyLinkRelationship(String userId,CategoryHierarchyLink categoryHierarchyLink)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateCategoryHierarchyLinkRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = CategoryHierarchyLinkMapper.mapCategoryHierarchyLinkToOmrsRelationship(categoryHierarchyLink);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        CategoryHierarchyLink updatedCategoryHierarchyLink = CategoryHierarchyLinkMapper.mapOmrsRelationshipToCategoryHierarchyLink(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedCategoryHierarchyLink;
    }
    /**
      * Create PreferredTerm relationships
      * @param userId user identity
      * @param relationships PreferredTerm relationships to create
      * @return created PreferredTerm relationships
      */
    public PreferredTerm createPreferredTermRelationship(String userId,PreferredTerm relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createPreferredTermRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = PreferredTermMapper.mapPreferredTermToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        PreferredTerm returnedPreferredTerm =  PreferredTermMapper.mapOmrsRelationshipToPreferredTerm(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedPreferredTerm;
    }
    /**
      * Get PreferredTerm relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return PreferredTerm relationships
      */
    public PreferredTerm getPreferredTermRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getPreferredTermRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            PreferredTerm gotPreferredTerm = PreferredTermMapper.mapOmrsRelationshipToPreferredTerm(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotPreferredTerm;
      }
    /**
      * Update PreferredTerm relationships
      * @param userId user identity
      * @param preferredTerm relationships
      * @return  PreferredTerm relationships
      */
      public PreferredTerm updatePreferredTermRelationship(String userId,PreferredTerm preferredTerm)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updatePreferredTermRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = PreferredTermMapper.mapPreferredTermToOmrsRelationship(preferredTerm);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        PreferredTerm updatedPreferredTerm = PreferredTermMapper.mapOmrsRelationshipToPreferredTerm(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedPreferredTerm;
    }
    /**
      * Create ProjectHierarchy relationships
      * @param userId user identity
      * @param relationships ProjectHierarchy relationships to create
      * @return created ProjectHierarchy relationships
      */
    public ProjectHierarchy createProjectHierarchyRelationship(String userId,ProjectHierarchy relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createProjectHierarchyRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = ProjectHierarchyMapper.mapProjectHierarchyToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        ProjectHierarchy returnedProjectHierarchy =  ProjectHierarchyMapper.mapOmrsRelationshipToProjectHierarchy(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedProjectHierarchy;
    }
    /**
      * Get ProjectHierarchy relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return ProjectHierarchy relationships
      */
    public ProjectHierarchy getProjectHierarchyRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getProjectHierarchyRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            ProjectHierarchy gotProjectHierarchy = ProjectHierarchyMapper.mapOmrsRelationshipToProjectHierarchy(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotProjectHierarchy;
      }
    /**
      * Update ProjectHierarchy relationships
      * @param userId user identity
      * @param projectHierarchy relationships
      * @return  ProjectHierarchy relationships
      */
      public ProjectHierarchy updateProjectHierarchyRelationship(String userId,ProjectHierarchy projectHierarchy)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateProjectHierarchyRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = ProjectHierarchyMapper.mapProjectHierarchyToOmrsRelationship(projectHierarchy);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        ProjectHierarchy updatedProjectHierarchy = ProjectHierarchyMapper.mapOmrsRelationshipToProjectHierarchy(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedProjectHierarchy;
    }
    /**
      * Create DeployedVirtualContainer relationships
      * @param userId user identity
      * @param relationships DeployedVirtualContainer relationships to create
      * @return created DeployedVirtualContainer relationships
      */
    public DeployedVirtualContainer createDeployedVirtualContainerRelationship(String userId,DeployedVirtualContainer relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createDeployedVirtualContainerRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = DeployedVirtualContainerMapper.mapDeployedVirtualContainerToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        DeployedVirtualContainer returnedDeployedVirtualContainer =  DeployedVirtualContainerMapper.mapOmrsRelationshipToDeployedVirtualContainer(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedDeployedVirtualContainer;
    }
    /**
      * Get DeployedVirtualContainer relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return DeployedVirtualContainer relationships
      */
    public DeployedVirtualContainer getDeployedVirtualContainerRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getDeployedVirtualContainerRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            DeployedVirtualContainer gotDeployedVirtualContainer = DeployedVirtualContainerMapper.mapOmrsRelationshipToDeployedVirtualContainer(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotDeployedVirtualContainer;
      }
    /**
      * Update DeployedVirtualContainer relationships
      * @param userId user identity
      * @param deployedVirtualContainer relationships
      * @return  DeployedVirtualContainer relationships
      */
      public DeployedVirtualContainer updateDeployedVirtualContainerRelationship(String userId,DeployedVirtualContainer deployedVirtualContainer)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateDeployedVirtualContainerRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = DeployedVirtualContainerMapper.mapDeployedVirtualContainerToOmrsRelationship(deployedVirtualContainer);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        DeployedVirtualContainer updatedDeployedVirtualContainer = DeployedVirtualContainerMapper.mapOmrsRelationshipToDeployedVirtualContainer(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedDeployedVirtualContainer;
    }
    /**
      * Create AnnotationExtension relationships
      * @param userId user identity
      * @param relationships AnnotationExtension relationships to create
      * @return created AnnotationExtension relationships
      */
    public AnnotationExtension createAnnotationExtensionRelationship(String userId,AnnotationExtension relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createAnnotationExtensionRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = AnnotationExtensionMapper.mapAnnotationExtensionToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        AnnotationExtension returnedAnnotationExtension =  AnnotationExtensionMapper.mapOmrsRelationshipToAnnotationExtension(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedAnnotationExtension;
    }
    /**
      * Get AnnotationExtension relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return AnnotationExtension relationships
      */
    public AnnotationExtension getAnnotationExtensionRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getAnnotationExtensionRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            AnnotationExtension gotAnnotationExtension = AnnotationExtensionMapper.mapOmrsRelationshipToAnnotationExtension(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotAnnotationExtension;
      }
    /**
      * Update AnnotationExtension relationships
      * @param userId user identity
      * @param annotationExtension relationships
      * @return  AnnotationExtension relationships
      */
      public AnnotationExtension updateAnnotationExtensionRelationship(String userId,AnnotationExtension annotationExtension)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateAnnotationExtensionRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = AnnotationExtensionMapper.mapAnnotationExtensionToOmrsRelationship(annotationExtension);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        AnnotationExtension updatedAnnotationExtension = AnnotationExtensionMapper.mapOmrsRelationshipToAnnotationExtension(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedAnnotationExtension;
    }
    /**
      * Create DataClassHierarchy relationships
      * @param userId user identity
      * @param relationships DataClassHierarchy relationships to create
      * @return created DataClassHierarchy relationships
      */
    public DataClassHierarchy createDataClassHierarchyRelationship(String userId,DataClassHierarchy relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createDataClassHierarchyRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = DataClassHierarchyMapper.mapDataClassHierarchyToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        DataClassHierarchy returnedDataClassHierarchy =  DataClassHierarchyMapper.mapOmrsRelationshipToDataClassHierarchy(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedDataClassHierarchy;
    }
    /**
      * Get DataClassHierarchy relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return DataClassHierarchy relationships
      */
    public DataClassHierarchy getDataClassHierarchyRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getDataClassHierarchyRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            DataClassHierarchy gotDataClassHierarchy = DataClassHierarchyMapper.mapOmrsRelationshipToDataClassHierarchy(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotDataClassHierarchy;
      }
    /**
      * Update DataClassHierarchy relationships
      * @param userId user identity
      * @param dataClassHierarchy relationships
      * @return  DataClassHierarchy relationships
      */
      public DataClassHierarchy updateDataClassHierarchyRelationship(String userId,DataClassHierarchy dataClassHierarchy)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateDataClassHierarchyRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = DataClassHierarchyMapper.mapDataClassHierarchyToOmrsRelationship(dataClassHierarchy);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        DataClassHierarchy updatedDataClassHierarchy = DataClassHierarchyMapper.mapOmrsRelationshipToDataClassHierarchy(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedDataClassHierarchy;
    }
    /**
      * Create GovernanceResults relationships
      * @param userId user identity
      * @param relationships GovernanceResults relationships to create
      * @return created GovernanceResults relationships
      */
    public GovernanceResults createGovernanceResultsRelationship(String userId,GovernanceResults relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createGovernanceResultsRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = GovernanceResultsMapper.mapGovernanceResultsToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        GovernanceResults returnedGovernanceResults =  GovernanceResultsMapper.mapOmrsRelationshipToGovernanceResults(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedGovernanceResults;
    }
    /**
      * Get GovernanceResults relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return GovernanceResults relationships
      */
    public GovernanceResults getGovernanceResultsRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getGovernanceResultsRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            GovernanceResults gotGovernanceResults = GovernanceResultsMapper.mapOmrsRelationshipToGovernanceResults(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotGovernanceResults;
      }
    /**
      * Update GovernanceResults relationships
      * @param userId user identity
      * @param governanceResults relationships
      * @return  GovernanceResults relationships
      */
      public GovernanceResults updateGovernanceResultsRelationship(String userId,GovernanceResults governanceResults)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateGovernanceResultsRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = GovernanceResultsMapper.mapGovernanceResultsToOmrsRelationship(governanceResults);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        GovernanceResults updatedGovernanceResults = GovernanceResultsMapper.mapOmrsRelationshipToGovernanceResults(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedGovernanceResults;
    }
    /**
      * Create APIResponse relationships
      * @param userId user identity
      * @param relationships APIResponse relationships to create
      * @return created APIResponse relationships
      */
    public APIResponse createAPIResponseRelationship(String userId,APIResponse relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createAPIResponseRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = APIResponseMapper.mapAPIResponseToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        APIResponse returnedAPIResponse =  APIResponseMapper.mapOmrsRelationshipToAPIResponse(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedAPIResponse;
    }
    /**
      * Get APIResponse relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return APIResponse relationships
      */
    public APIResponse getAPIResponseRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getAPIResponseRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            APIResponse gotAPIResponse = APIResponseMapper.mapOmrsRelationshipToAPIResponse(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotAPIResponse;
      }
    /**
      * Update APIResponse relationships
      * @param userId user identity
      * @param aPIResponse relationships
      * @return  APIResponse relationships
      */
      public APIResponse updateAPIResponseRelationship(String userId,APIResponse aPIResponse)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateAPIResponseRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = APIResponseMapper.mapAPIResponseToOmrsRelationship(aPIResponse);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        APIResponse updatedAPIResponse = APIResponseMapper.mapOmrsRelationshipToAPIResponse(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedAPIResponse;
    }
    /**
      * Create SchemaAttributeDefinition relationships
      * @param userId user identity
      * @param relationships SchemaAttributeDefinition relationships to create
      * @return created SchemaAttributeDefinition relationships
      */
    public SchemaAttributeDefinition createSchemaAttributeDefinitionRelationship(String userId,SchemaAttributeDefinition relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createSchemaAttributeDefinitionRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = SchemaAttributeDefinitionMapper.mapSchemaAttributeDefinitionToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        SchemaAttributeDefinition returnedSchemaAttributeDefinition =  SchemaAttributeDefinitionMapper.mapOmrsRelationshipToSchemaAttributeDefinition(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedSchemaAttributeDefinition;
    }
    /**
      * Get SchemaAttributeDefinition relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return SchemaAttributeDefinition relationships
      */
    public SchemaAttributeDefinition getSchemaAttributeDefinitionRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getSchemaAttributeDefinitionRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            SchemaAttributeDefinition gotSchemaAttributeDefinition = SchemaAttributeDefinitionMapper.mapOmrsRelationshipToSchemaAttributeDefinition(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotSchemaAttributeDefinition;
      }
    /**
      * Update SchemaAttributeDefinition relationships
      * @param userId user identity
      * @param schemaAttributeDefinition relationships
      * @return  SchemaAttributeDefinition relationships
      */
      public SchemaAttributeDefinition updateSchemaAttributeDefinitionRelationship(String userId,SchemaAttributeDefinition schemaAttributeDefinition)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateSchemaAttributeDefinitionRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = SchemaAttributeDefinitionMapper.mapSchemaAttributeDefinitionToOmrsRelationship(schemaAttributeDefinition);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        SchemaAttributeDefinition updatedSchemaAttributeDefinition = SchemaAttributeDefinitionMapper.mapOmrsRelationshipToSchemaAttributeDefinition(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedSchemaAttributeDefinition;
    }
    /**
      * Create HostNetwork relationships
      * @param userId user identity
      * @param relationships HostNetwork relationships to create
      * @return created HostNetwork relationships
      */
    public HostNetwork createHostNetworkRelationship(String userId,HostNetwork relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createHostNetworkRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = HostNetworkMapper.mapHostNetworkToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        HostNetwork returnedHostNetwork =  HostNetworkMapper.mapOmrsRelationshipToHostNetwork(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedHostNetwork;
    }
    /**
      * Get HostNetwork relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return HostNetwork relationships
      */
    public HostNetwork getHostNetworkRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getHostNetworkRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            HostNetwork gotHostNetwork = HostNetworkMapper.mapOmrsRelationshipToHostNetwork(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotHostNetwork;
      }
    /**
      * Update HostNetwork relationships
      * @param userId user identity
      * @param hostNetwork relationships
      * @return  HostNetwork relationships
      */
      public HostNetwork updateHostNetworkRelationship(String userId,HostNetwork hostNetwork)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateHostNetworkRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = HostNetworkMapper.mapHostNetworkToOmrsRelationship(hostNetwork);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        HostNetwork updatedHostNetwork = HostNetworkMapper.mapOmrsRelationshipToHostNetwork(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedHostNetwork;
    }
    /**
      * Create AttributeForSchema relationships
      * @param userId user identity
      * @param relationships AttributeForSchema relationships to create
      * @return created AttributeForSchema relationships
      */
    public AttributeForSchema createAttributeForSchemaRelationship(String userId,AttributeForSchema relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createAttributeForSchemaRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = AttributeForSchemaMapper.mapAttributeForSchemaToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        AttributeForSchema returnedAttributeForSchema =  AttributeForSchemaMapper.mapOmrsRelationshipToAttributeForSchema(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedAttributeForSchema;
    }
    /**
      * Get AttributeForSchema relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return AttributeForSchema relationships
      */
    public AttributeForSchema getAttributeForSchemaRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getAttributeForSchemaRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            AttributeForSchema gotAttributeForSchema = AttributeForSchemaMapper.mapOmrsRelationshipToAttributeForSchema(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotAttributeForSchema;
      }
    /**
      * Update AttributeForSchema relationships
      * @param userId user identity
      * @param attributeForSchema relationships
      * @return  AttributeForSchema relationships
      */
      public AttributeForSchema updateAttributeForSchemaRelationship(String userId,AttributeForSchema attributeForSchema)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateAttributeForSchemaRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = AttributeForSchemaMapper.mapAttributeForSchemaToOmrsRelationship(attributeForSchema);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        AttributeForSchema updatedAttributeForSchema = AttributeForSchemaMapper.mapOmrsRelationshipToAttributeForSchema(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedAttributeForSchema;
    }
    /**
      * Create AssetLocation relationships
      * @param userId user identity
      * @param relationships AssetLocation relationships to create
      * @return created AssetLocation relationships
      */
    public AssetLocation createAssetLocationRelationship(String userId,AssetLocation relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createAssetLocationRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = AssetLocationMapper.mapAssetLocationToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        AssetLocation returnedAssetLocation =  AssetLocationMapper.mapOmrsRelationshipToAssetLocation(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedAssetLocation;
    }
    /**
      * Get AssetLocation relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return AssetLocation relationships
      */
    public AssetLocation getAssetLocationRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getAssetLocationRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            AssetLocation gotAssetLocation = AssetLocationMapper.mapOmrsRelationshipToAssetLocation(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotAssetLocation;
      }
    /**
      * Update AssetLocation relationships
      * @param userId user identity
      * @param assetLocation relationships
      * @return  AssetLocation relationships
      */
      public AssetLocation updateAssetLocationRelationship(String userId,AssetLocation assetLocation)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateAssetLocationRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = AssetLocationMapper.mapAssetLocationToOmrsRelationship(assetLocation);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        AssetLocation updatedAssetLocation = AssetLocationMapper.mapOmrsRelationshipToAssetLocation(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedAssetLocation;
    }
    /**
      * Create ParentPort relationships
      * @param userId user identity
      * @param relationships ParentPort relationships to create
      * @return created ParentPort relationships
      */
    public ParentPort createParentPortRelationship(String userId,ParentPort relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createParentPortRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = ParentPortMapper.mapParentPortToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        ParentPort returnedParentPort =  ParentPortMapper.mapOmrsRelationshipToParentPort(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedParentPort;
    }
    /**
      * Get ParentPort relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return ParentPort relationships
      */
    public ParentPort getParentPortRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getParentPortRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            ParentPort gotParentPort = ParentPortMapper.mapOmrsRelationshipToParentPort(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotParentPort;
      }
    /**
      * Update ParentPort relationships
      * @param userId user identity
      * @param parentPort relationships
      * @return  ParentPort relationships
      */
      public ParentPort updateParentPortRelationship(String userId,ParentPort parentPort)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateParentPortRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = ParentPortMapper.mapParentPortToOmrsRelationship(parentPort);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        ParentPort updatedParentPort = ParentPortMapper.mapOmrsRelationshipToParentPort(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedParentPort;
    }
    /**
      * Create SoftwareServerSupportedCapability relationships
      * @param userId user identity
      * @param relationships SoftwareServerSupportedCapability relationships to create
      * @return created SoftwareServerSupportedCapability relationships
      */
    public SoftwareServerSupportedCapability createSoftwareServerSupportedCapabilityRelationship(String userId,SoftwareServerSupportedCapability relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createSoftwareServerSupportedCapabilityRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = SoftwareServerSupportedCapabilityMapper.mapSoftwareServerSupportedCapabilityToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        SoftwareServerSupportedCapability returnedSoftwareServerSupportedCapability =  SoftwareServerSupportedCapabilityMapper.mapOmrsRelationshipToSoftwareServerSupportedCapability(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedSoftwareServerSupportedCapability;
    }
    /**
      * Get SoftwareServerSupportedCapability relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return SoftwareServerSupportedCapability relationships
      */
    public SoftwareServerSupportedCapability getSoftwareServerSupportedCapabilityRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getSoftwareServerSupportedCapabilityRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            SoftwareServerSupportedCapability gotSoftwareServerSupportedCapability = SoftwareServerSupportedCapabilityMapper.mapOmrsRelationshipToSoftwareServerSupportedCapability(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotSoftwareServerSupportedCapability;
      }
    /**
      * Update SoftwareServerSupportedCapability relationships
      * @param userId user identity
      * @param softwareServerSupportedCapability relationships
      * @return  SoftwareServerSupportedCapability relationships
      */
      public SoftwareServerSupportedCapability updateSoftwareServerSupportedCapabilityRelationship(String userId,SoftwareServerSupportedCapability softwareServerSupportedCapability)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateSoftwareServerSupportedCapabilityRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = SoftwareServerSupportedCapabilityMapper.mapSoftwareServerSupportedCapabilityToOmrsRelationship(softwareServerSupportedCapability);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        SoftwareServerSupportedCapability updatedSoftwareServerSupportedCapability = SoftwareServerSupportedCapabilityMapper.mapOmrsRelationshipToSoftwareServerSupportedCapability(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedSoftwareServerSupportedCapability;
    }
    /**
      * Create DiscoveredAnnotation relationships
      * @param userId user identity
      * @param relationships DiscoveredAnnotation relationships to create
      * @return created DiscoveredAnnotation relationships
      */
    public DiscoveredAnnotation createDiscoveredAnnotationRelationship(String userId,DiscoveredAnnotation relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createDiscoveredAnnotationRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = DiscoveredAnnotationMapper.mapDiscoveredAnnotationToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        DiscoveredAnnotation returnedDiscoveredAnnotation =  DiscoveredAnnotationMapper.mapOmrsRelationshipToDiscoveredAnnotation(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedDiscoveredAnnotation;
    }
    /**
      * Get DiscoveredAnnotation relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return DiscoveredAnnotation relationships
      */
    public DiscoveredAnnotation getDiscoveredAnnotationRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getDiscoveredAnnotationRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            DiscoveredAnnotation gotDiscoveredAnnotation = DiscoveredAnnotationMapper.mapOmrsRelationshipToDiscoveredAnnotation(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotDiscoveredAnnotation;
      }
    /**
      * Update DiscoveredAnnotation relationships
      * @param userId user identity
      * @param discoveredAnnotation relationships
      * @return  DiscoveredAnnotation relationships
      */
      public DiscoveredAnnotation updateDiscoveredAnnotationRelationship(String userId,DiscoveredAnnotation discoveredAnnotation)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateDiscoveredAnnotationRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = DiscoveredAnnotationMapper.mapDiscoveredAnnotationToOmrsRelationship(discoveredAnnotation);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        DiscoveredAnnotation updatedDiscoveredAnnotation = DiscoveredAnnotationMapper.mapOmrsRelationshipToDiscoveredAnnotation(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedDiscoveredAnnotation;
    }
    /**
      * Create SchemaAttributeType relationships
      * @param userId user identity
      * @param relationships SchemaAttributeType relationships to create
      * @return created SchemaAttributeType relationships
      */
    public SchemaAttributeType createSchemaAttributeTypeRelationship(String userId,SchemaAttributeType relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createSchemaAttributeTypeRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = SchemaAttributeTypeMapper.mapSchemaAttributeTypeToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        SchemaAttributeType returnedSchemaAttributeType =  SchemaAttributeTypeMapper.mapOmrsRelationshipToSchemaAttributeType(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedSchemaAttributeType;
    }
    /**
      * Get SchemaAttributeType relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return SchemaAttributeType relationships
      */
    public SchemaAttributeType getSchemaAttributeTypeRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getSchemaAttributeTypeRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            SchemaAttributeType gotSchemaAttributeType = SchemaAttributeTypeMapper.mapOmrsRelationshipToSchemaAttributeType(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotSchemaAttributeType;
      }
    /**
      * Update SchemaAttributeType relationships
      * @param userId user identity
      * @param schemaAttributeType relationships
      * @return  SchemaAttributeType relationships
      */
      public SchemaAttributeType updateSchemaAttributeTypeRelationship(String userId,SchemaAttributeType schemaAttributeType)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateSchemaAttributeTypeRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = SchemaAttributeTypeMapper.mapSchemaAttributeTypeToOmrsRelationship(schemaAttributeType);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        SchemaAttributeType updatedSchemaAttributeType = SchemaAttributeTypeMapper.mapOmrsRelationshipToSchemaAttributeType(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedSchemaAttributeType;
    }
    /**
      * Create GovernanceImplementation relationships
      * @param userId user identity
      * @param relationships GovernanceImplementation relationships to create
      * @return created GovernanceImplementation relationships
      */
    public GovernanceImplementation createGovernanceImplementationRelationship(String userId,GovernanceImplementation relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createGovernanceImplementationRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = GovernanceImplementationMapper.mapGovernanceImplementationToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        GovernanceImplementation returnedGovernanceImplementation =  GovernanceImplementationMapper.mapOmrsRelationshipToGovernanceImplementation(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedGovernanceImplementation;
    }
    /**
      * Get GovernanceImplementation relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return GovernanceImplementation relationships
      */
    public GovernanceImplementation getGovernanceImplementationRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getGovernanceImplementationRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            GovernanceImplementation gotGovernanceImplementation = GovernanceImplementationMapper.mapOmrsRelationshipToGovernanceImplementation(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotGovernanceImplementation;
      }
    /**
      * Update GovernanceImplementation relationships
      * @param userId user identity
      * @param governanceImplementation relationships
      * @return  GovernanceImplementation relationships
      */
      public GovernanceImplementation updateGovernanceImplementationRelationship(String userId,GovernanceImplementation governanceImplementation)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateGovernanceImplementationRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = GovernanceImplementationMapper.mapGovernanceImplementationToOmrsRelationship(governanceImplementation);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        GovernanceImplementation updatedGovernanceImplementation = GovernanceImplementationMapper.mapOmrsRelationshipToGovernanceImplementation(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedGovernanceImplementation;
    }
    /**
      * Create LinkedMedia relationships
      * @param userId user identity
      * @param relationships LinkedMedia relationships to create
      * @return created LinkedMedia relationships
      */
    public LinkedMedia createLinkedMediaRelationship(String userId,LinkedMedia relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createLinkedMediaRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = LinkedMediaMapper.mapLinkedMediaToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        LinkedMedia returnedLinkedMedia =  LinkedMediaMapper.mapOmrsRelationshipToLinkedMedia(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedLinkedMedia;
    }
    /**
      * Get LinkedMedia relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return LinkedMedia relationships
      */
    public LinkedMedia getLinkedMediaRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getLinkedMediaRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            LinkedMedia gotLinkedMedia = LinkedMediaMapper.mapOmrsRelationshipToLinkedMedia(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotLinkedMedia;
      }
    /**
      * Update LinkedMedia relationships
      * @param userId user identity
      * @param linkedMedia relationships
      * @return  LinkedMedia relationships
      */
      public LinkedMedia updateLinkedMediaRelationship(String userId,LinkedMedia linkedMedia)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateLinkedMediaRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = LinkedMediaMapper.mapLinkedMediaToOmrsRelationship(linkedMedia);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        LinkedMedia updatedLinkedMedia = LinkedMediaMapper.mapOmrsRelationshipToLinkedMedia(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedLinkedMedia;
    }
    /**
      * Create MapToElementType relationships
      * @param userId user identity
      * @param relationships MapToElementType relationships to create
      * @return created MapToElementType relationships
      */
    public MapToElementType createMapToElementTypeRelationship(String userId,MapToElementType relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createMapToElementTypeRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = MapToElementTypeMapper.mapMapToElementTypeToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        MapToElementType returnedMapToElementType =  MapToElementTypeMapper.mapOmrsRelationshipToMapToElementType(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedMapToElementType;
    }
    /**
      * Get MapToElementType relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return MapToElementType relationships
      */
    public MapToElementType getMapToElementTypeRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getMapToElementTypeRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            MapToElementType gotMapToElementType = MapToElementTypeMapper.mapOmrsRelationshipToMapToElementType(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotMapToElementType;
      }
    /**
      * Update MapToElementType relationships
      * @param userId user identity
      * @param mapToElementType relationships
      * @return  MapToElementType relationships
      */
      public MapToElementType updateMapToElementTypeRelationship(String userId,MapToElementType mapToElementType)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateMapToElementTypeRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = MapToElementTypeMapper.mapMapToElementTypeToOmrsRelationship(mapToElementType);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        MapToElementType updatedMapToElementType = MapToElementTypeMapper.mapOmrsRelationshipToMapToElementType(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedMapToElementType;
    }
    /**
      * Create ExternallySourcedGlossary relationships
      * @param userId user identity
      * @param relationships ExternallySourcedGlossary relationships to create
      * @return created ExternallySourcedGlossary relationships
      */
    public ExternallySourcedGlossary createExternallySourcedGlossaryRelationship(String userId,ExternallySourcedGlossary relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createExternallySourcedGlossaryRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = ExternallySourcedGlossaryMapper.mapExternallySourcedGlossaryToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        ExternallySourcedGlossary returnedExternallySourcedGlossary =  ExternallySourcedGlossaryMapper.mapOmrsRelationshipToExternallySourcedGlossary(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedExternallySourcedGlossary;
    }
    /**
      * Get ExternallySourcedGlossary relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return ExternallySourcedGlossary relationships
      */
    public ExternallySourcedGlossary getExternallySourcedGlossaryRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getExternallySourcedGlossaryRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            ExternallySourcedGlossary gotExternallySourcedGlossary = ExternallySourcedGlossaryMapper.mapOmrsRelationshipToExternallySourcedGlossary(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotExternallySourcedGlossary;
      }
    /**
      * Update ExternallySourcedGlossary relationships
      * @param userId user identity
      * @param externallySourcedGlossary relationships
      * @return  ExternallySourcedGlossary relationships
      */
      public ExternallySourcedGlossary updateExternallySourcedGlossaryRelationship(String userId,ExternallySourcedGlossary externallySourcedGlossary)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateExternallySourcedGlossaryRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = ExternallySourcedGlossaryMapper.mapExternallySourcedGlossaryToOmrsRelationship(externallySourcedGlossary);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        ExternallySourcedGlossary updatedExternallySourcedGlossary = ExternallySourcedGlossaryMapper.mapOmrsRelationshipToExternallySourcedGlossary(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedExternallySourcedGlossary;
    }
    /**
      * Create ExternalReferenceLink relationships
      * @param userId user identity
      * @param relationships ExternalReferenceLink relationships to create
      * @return created ExternalReferenceLink relationships
      */
    public ExternalReferenceLink createExternalReferenceLinkRelationship(String userId,ExternalReferenceLink relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createExternalReferenceLinkRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = ExternalReferenceLinkMapper.mapExternalReferenceLinkToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        ExternalReferenceLink returnedExternalReferenceLink =  ExternalReferenceLinkMapper.mapOmrsRelationshipToExternalReferenceLink(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedExternalReferenceLink;
    }
    /**
      * Get ExternalReferenceLink relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return ExternalReferenceLink relationships
      */
    public ExternalReferenceLink getExternalReferenceLinkRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getExternalReferenceLinkRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            ExternalReferenceLink gotExternalReferenceLink = ExternalReferenceLinkMapper.mapOmrsRelationshipToExternalReferenceLink(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotExternalReferenceLink;
      }
    /**
      * Update ExternalReferenceLink relationships
      * @param userId user identity
      * @param externalReferenceLink relationships
      * @return  ExternalReferenceLink relationships
      */
      public ExternalReferenceLink updateExternalReferenceLinkRelationship(String userId,ExternalReferenceLink externalReferenceLink)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateExternalReferenceLinkRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = ExternalReferenceLinkMapper.mapExternalReferenceLinkToOmrsRelationship(externalReferenceLink);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        ExternalReferenceLink updatedExternalReferenceLink = ExternalReferenceLinkMapper.mapOmrsRelationshipToExternalReferenceLink(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedExternalReferenceLink;
    }
    /**
      * Create MediaReference relationships
      * @param userId user identity
      * @param relationships MediaReference relationships to create
      * @return created MediaReference relationships
      */
    public MediaReference createMediaReferenceRelationship(String userId,MediaReference relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createMediaReferenceRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = MediaReferenceMapper.mapMediaReferenceToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        MediaReference returnedMediaReference =  MediaReferenceMapper.mapOmrsRelationshipToMediaReference(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedMediaReference;
    }
    /**
      * Get MediaReference relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return MediaReference relationships
      */
    public MediaReference getMediaReferenceRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getMediaReferenceRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            MediaReference gotMediaReference = MediaReferenceMapper.mapOmrsRelationshipToMediaReference(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotMediaReference;
      }
    /**
      * Update MediaReference relationships
      * @param userId user identity
      * @param mediaReference relationships
      * @return  MediaReference relationships
      */
      public MediaReference updateMediaReferenceRelationship(String userId,MediaReference mediaReference)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateMediaReferenceRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = MediaReferenceMapper.mapMediaReferenceToOmrsRelationship(mediaReference);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        MediaReference updatedMediaReference = MediaReferenceMapper.mapOmrsRelationshipToMediaReference(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedMediaReference;
    }
    /**
      * Create CommunityMembership relationships
      * @param userId user identity
      * @param relationships CommunityMembership relationships to create
      * @return created CommunityMembership relationships
      */
    public CommunityMembership createCommunityMembershipRelationship(String userId,CommunityMembership relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createCommunityMembershipRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = CommunityMembershipMapper.mapCommunityMembershipToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        CommunityMembership returnedCommunityMembership =  CommunityMembershipMapper.mapOmrsRelationshipToCommunityMembership(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedCommunityMembership;
    }
    /**
      * Get CommunityMembership relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return CommunityMembership relationships
      */
    public CommunityMembership getCommunityMembershipRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getCommunityMembershipRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            CommunityMembership gotCommunityMembership = CommunityMembershipMapper.mapOmrsRelationshipToCommunityMembership(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotCommunityMembership;
      }
    /**
      * Update CommunityMembership relationships
      * @param userId user identity
      * @param communityMembership relationships
      * @return  CommunityMembership relationships
      */
      public CommunityMembership updateCommunityMembershipRelationship(String userId,CommunityMembership communityMembership)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateCommunityMembershipRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = CommunityMembershipMapper.mapCommunityMembershipToOmrsRelationship(communityMembership);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        CommunityMembership updatedCommunityMembership = CommunityMembershipMapper.mapOmrsRelationshipToCommunityMembership(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedCommunityMembership;
    }
    /**
      * Create ExternalIdScope relationships
      * @param userId user identity
      * @param relationships ExternalIdScope relationships to create
      * @return created ExternalIdScope relationships
      */
    public ExternalIdScope createExternalIdScopeRelationship(String userId,ExternalIdScope relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createExternalIdScopeRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = ExternalIdScopeMapper.mapExternalIdScopeToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        ExternalIdScope returnedExternalIdScope =  ExternalIdScopeMapper.mapOmrsRelationshipToExternalIdScope(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedExternalIdScope;
    }
    /**
      * Get ExternalIdScope relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return ExternalIdScope relationships
      */
    public ExternalIdScope getExternalIdScopeRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getExternalIdScopeRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            ExternalIdScope gotExternalIdScope = ExternalIdScopeMapper.mapOmrsRelationshipToExternalIdScope(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotExternalIdScope;
      }
    /**
      * Update ExternalIdScope relationships
      * @param userId user identity
      * @param externalIdScope relationships
      * @return  ExternalIdScope relationships
      */
      public ExternalIdScope updateExternalIdScopeRelationship(String userId,ExternalIdScope externalIdScope)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateExternalIdScopeRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = ExternalIdScopeMapper.mapExternalIdScopeToOmrsRelationship(externalIdScope);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        ExternalIdScope updatedExternalIdScope = ExternalIdScopeMapper.mapOmrsRelationshipToExternalIdScope(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedExternalIdScope;
    }
    /**
      * Create ValidValue relationships
      * @param userId user identity
      * @param relationships ValidValue relationships to create
      * @return created ValidValue relationships
      */
    public ValidValue createValidValueRelationship(String userId,ValidValue relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createValidValueRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = ValidValueMapper.mapValidValueToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        ValidValue returnedValidValue =  ValidValueMapper.mapOmrsRelationshipToValidValue(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedValidValue;
    }
    /**
      * Get ValidValue relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return ValidValue relationships
      */
    public ValidValue getValidValueRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getValidValueRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            ValidValue gotValidValue = ValidValueMapper.mapOmrsRelationshipToValidValue(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotValidValue;
      }
    /**
      * Update ValidValue relationships
      * @param userId user identity
      * @param validValue relationships
      * @return  ValidValue relationships
      */
      public ValidValue updateValidValueRelationship(String userId,ValidValue validValue)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateValidValueRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = ValidValueMapper.mapValidValueToOmrsRelationship(validValue);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        ValidValue updatedValidValue = ValidValueMapper.mapOmrsRelationshipToValidValue(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedValidValue;
    }
    /**
      * Create AcceptedAnswer relationships
      * @param userId user identity
      * @param relationships AcceptedAnswer relationships to create
      * @return created AcceptedAnswer relationships
      */
    public AcceptedAnswer createAcceptedAnswerRelationship(String userId,AcceptedAnswer relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createAcceptedAnswerRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = AcceptedAnswerMapper.mapAcceptedAnswerToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        AcceptedAnswer returnedAcceptedAnswer =  AcceptedAnswerMapper.mapOmrsRelationshipToAcceptedAnswer(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedAcceptedAnswer;
    }
    /**
      * Get AcceptedAnswer relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return AcceptedAnswer relationships
      */
    public AcceptedAnswer getAcceptedAnswerRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getAcceptedAnswerRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            AcceptedAnswer gotAcceptedAnswer = AcceptedAnswerMapper.mapOmrsRelationshipToAcceptedAnswer(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotAcceptedAnswer;
      }
    /**
      * Update AcceptedAnswer relationships
      * @param userId user identity
      * @param acceptedAnswer relationships
      * @return  AcceptedAnswer relationships
      */
      public AcceptedAnswer updateAcceptedAnswerRelationship(String userId,AcceptedAnswer acceptedAnswer)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateAcceptedAnswerRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = AcceptedAnswerMapper.mapAcceptedAnswerToOmrsRelationship(acceptedAnswer);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        AcceptedAnswer updatedAcceptedAnswer = AcceptedAnswerMapper.mapOmrsRelationshipToAcceptedAnswer(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedAcceptedAnswer;
    }
    /**
      * Create GovernanceDefinitionMetric relationships
      * @param userId user identity
      * @param relationships GovernanceDefinitionMetric relationships to create
      * @return created GovernanceDefinitionMetric relationships
      */
    public GovernanceDefinitionMetric createGovernanceDefinitionMetricRelationship(String userId,GovernanceDefinitionMetric relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createGovernanceDefinitionMetricRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = GovernanceDefinitionMetricMapper.mapGovernanceDefinitionMetricToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        GovernanceDefinitionMetric returnedGovernanceDefinitionMetric =  GovernanceDefinitionMetricMapper.mapOmrsRelationshipToGovernanceDefinitionMetric(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedGovernanceDefinitionMetric;
    }
    /**
      * Get GovernanceDefinitionMetric relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return GovernanceDefinitionMetric relationships
      */
    public GovernanceDefinitionMetric getGovernanceDefinitionMetricRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getGovernanceDefinitionMetricRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            GovernanceDefinitionMetric gotGovernanceDefinitionMetric = GovernanceDefinitionMetricMapper.mapOmrsRelationshipToGovernanceDefinitionMetric(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotGovernanceDefinitionMetric;
      }
    /**
      * Update GovernanceDefinitionMetric relationships
      * @param userId user identity
      * @param governanceDefinitionMetric relationships
      * @return  GovernanceDefinitionMetric relationships
      */
      public GovernanceDefinitionMetric updateGovernanceDefinitionMetricRelationship(String userId,GovernanceDefinitionMetric governanceDefinitionMetric)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateGovernanceDefinitionMetricRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = GovernanceDefinitionMetricMapper.mapGovernanceDefinitionMetricToOmrsRelationship(governanceDefinitionMetric);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        GovernanceDefinitionMetric updatedGovernanceDefinitionMetric = GovernanceDefinitionMetricMapper.mapOmrsRelationshipToGovernanceDefinitionMetric(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedGovernanceDefinitionMetric;
    }
    /**
      * Create TeamStructure relationships
      * @param userId user identity
      * @param relationships TeamStructure relationships to create
      * @return created TeamStructure relationships
      */
    public TeamStructure createTeamStructureRelationship(String userId,TeamStructure relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createTeamStructureRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = TeamStructureMapper.mapTeamStructureToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        TeamStructure returnedTeamStructure =  TeamStructureMapper.mapOmrsRelationshipToTeamStructure(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedTeamStructure;
    }
    /**
      * Get TeamStructure relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return TeamStructure relationships
      */
    public TeamStructure getTeamStructureRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getTeamStructureRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            TeamStructure gotTeamStructure = TeamStructureMapper.mapOmrsRelationshipToTeamStructure(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotTeamStructure;
      }
    /**
      * Update TeamStructure relationships
      * @param userId user identity
      * @param teamStructure relationships
      * @return  TeamStructure relationships
      */
      public TeamStructure updateTeamStructureRelationship(String userId,TeamStructure teamStructure)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateTeamStructureRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = TeamStructureMapper.mapTeamStructureToOmrsRelationship(teamStructure);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        TeamStructure updatedTeamStructure = TeamStructureMapper.mapOmrsRelationshipToTeamStructure(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedTeamStructure;
    }
    /**
      * Create SchemaQueryImplementation relationships
      * @param userId user identity
      * @param relationships SchemaQueryImplementation relationships to create
      * @return created SchemaQueryImplementation relationships
      */
    public SchemaQueryImplementation createSchemaQueryImplementationRelationship(String userId,SchemaQueryImplementation relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createSchemaQueryImplementationRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = SchemaQueryImplementationMapper.mapSchemaQueryImplementationToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        SchemaQueryImplementation returnedSchemaQueryImplementation =  SchemaQueryImplementationMapper.mapOmrsRelationshipToSchemaQueryImplementation(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedSchemaQueryImplementation;
    }
    /**
      * Get SchemaQueryImplementation relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return SchemaQueryImplementation relationships
      */
    public SchemaQueryImplementation getSchemaQueryImplementationRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getSchemaQueryImplementationRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            SchemaQueryImplementation gotSchemaQueryImplementation = SchemaQueryImplementationMapper.mapOmrsRelationshipToSchemaQueryImplementation(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotSchemaQueryImplementation;
      }
    /**
      * Update SchemaQueryImplementation relationships
      * @param userId user identity
      * @param schemaQueryImplementation relationships
      * @return  SchemaQueryImplementation relationships
      */
      public SchemaQueryImplementation updateSchemaQueryImplementationRelationship(String userId,SchemaQueryImplementation schemaQueryImplementation)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateSchemaQueryImplementationRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = SchemaQueryImplementationMapper.mapSchemaQueryImplementationToOmrsRelationship(schemaQueryImplementation);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        SchemaQueryImplementation updatedSchemaQueryImplementation = SchemaQueryImplementationMapper.mapOmrsRelationshipToSchemaQueryImplementation(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedSchemaQueryImplementation;
    }
    /**
      * Create AssetSchemaType relationships
      * @param userId user identity
      * @param relationships AssetSchemaType relationships to create
      * @return created AssetSchemaType relationships
      */
    public AssetSchemaType createAssetSchemaTypeRelationship(String userId,AssetSchemaType relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createAssetSchemaTypeRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = AssetSchemaTypeMapper.mapAssetSchemaTypeToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        AssetSchemaType returnedAssetSchemaType =  AssetSchemaTypeMapper.mapOmrsRelationshipToAssetSchemaType(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedAssetSchemaType;
    }
    /**
      * Get AssetSchemaType relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return AssetSchemaType relationships
      */
    public AssetSchemaType getAssetSchemaTypeRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getAssetSchemaTypeRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            AssetSchemaType gotAssetSchemaType = AssetSchemaTypeMapper.mapOmrsRelationshipToAssetSchemaType(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotAssetSchemaType;
      }
    /**
      * Update AssetSchemaType relationships
      * @param userId user identity
      * @param assetSchemaType relationships
      * @return  AssetSchemaType relationships
      */
      public AssetSchemaType updateAssetSchemaTypeRelationship(String userId,AssetSchemaType assetSchemaType)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateAssetSchemaTypeRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = AssetSchemaTypeMapper.mapAssetSchemaTypeToOmrsRelationship(assetSchemaType);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        AssetSchemaType updatedAssetSchemaType = AssetSchemaTypeMapper.mapOmrsRelationshipToAssetSchemaType(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedAssetSchemaType;
    }
    /**
      * Create ProjectDependency relationships
      * @param userId user identity
      * @param relationships ProjectDependency relationships to create
      * @return created ProjectDependency relationships
      */
    public ProjectDependency createProjectDependencyRelationship(String userId,ProjectDependency relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createProjectDependencyRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = ProjectDependencyMapper.mapProjectDependencyToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        ProjectDependency returnedProjectDependency =  ProjectDependencyMapper.mapOmrsRelationshipToProjectDependency(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedProjectDependency;
    }
    /**
      * Get ProjectDependency relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return ProjectDependency relationships
      */
    public ProjectDependency getProjectDependencyRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getProjectDependencyRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            ProjectDependency gotProjectDependency = ProjectDependencyMapper.mapOmrsRelationshipToProjectDependency(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotProjectDependency;
      }
    /**
      * Update ProjectDependency relationships
      * @param userId user identity
      * @param projectDependency relationships
      * @return  ProjectDependency relationships
      */
      public ProjectDependency updateProjectDependencyRelationship(String userId,ProjectDependency projectDependency)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateProjectDependencyRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = ProjectDependencyMapper.mapProjectDependencyToOmrsRelationship(projectDependency);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        ProjectDependency updatedProjectDependency = ProjectDependencyMapper.mapOmrsRelationshipToProjectDependency(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedProjectDependency;
    }
    /**
      * Create TopicSubscribers relationships
      * @param userId user identity
      * @param relationships TopicSubscribers relationships to create
      * @return created TopicSubscribers relationships
      */
    public TopicSubscribers createTopicSubscribersRelationship(String userId,TopicSubscribers relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createTopicSubscribersRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = TopicSubscribersMapper.mapTopicSubscribersToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        TopicSubscribers returnedTopicSubscribers =  TopicSubscribersMapper.mapOmrsRelationshipToTopicSubscribers(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedTopicSubscribers;
    }
    /**
      * Get TopicSubscribers relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return TopicSubscribers relationships
      */
    public TopicSubscribers getTopicSubscribersRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getTopicSubscribersRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            TopicSubscribers gotTopicSubscribers = TopicSubscribersMapper.mapOmrsRelationshipToTopicSubscribers(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotTopicSubscribers;
      }
    /**
      * Update TopicSubscribers relationships
      * @param userId user identity
      * @param topicSubscribers relationships
      * @return  TopicSubscribers relationships
      */
      public TopicSubscribers updateTopicSubscribersRelationship(String userId,TopicSubscribers topicSubscribers)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateTopicSubscribersRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = TopicSubscribersMapper.mapTopicSubscribersToOmrsRelationship(topicSubscribers);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        TopicSubscribers updatedTopicSubscribers = TopicSubscribersMapper.mapOmrsRelationshipToTopicSubscribers(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedTopicSubscribers;
    }
    /**
      * Create ReplacementTerm relationships
      * @param userId user identity
      * @param relationships ReplacementTerm relationships to create
      * @return created ReplacementTerm relationships
      */
    public ReplacementTerm createReplacementTermRelationship(String userId,ReplacementTerm relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createReplacementTermRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = ReplacementTermMapper.mapReplacementTermToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        ReplacementTerm returnedReplacementTerm =  ReplacementTermMapper.mapOmrsRelationshipToReplacementTerm(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedReplacementTerm;
    }
    /**
      * Get ReplacementTerm relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return ReplacementTerm relationships
      */
    public ReplacementTerm getReplacementTermRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getReplacementTermRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            ReplacementTerm gotReplacementTerm = ReplacementTermMapper.mapOmrsRelationshipToReplacementTerm(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotReplacementTerm;
      }
    /**
      * Update ReplacementTerm relationships
      * @param userId user identity
      * @param replacementTerm relationships
      * @return  ReplacementTerm relationships
      */
      public ReplacementTerm updateReplacementTermRelationship(String userId,ReplacementTerm replacementTerm)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateReplacementTermRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = ReplacementTermMapper.mapReplacementTermToOmrsRelationship(replacementTerm);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        ReplacementTerm updatedReplacementTerm = ReplacementTermMapper.mapOmrsRelationshipToReplacementTerm(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedReplacementTerm;
    }
    /**
      * Create OrganizationalCapability relationships
      * @param userId user identity
      * @param relationships OrganizationalCapability relationships to create
      * @return created OrganizationalCapability relationships
      */
    public OrganizationalCapability createOrganizationalCapabilityRelationship(String userId,OrganizationalCapability relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createOrganizationalCapabilityRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = OrganizationalCapabilityMapper.mapOrganizationalCapabilityToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        OrganizationalCapability returnedOrganizationalCapability =  OrganizationalCapabilityMapper.mapOmrsRelationshipToOrganizationalCapability(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedOrganizationalCapability;
    }
    /**
      * Get OrganizationalCapability relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return OrganizationalCapability relationships
      */
    public OrganizationalCapability getOrganizationalCapabilityRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getOrganizationalCapabilityRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            OrganizationalCapability gotOrganizationalCapability = OrganizationalCapabilityMapper.mapOmrsRelationshipToOrganizationalCapability(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotOrganizationalCapability;
      }
    /**
      * Update OrganizationalCapability relationships
      * @param userId user identity
      * @param organizationalCapability relationships
      * @return  OrganizationalCapability relationships
      */
      public OrganizationalCapability updateOrganizationalCapabilityRelationship(String userId,OrganizationalCapability organizationalCapability)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateOrganizationalCapabilityRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = OrganizationalCapabilityMapper.mapOrganizationalCapabilityToOmrsRelationship(organizationalCapability);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        OrganizationalCapability updatedOrganizationalCapability = OrganizationalCapabilityMapper.mapOmrsRelationshipToOrganizationalCapability(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedOrganizationalCapability;
    }
    /**
      * Create MetadataCohortPeer relationships
      * @param userId user identity
      * @param relationships MetadataCohortPeer relationships to create
      * @return created MetadataCohortPeer relationships
      */
    public MetadataCohortPeer createMetadataCohortPeerRelationship(String userId,MetadataCohortPeer relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createMetadataCohortPeerRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = MetadataCohortPeerMapper.mapMetadataCohortPeerToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        MetadataCohortPeer returnedMetadataCohortPeer =  MetadataCohortPeerMapper.mapOmrsRelationshipToMetadataCohortPeer(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedMetadataCohortPeer;
    }
    /**
      * Get MetadataCohortPeer relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return MetadataCohortPeer relationships
      */
    public MetadataCohortPeer getMetadataCohortPeerRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getMetadataCohortPeerRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            MetadataCohortPeer gotMetadataCohortPeer = MetadataCohortPeerMapper.mapOmrsRelationshipToMetadataCohortPeer(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotMetadataCohortPeer;
      }
    /**
      * Update MetadataCohortPeer relationships
      * @param userId user identity
      * @param metadataCohortPeer relationships
      * @return  MetadataCohortPeer relationships
      */
      public MetadataCohortPeer updateMetadataCohortPeerRelationship(String userId,MetadataCohortPeer metadataCohortPeer)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateMetadataCohortPeerRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = MetadataCohortPeerMapper.mapMetadataCohortPeerToOmrsRelationship(metadataCohortPeer);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        MetadataCohortPeer updatedMetadataCohortPeer = MetadataCohortPeerMapper.mapOmrsRelationshipToMetadataCohortPeer(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedMetadataCohortPeer;
    }
    /**
      * Create CollectionMembership relationships
      * @param userId user identity
      * @param relationships CollectionMembership relationships to create
      * @return created CollectionMembership relationships
      */
    public CollectionMembership createCollectionMembershipRelationship(String userId,CollectionMembership relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createCollectionMembershipRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = CollectionMembershipMapper.mapCollectionMembershipToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        CollectionMembership returnedCollectionMembership =  CollectionMembershipMapper.mapOmrsRelationshipToCollectionMembership(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedCollectionMembership;
    }
    /**
      * Get CollectionMembership relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return CollectionMembership relationships
      */
    public CollectionMembership getCollectionMembershipRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getCollectionMembershipRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            CollectionMembership gotCollectionMembership = CollectionMembershipMapper.mapOmrsRelationshipToCollectionMembership(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotCollectionMembership;
      }
    /**
      * Update CollectionMembership relationships
      * @param userId user identity
      * @param collectionMembership relationships
      * @return  CollectionMembership relationships
      */
      public CollectionMembership updateCollectionMembershipRelationship(String userId,CollectionMembership collectionMembership)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateCollectionMembershipRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = CollectionMembershipMapper.mapCollectionMembershipToOmrsRelationship(collectionMembership);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        CollectionMembership updatedCollectionMembership = CollectionMembershipMapper.mapOmrsRelationshipToCollectionMembership(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedCollectionMembership;
    }
    /**
      * Create AttachedNoteLogEntry relationships
      * @param userId user identity
      * @param relationships AttachedNoteLogEntry relationships to create
      * @return created AttachedNoteLogEntry relationships
      */
    public AttachedNoteLogEntry createAttachedNoteLogEntryRelationship(String userId,AttachedNoteLogEntry relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createAttachedNoteLogEntryRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = AttachedNoteLogEntryMapper.mapAttachedNoteLogEntryToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        AttachedNoteLogEntry returnedAttachedNoteLogEntry =  AttachedNoteLogEntryMapper.mapOmrsRelationshipToAttachedNoteLogEntry(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedAttachedNoteLogEntry;
    }
    /**
      * Get AttachedNoteLogEntry relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return AttachedNoteLogEntry relationships
      */
    public AttachedNoteLogEntry getAttachedNoteLogEntryRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getAttachedNoteLogEntryRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            AttachedNoteLogEntry gotAttachedNoteLogEntry = AttachedNoteLogEntryMapper.mapOmrsRelationshipToAttachedNoteLogEntry(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotAttachedNoteLogEntry;
      }
    /**
      * Update AttachedNoteLogEntry relationships
      * @param userId user identity
      * @param attachedNoteLogEntry relationships
      * @return  AttachedNoteLogEntry relationships
      */
      public AttachedNoteLogEntry updateAttachedNoteLogEntryRelationship(String userId,AttachedNoteLogEntry attachedNoteLogEntry)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateAttachedNoteLogEntryRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = AttachedNoteLogEntryMapper.mapAttachedNoteLogEntryToOmrsRelationship(attachedNoteLogEntry);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        AttachedNoteLogEntry updatedAttachedNoteLogEntry = AttachedNoteLogEntryMapper.mapOmrsRelationshipToAttachedNoteLogEntry(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedAttachedNoteLogEntry;
    }
    /**
      * Create AssetServerUse relationships
      * @param userId user identity
      * @param relationships AssetServerUse relationships to create
      * @return created AssetServerUse relationships
      */
    public AssetServerUse createAssetServerUseRelationship(String userId,AssetServerUse relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createAssetServerUseRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = AssetServerUseMapper.mapAssetServerUseToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        AssetServerUse returnedAssetServerUse =  AssetServerUseMapper.mapOmrsRelationshipToAssetServerUse(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedAssetServerUse;
    }
    /**
      * Get AssetServerUse relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return AssetServerUse relationships
      */
    public AssetServerUse getAssetServerUseRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getAssetServerUseRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            AssetServerUse gotAssetServerUse = AssetServerUseMapper.mapOmrsRelationshipToAssetServerUse(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotAssetServerUse;
      }
    /**
      * Update AssetServerUse relationships
      * @param userId user identity
      * @param assetServerUse relationships
      * @return  AssetServerUse relationships
      */
      public AssetServerUse updateAssetServerUseRelationship(String userId,AssetServerUse assetServerUse)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateAssetServerUseRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = AssetServerUseMapper.mapAssetServerUseToOmrsRelationship(assetServerUse);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        AssetServerUse updatedAssetServerUse = AssetServerUseMapper.mapOmrsRelationshipToAssetServerUse(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedAssetServerUse;
    }
    /**
      * Create RuntimeForProcess relationships
      * @param userId user identity
      * @param relationships RuntimeForProcess relationships to create
      * @return created RuntimeForProcess relationships
      */
    public RuntimeForProcess createRuntimeForProcessRelationship(String userId,RuntimeForProcess relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createRuntimeForProcessRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = RuntimeForProcessMapper.mapRuntimeForProcessToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        RuntimeForProcess returnedRuntimeForProcess =  RuntimeForProcessMapper.mapOmrsRelationshipToRuntimeForProcess(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedRuntimeForProcess;
    }
    /**
      * Get RuntimeForProcess relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return RuntimeForProcess relationships
      */
    public RuntimeForProcess getRuntimeForProcessRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getRuntimeForProcessRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            RuntimeForProcess gotRuntimeForProcess = RuntimeForProcessMapper.mapOmrsRelationshipToRuntimeForProcess(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotRuntimeForProcess;
      }
    /**
      * Update RuntimeForProcess relationships
      * @param userId user identity
      * @param runtimeForProcess relationships
      * @return  RuntimeForProcess relationships
      */
      public RuntimeForProcess updateRuntimeForProcessRelationship(String userId,RuntimeForProcess runtimeForProcess)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateRuntimeForProcessRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = RuntimeForProcessMapper.mapRuntimeForProcessToOmrsRelationship(runtimeForProcess);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        RuntimeForProcess updatedRuntimeForProcess = RuntimeForProcessMapper.mapOmrsRelationshipToRuntimeForProcess(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedRuntimeForProcess;
    }
    /**
      * Create SupportedDiscoveryService relationships
      * @param userId user identity
      * @param relationships SupportedDiscoveryService relationships to create
      * @return created SupportedDiscoveryService relationships
      */
    public SupportedDiscoveryService createSupportedDiscoveryServiceRelationship(String userId,SupportedDiscoveryService relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createSupportedDiscoveryServiceRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = SupportedDiscoveryServiceMapper.mapSupportedDiscoveryServiceToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        SupportedDiscoveryService returnedSupportedDiscoveryService =  SupportedDiscoveryServiceMapper.mapOmrsRelationshipToSupportedDiscoveryService(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedSupportedDiscoveryService;
    }
    /**
      * Get SupportedDiscoveryService relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return SupportedDiscoveryService relationships
      */
    public SupportedDiscoveryService getSupportedDiscoveryServiceRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getSupportedDiscoveryServiceRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            SupportedDiscoveryService gotSupportedDiscoveryService = SupportedDiscoveryServiceMapper.mapOmrsRelationshipToSupportedDiscoveryService(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotSupportedDiscoveryService;
      }
    /**
      * Update SupportedDiscoveryService relationships
      * @param userId user identity
      * @param supportedDiscoveryService relationships
      * @return  SupportedDiscoveryService relationships
      */
      public SupportedDiscoveryService updateSupportedDiscoveryServiceRelationship(String userId,SupportedDiscoveryService supportedDiscoveryService)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateSupportedDiscoveryServiceRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = SupportedDiscoveryServiceMapper.mapSupportedDiscoveryServiceToOmrsRelationship(supportedDiscoveryService);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        SupportedDiscoveryService updatedSupportedDiscoveryService = SupportedDiscoveryServiceMapper.mapOmrsRelationshipToSupportedDiscoveryService(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedSupportedDiscoveryService;
    }
    /**
      * Create NestedLocation relationships
      * @param userId user identity
      * @param relationships NestedLocation relationships to create
      * @return created NestedLocation relationships
      */
    public NestedLocation createNestedLocationRelationship(String userId,NestedLocation relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createNestedLocationRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = NestedLocationMapper.mapNestedLocationToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        NestedLocation returnedNestedLocation =  NestedLocationMapper.mapOmrsRelationshipToNestedLocation(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedNestedLocation;
    }
    /**
      * Get NestedLocation relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return NestedLocation relationships
      */
    public NestedLocation getNestedLocationRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getNestedLocationRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            NestedLocation gotNestedLocation = NestedLocationMapper.mapOmrsRelationshipToNestedLocation(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotNestedLocation;
      }
    /**
      * Update NestedLocation relationships
      * @param userId user identity
      * @param nestedLocation relationships
      * @return  NestedLocation relationships
      */
      public NestedLocation updateNestedLocationRelationship(String userId,NestedLocation nestedLocation)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateNestedLocationRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = NestedLocationMapper.mapNestedLocationToOmrsRelationship(nestedLocation);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        NestedLocation updatedNestedLocation = NestedLocationMapper.mapOmrsRelationshipToNestedLocation(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedNestedLocation;
    }
    /**
      * Create LinkedFile relationships
      * @param userId user identity
      * @param relationships LinkedFile relationships to create
      * @return created LinkedFile relationships
      */
    public LinkedFile createLinkedFileRelationship(String userId,LinkedFile relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createLinkedFileRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = LinkedFileMapper.mapLinkedFileToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        LinkedFile returnedLinkedFile =  LinkedFileMapper.mapOmrsRelationshipToLinkedFile(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedLinkedFile;
    }
    /**
      * Get LinkedFile relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return LinkedFile relationships
      */
    public LinkedFile getLinkedFileRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getLinkedFileRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            LinkedFile gotLinkedFile = LinkedFileMapper.mapOmrsRelationshipToLinkedFile(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotLinkedFile;
      }
    /**
      * Update LinkedFile relationships
      * @param userId user identity
      * @param linkedFile relationships
      * @return  LinkedFile relationships
      */
      public LinkedFile updateLinkedFileRelationship(String userId,LinkedFile linkedFile)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateLinkedFileRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = LinkedFileMapper.mapLinkedFileToOmrsRelationship(linkedFile);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        LinkedFile updatedLinkedFile = LinkedFileMapper.mapOmrsRelationshipToLinkedFile(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedLinkedFile;
    }
    /**
      * Create TermCategorization relationships
      * @param userId user identity
      * @param relationships TermCategorization relationships to create
      * @return created TermCategorization relationships
      */
    public TermCategorization createTermCategorizationRelationship(String userId,TermCategorization relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createTermCategorizationRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = TermCategorizationMapper.mapTermCategorizationToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        TermCategorization returnedTermCategorization =  TermCategorizationMapper.mapOmrsRelationshipToTermCategorization(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedTermCategorization;
    }
    /**
      * Get TermCategorization relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return TermCategorization relationships
      */
    public TermCategorization getTermCategorizationRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getTermCategorizationRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            TermCategorization gotTermCategorization = TermCategorizationMapper.mapOmrsRelationshipToTermCategorization(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotTermCategorization;
      }
    /**
      * Update TermCategorization relationships
      * @param userId user identity
      * @param termCategorization relationships
      * @return  TermCategorization relationships
      */
      public TermCategorization updateTermCategorizationRelationship(String userId,TermCategorization termCategorization)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateTermCategorizationRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = TermCategorizationMapper.mapTermCategorizationToOmrsRelationship(termCategorization);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        TermCategorization updatedTermCategorization = TermCategorizationMapper.mapOmrsRelationshipToTermCategorization(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedTermCategorization;
    }
    /**
      * Create PortWire relationships
      * @param userId user identity
      * @param relationships PortWire relationships to create
      * @return created PortWire relationships
      */
    public PortWire createPortWireRelationship(String userId,PortWire relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createPortWireRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = PortWireMapper.mapPortWireToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        PortWire returnedPortWire =  PortWireMapper.mapOmrsRelationshipToPortWire(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedPortWire;
    }
    /**
      * Get PortWire relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return PortWire relationships
      */
    public PortWire getPortWireRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getPortWireRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            PortWire gotPortWire = PortWireMapper.mapOmrsRelationshipToPortWire(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotPortWire;
      }
    /**
      * Update PortWire relationships
      * @param userId user identity
      * @param portWire relationships
      * @return  PortWire relationships
      */
      public PortWire updatePortWireRelationship(String userId,PortWire portWire)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updatePortWireRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = PortWireMapper.mapPortWireToOmrsRelationship(portWire);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        PortWire updatedPortWire = PortWireMapper.mapOmrsRelationshipToPortWire(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedPortWire;
    }
    /**
      * Create APIEndpoint relationships
      * @param userId user identity
      * @param relationships APIEndpoint relationships to create
      * @return created APIEndpoint relationships
      */
    public APIEndpoint createAPIEndpointRelationship(String userId,APIEndpoint relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createAPIEndpointRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = APIEndpointMapper.mapAPIEndpointToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        APIEndpoint returnedAPIEndpoint =  APIEndpointMapper.mapOmrsRelationshipToAPIEndpoint(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedAPIEndpoint;
    }
    /**
      * Get APIEndpoint relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return APIEndpoint relationships
      */
    public APIEndpoint getAPIEndpointRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getAPIEndpointRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            APIEndpoint gotAPIEndpoint = APIEndpointMapper.mapOmrsRelationshipToAPIEndpoint(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotAPIEndpoint;
      }
    /**
      * Update APIEndpoint relationships
      * @param userId user identity
      * @param aPIEndpoint relationships
      * @return  APIEndpoint relationships
      */
      public APIEndpoint updateAPIEndpointRelationship(String userId,APIEndpoint aPIEndpoint)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateAPIEndpointRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = APIEndpointMapper.mapAPIEndpointToOmrsRelationship(aPIEndpoint);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        APIEndpoint updatedAPIEndpoint = APIEndpointMapper.mapOmrsRelationshipToAPIEndpoint(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedAPIEndpoint;
    }
    /**
      * Create ProjectManagement relationships
      * @param userId user identity
      * @param relationships ProjectManagement relationships to create
      * @return created ProjectManagement relationships
      */
    public ProjectManagement createProjectManagementRelationship(String userId,ProjectManagement relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createProjectManagementRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = ProjectManagementMapper.mapProjectManagementToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        ProjectManagement returnedProjectManagement =  ProjectManagementMapper.mapOmrsRelationshipToProjectManagement(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedProjectManagement;
    }
    /**
      * Get ProjectManagement relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return ProjectManagement relationships
      */
    public ProjectManagement getProjectManagementRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getProjectManagementRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            ProjectManagement gotProjectManagement = ProjectManagementMapper.mapOmrsRelationshipToProjectManagement(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotProjectManagement;
      }
    /**
      * Update ProjectManagement relationships
      * @param userId user identity
      * @param projectManagement relationships
      * @return  ProjectManagement relationships
      */
      public ProjectManagement updateProjectManagementRelationship(String userId,ProjectManagement projectManagement)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateProjectManagementRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = ProjectManagementMapper.mapProjectManagementToOmrsRelationship(projectManagement);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        ProjectManagement updatedProjectManagement = ProjectManagementMapper.mapOmrsRelationshipToProjectManagement(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedProjectManagement;
    }
    /**
      * Create DataClassDefinition relationships
      * @param userId user identity
      * @param relationships DataClassDefinition relationships to create
      * @return created DataClassDefinition relationships
      */
    public DataClassDefinition createDataClassDefinitionRelationship(String userId,DataClassDefinition relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createDataClassDefinitionRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = DataClassDefinitionMapper.mapDataClassDefinitionToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        DataClassDefinition returnedDataClassDefinition =  DataClassDefinitionMapper.mapOmrsRelationshipToDataClassDefinition(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedDataClassDefinition;
    }
    /**
      * Get DataClassDefinition relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return DataClassDefinition relationships
      */
    public DataClassDefinition getDataClassDefinitionRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getDataClassDefinitionRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            DataClassDefinition gotDataClassDefinition = DataClassDefinitionMapper.mapOmrsRelationshipToDataClassDefinition(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotDataClassDefinition;
      }
    /**
      * Update DataClassDefinition relationships
      * @param userId user identity
      * @param dataClassDefinition relationships
      * @return  DataClassDefinition relationships
      */
      public DataClassDefinition updateDataClassDefinitionRelationship(String userId,DataClassDefinition dataClassDefinition)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateDataClassDefinitionRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = DataClassDefinitionMapper.mapDataClassDefinitionToOmrsRelationship(dataClassDefinition);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        DataClassDefinition updatedDataClassDefinition = DataClassDefinitionMapper.mapOmrsRelationshipToDataClassDefinition(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedDataClassDefinition;
    }
    /**
      * Create ConnectionEndpoint relationships
      * @param userId user identity
      * @param relationships ConnectionEndpoint relationships to create
      * @return created ConnectionEndpoint relationships
      */
    public ConnectionEndpoint createConnectionEndpointRelationship(String userId,ConnectionEndpoint relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createConnectionEndpointRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = ConnectionEndpointMapper.mapConnectionEndpointToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        ConnectionEndpoint returnedConnectionEndpoint =  ConnectionEndpointMapper.mapOmrsRelationshipToConnectionEndpoint(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedConnectionEndpoint;
    }
    /**
      * Get ConnectionEndpoint relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return ConnectionEndpoint relationships
      */
    public ConnectionEndpoint getConnectionEndpointRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getConnectionEndpointRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            ConnectionEndpoint gotConnectionEndpoint = ConnectionEndpointMapper.mapOmrsRelationshipToConnectionEndpoint(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotConnectionEndpoint;
      }
    /**
      * Update ConnectionEndpoint relationships
      * @param userId user identity
      * @param connectionEndpoint relationships
      * @return  ConnectionEndpoint relationships
      */
      public ConnectionEndpoint updateConnectionEndpointRelationship(String userId,ConnectionEndpoint connectionEndpoint)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateConnectionEndpointRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = ConnectionEndpointMapper.mapConnectionEndpointToOmrsRelationship(connectionEndpoint);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        ConnectionEndpoint updatedConnectionEndpoint = ConnectionEndpointMapper.mapOmrsRelationshipToConnectionEndpoint(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedConnectionEndpoint;
    }
    /**
      * Create CategoryAnchor relationships
      * @param userId user identity
      * @param relationships CategoryAnchor relationships to create
      * @return created CategoryAnchor relationships
      */
    public CategoryAnchor createCategoryAnchorRelationship(String userId,CategoryAnchor relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createCategoryAnchorRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = CategoryAnchorMapper.mapCategoryAnchorToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        CategoryAnchor returnedCategoryAnchor =  CategoryAnchorMapper.mapOmrsRelationshipToCategoryAnchor(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedCategoryAnchor;
    }
    /**
      * Get CategoryAnchor relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return CategoryAnchor relationships
      */
    public CategoryAnchor getCategoryAnchorRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getCategoryAnchorRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            CategoryAnchor gotCategoryAnchor = CategoryAnchorMapper.mapOmrsRelationshipToCategoryAnchor(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotCategoryAnchor;
      }
    /**
      * Update CategoryAnchor relationships
      * @param userId user identity
      * @param categoryAnchor relationships
      * @return  CategoryAnchor relationships
      */
      public CategoryAnchor updateCategoryAnchorRelationship(String userId,CategoryAnchor categoryAnchor)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateCategoryAnchorRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = CategoryAnchorMapper.mapCategoryAnchorToOmrsRelationship(categoryAnchor);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        CategoryAnchor updatedCategoryAnchor = CategoryAnchorMapper.mapOmrsRelationshipToCategoryAnchor(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedCategoryAnchor;
    }
    /**
      * Create ProjectTeam relationships
      * @param userId user identity
      * @param relationships ProjectTeam relationships to create
      * @return created ProjectTeam relationships
      */
    public ProjectTeam createProjectTeamRelationship(String userId,ProjectTeam relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createProjectTeamRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = ProjectTeamMapper.mapProjectTeamToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        ProjectTeam returnedProjectTeam =  ProjectTeamMapper.mapOmrsRelationshipToProjectTeam(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedProjectTeam;
    }
    /**
      * Get ProjectTeam relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return ProjectTeam relationships
      */
    public ProjectTeam getProjectTeamRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getProjectTeamRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            ProjectTeam gotProjectTeam = ProjectTeamMapper.mapOmrsRelationshipToProjectTeam(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotProjectTeam;
      }
    /**
      * Update ProjectTeam relationships
      * @param userId user identity
      * @param projectTeam relationships
      * @return  ProjectTeam relationships
      */
      public ProjectTeam updateProjectTeamRelationship(String userId,ProjectTeam projectTeam)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateProjectTeamRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = ProjectTeamMapper.mapProjectTeamToOmrsRelationship(projectTeam);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        ProjectTeam updatedProjectTeam = ProjectTeamMapper.mapOmrsRelationshipToProjectTeam(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedProjectTeam;
    }
    /**
      * Create APIOperations relationships
      * @param userId user identity
      * @param relationships APIOperations relationships to create
      * @return created APIOperations relationships
      */
    public APIOperations createAPIOperationsRelationship(String userId,APIOperations relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createAPIOperationsRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = APIOperationsMapper.mapAPIOperationsToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        APIOperations returnedAPIOperations =  APIOperationsMapper.mapOmrsRelationshipToAPIOperations(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedAPIOperations;
    }
    /**
      * Get APIOperations relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return APIOperations relationships
      */
    public APIOperations getAPIOperationsRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getAPIOperationsRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            APIOperations gotAPIOperations = APIOperationsMapper.mapOmrsRelationshipToAPIOperations(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotAPIOperations;
      }
    /**
      * Update APIOperations relationships
      * @param userId user identity
      * @param aPIOperations relationships
      * @return  APIOperations relationships
      */
      public APIOperations updateAPIOperationsRelationship(String userId,APIOperations aPIOperations)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateAPIOperationsRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = APIOperationsMapper.mapAPIOperationsToOmrsRelationship(aPIOperations);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        APIOperations updatedAPIOperations = APIOperationsMapper.mapOmrsRelationshipToAPIOperations(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedAPIOperations;
    }
    /**
      * Create RelationshipAnnotation relationships
      * @param userId user identity
      * @param relationships RelationshipAnnotation relationships to create
      * @return created RelationshipAnnotation relationships
      */
    public RelationshipAnnotation createRelationshipAnnotationRelationship(String userId,RelationshipAnnotation relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createRelationshipAnnotationRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = RelationshipAnnotationMapper.mapRelationshipAnnotationToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        RelationshipAnnotation returnedRelationshipAnnotation =  RelationshipAnnotationMapper.mapOmrsRelationshipToRelationshipAnnotation(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedRelationshipAnnotation;
    }
    /**
      * Get RelationshipAnnotation relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return RelationshipAnnotation relationships
      */
    public RelationshipAnnotation getRelationshipAnnotationRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getRelationshipAnnotationRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            RelationshipAnnotation gotRelationshipAnnotation = RelationshipAnnotationMapper.mapOmrsRelationshipToRelationshipAnnotation(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotRelationshipAnnotation;
      }
    /**
      * Update RelationshipAnnotation relationships
      * @param userId user identity
      * @param relationshipAnnotation relationships
      * @return  RelationshipAnnotation relationships
      */
      public RelationshipAnnotation updateRelationshipAnnotationRelationship(String userId,RelationshipAnnotation relationshipAnnotation)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateRelationshipAnnotationRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = RelationshipAnnotationMapper.mapRelationshipAnnotationToOmrsRelationship(relationshipAnnotation);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        RelationshipAnnotation updatedRelationshipAnnotation = RelationshipAnnotationMapper.mapOmrsRelationshipToRelationshipAnnotation(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedRelationshipAnnotation;
    }
    /**
      * Create GovernancePolicyLink relationships
      * @param userId user identity
      * @param relationships GovernancePolicyLink relationships to create
      * @return created GovernancePolicyLink relationships
      */
    public GovernancePolicyLink createGovernancePolicyLinkRelationship(String userId,GovernancePolicyLink relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createGovernancePolicyLinkRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = GovernancePolicyLinkMapper.mapGovernancePolicyLinkToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        GovernancePolicyLink returnedGovernancePolicyLink =  GovernancePolicyLinkMapper.mapOmrsRelationshipToGovernancePolicyLink(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedGovernancePolicyLink;
    }
    /**
      * Get GovernancePolicyLink relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return GovernancePolicyLink relationships
      */
    public GovernancePolicyLink getGovernancePolicyLinkRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getGovernancePolicyLinkRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            GovernancePolicyLink gotGovernancePolicyLink = GovernancePolicyLinkMapper.mapOmrsRelationshipToGovernancePolicyLink(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotGovernancePolicyLink;
      }
    /**
      * Update GovernancePolicyLink relationships
      * @param userId user identity
      * @param governancePolicyLink relationships
      * @return  GovernancePolicyLink relationships
      */
      public GovernancePolicyLink updateGovernancePolicyLinkRelationship(String userId,GovernancePolicyLink governancePolicyLink)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateGovernancePolicyLinkRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = GovernancePolicyLinkMapper.mapGovernancePolicyLinkToOmrsRelationship(governancePolicyLink);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        GovernancePolicyLink updatedGovernancePolicyLink = GovernancePolicyLinkMapper.mapOmrsRelationshipToGovernancePolicyLink(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedGovernancePolicyLink;
    }
    /**
      * Create ResponsibilityStaffContact relationships
      * @param userId user identity
      * @param relationships ResponsibilityStaffContact relationships to create
      * @return created ResponsibilityStaffContact relationships
      */
    public ResponsibilityStaffContact createResponsibilityStaffContactRelationship(String userId,ResponsibilityStaffContact relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createResponsibilityStaffContactRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = ResponsibilityStaffContactMapper.mapResponsibilityStaffContactToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        ResponsibilityStaffContact returnedResponsibilityStaffContact =  ResponsibilityStaffContactMapper.mapOmrsRelationshipToResponsibilityStaffContact(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedResponsibilityStaffContact;
    }
    /**
      * Get ResponsibilityStaffContact relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return ResponsibilityStaffContact relationships
      */
    public ResponsibilityStaffContact getResponsibilityStaffContactRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getResponsibilityStaffContactRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            ResponsibilityStaffContact gotResponsibilityStaffContact = ResponsibilityStaffContactMapper.mapOmrsRelationshipToResponsibilityStaffContact(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotResponsibilityStaffContact;
      }
    /**
      * Update ResponsibilityStaffContact relationships
      * @param userId user identity
      * @param responsibilityStaffContact relationships
      * @return  ResponsibilityStaffContact relationships
      */
      public ResponsibilityStaffContact updateResponsibilityStaffContactRelationship(String userId,ResponsibilityStaffContact responsibilityStaffContact)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateResponsibilityStaffContactRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = ResponsibilityStaffContactMapper.mapResponsibilityStaffContactToOmrsRelationship(responsibilityStaffContact);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        ResponsibilityStaffContact updatedResponsibilityStaffContact = ResponsibilityStaffContactMapper.mapOmrsRelationshipToResponsibilityStaffContact(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedResponsibilityStaffContact;
    }
    /**
      * Create DiscoveredDataField relationships
      * @param userId user identity
      * @param relationships DiscoveredDataField relationships to create
      * @return created DiscoveredDataField relationships
      */
    public DiscoveredDataField createDiscoveredDataFieldRelationship(String userId,DiscoveredDataField relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createDiscoveredDataFieldRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = DiscoveredDataFieldMapper.mapDiscoveredDataFieldToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        DiscoveredDataField returnedDiscoveredDataField =  DiscoveredDataFieldMapper.mapOmrsRelationshipToDiscoveredDataField(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedDiscoveredDataField;
    }
    /**
      * Get DiscoveredDataField relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return DiscoveredDataField relationships
      */
    public DiscoveredDataField getDiscoveredDataFieldRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getDiscoveredDataFieldRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            DiscoveredDataField gotDiscoveredDataField = DiscoveredDataFieldMapper.mapOmrsRelationshipToDiscoveredDataField(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotDiscoveredDataField;
      }
    /**
      * Update DiscoveredDataField relationships
      * @param userId user identity
      * @param discoveredDataField relationships
      * @return  DiscoveredDataField relationships
      */
      public DiscoveredDataField updateDiscoveredDataFieldRelationship(String userId,DiscoveredDataField discoveredDataField)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateDiscoveredDataFieldRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = DiscoveredDataFieldMapper.mapDiscoveredDataFieldToOmrsRelationship(discoveredDataField);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        DiscoveredDataField updatedDiscoveredDataField = DiscoveredDataFieldMapper.mapOmrsRelationshipToDiscoveredDataField(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedDiscoveredDataField;
    }
    /**
      * Create PersonRoleAppointment relationships
      * @param userId user identity
      * @param relationships PersonRoleAppointment relationships to create
      * @return created PersonRoleAppointment relationships
      */
    public PersonRoleAppointment createPersonRoleAppointmentRelationship(String userId,PersonRoleAppointment relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createPersonRoleAppointmentRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = PersonRoleAppointmentMapper.mapPersonRoleAppointmentToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        PersonRoleAppointment returnedPersonRoleAppointment =  PersonRoleAppointmentMapper.mapOmrsRelationshipToPersonRoleAppointment(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedPersonRoleAppointment;
    }
    /**
      * Get PersonRoleAppointment relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return PersonRoleAppointment relationships
      */
    public PersonRoleAppointment getPersonRoleAppointmentRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getPersonRoleAppointmentRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            PersonRoleAppointment gotPersonRoleAppointment = PersonRoleAppointmentMapper.mapOmrsRelationshipToPersonRoleAppointment(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotPersonRoleAppointment;
      }
    /**
      * Update PersonRoleAppointment relationships
      * @param userId user identity
      * @param personRoleAppointment relationships
      * @return  PersonRoleAppointment relationships
      */
      public PersonRoleAppointment updatePersonRoleAppointmentRelationship(String userId,PersonRoleAppointment personRoleAppointment)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updatePersonRoleAppointmentRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = PersonRoleAppointmentMapper.mapPersonRoleAppointmentToOmrsRelationship(personRoleAppointment);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        PersonRoleAppointment updatedPersonRoleAppointment = PersonRoleAppointmentMapper.mapOmrsRelationshipToPersonRoleAppointment(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedPersonRoleAppointment;
    }
    /**
      * Create AssetDiscoveryService relationships
      * @param userId user identity
      * @param relationships AssetDiscoveryService relationships to create
      * @return created AssetDiscoveryService relationships
      */
    public AssetDiscoveryService createAssetDiscoveryServiceRelationship(String userId,AssetDiscoveryService relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createAssetDiscoveryServiceRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = AssetDiscoveryServiceMapper.mapAssetDiscoveryServiceToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        AssetDiscoveryService returnedAssetDiscoveryService =  AssetDiscoveryServiceMapper.mapOmrsRelationshipToAssetDiscoveryService(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedAssetDiscoveryService;
    }
    /**
      * Get AssetDiscoveryService relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return AssetDiscoveryService relationships
      */
    public AssetDiscoveryService getAssetDiscoveryServiceRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getAssetDiscoveryServiceRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            AssetDiscoveryService gotAssetDiscoveryService = AssetDiscoveryServiceMapper.mapOmrsRelationshipToAssetDiscoveryService(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotAssetDiscoveryService;
      }
    /**
      * Update AssetDiscoveryService relationships
      * @param userId user identity
      * @param assetDiscoveryService relationships
      * @return  AssetDiscoveryService relationships
      */
      public AssetDiscoveryService updateAssetDiscoveryServiceRelationship(String userId,AssetDiscoveryService assetDiscoveryService)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateAssetDiscoveryServiceRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = AssetDiscoveryServiceMapper.mapAssetDiscoveryServiceToOmrsRelationship(assetDiscoveryService);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        AssetDiscoveryService updatedAssetDiscoveryService = AssetDiscoveryServiceMapper.mapOmrsRelationshipToAssetDiscoveryService(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedAssetDiscoveryService;
    }
    /**
      * Create Peer relationships
      * @param userId user identity
      * @param relationships Peer relationships to create
      * @return created Peer relationships
      */
    public Peer createPeerRelationship(String userId,Peer relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createPeerRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = PeerMapper.mapPeerToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        Peer returnedPeer =  PeerMapper.mapOmrsRelationshipToPeer(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedPeer;
    }
    /**
      * Get Peer relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return Peer relationships
      */
    public Peer getPeerRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getPeerRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            Peer gotPeer = PeerMapper.mapOmrsRelationshipToPeer(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotPeer;
      }
    /**
      * Update Peer relationships
      * @param userId user identity
      * @param peer relationships
      * @return  Peer relationships
      */
      public Peer updatePeerRelationship(String userId,Peer peer)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updatePeerRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = PeerMapper.mapPeerToOmrsRelationship(peer);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        Peer updatedPeer = PeerMapper.mapOmrsRelationshipToPeer(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedPeer;
    }
    /**
      * Create ActionAssignment relationships
      * @param userId user identity
      * @param relationships ActionAssignment relationships to create
      * @return created ActionAssignment relationships
      */
    public ActionAssignment createActionAssignmentRelationship(String userId,ActionAssignment relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createActionAssignmentRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = ActionAssignmentMapper.mapActionAssignmentToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        ActionAssignment returnedActionAssignment =  ActionAssignmentMapper.mapOmrsRelationshipToActionAssignment(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedActionAssignment;
    }
    /**
      * Get ActionAssignment relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return ActionAssignment relationships
      */
    public ActionAssignment getActionAssignmentRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getActionAssignmentRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            ActionAssignment gotActionAssignment = ActionAssignmentMapper.mapOmrsRelationshipToActionAssignment(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotActionAssignment;
      }
    /**
      * Update ActionAssignment relationships
      * @param userId user identity
      * @param actionAssignment relationships
      * @return  ActionAssignment relationships
      */
      public ActionAssignment updateActionAssignmentRelationship(String userId,ActionAssignment actionAssignment)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateActionAssignmentRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = ActionAssignmentMapper.mapActionAssignmentToOmrsRelationship(actionAssignment);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        ActionAssignment updatedActionAssignment = ActionAssignmentMapper.mapOmrsRelationshipToActionAssignment(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedActionAssignment;
    }
    /**
      * Create TermTYPEDBYRelationship relationships
      * @param userId user identity
      * @param relationships TermTYPEDBYRelationship relationships to create
      * @return created TermTYPEDBYRelationship relationships
      */
    public TermTYPEDBYRelationship createTermTYPEDBYRelationshipRelationship(String userId,TermTYPEDBYRelationship relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createTermTYPEDBYRelationshipRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = TermTYPEDBYRelationshipMapper.mapTermTYPEDBYRelationshipToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        TermTYPEDBYRelationship returnedTermTYPEDBYRelationship =  TermTYPEDBYRelationshipMapper.mapOmrsRelationshipToTermTYPEDBYRelationship(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedTermTYPEDBYRelationship;
    }
    /**
      * Get TermTYPEDBYRelationship relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return TermTYPEDBYRelationship relationships
      */
    public TermTYPEDBYRelationship getTermTYPEDBYRelationshipRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getTermTYPEDBYRelationshipRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            TermTYPEDBYRelationship gotTermTYPEDBYRelationship = TermTYPEDBYRelationshipMapper.mapOmrsRelationshipToTermTYPEDBYRelationship(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotTermTYPEDBYRelationship;
      }
    /**
      * Update TermTYPEDBYRelationship relationships
      * @param userId user identity
      * @param termTYPEDBYRelationship relationships
      * @return  TermTYPEDBYRelationship relationships
      */
      public TermTYPEDBYRelationship updateTermTYPEDBYRelationshipRelationship(String userId,TermTYPEDBYRelationship termTYPEDBYRelationship)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateTermTYPEDBYRelationshipRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = TermTYPEDBYRelationshipMapper.mapTermTYPEDBYRelationshipToOmrsRelationship(termTYPEDBYRelationship);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        TermTYPEDBYRelationship updatedTermTYPEDBYRelationship = TermTYPEDBYRelationshipMapper.mapOmrsRelationshipToTermTYPEDBYRelationship(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedTermTYPEDBYRelationship;
    }
    /**
      * Create MapFromElementType relationships
      * @param userId user identity
      * @param relationships MapFromElementType relationships to create
      * @return created MapFromElementType relationships
      */
    public MapFromElementType createMapFromElementTypeRelationship(String userId,MapFromElementType relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createMapFromElementTypeRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = MapFromElementTypeMapper.mapMapFromElementTypeToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        MapFromElementType returnedMapFromElementType =  MapFromElementTypeMapper.mapOmrsRelationshipToMapFromElementType(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedMapFromElementType;
    }
    /**
      * Get MapFromElementType relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return MapFromElementType relationships
      */
    public MapFromElementType getMapFromElementTypeRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getMapFromElementTypeRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            MapFromElementType gotMapFromElementType = MapFromElementTypeMapper.mapOmrsRelationshipToMapFromElementType(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotMapFromElementType;
      }
    /**
      * Update MapFromElementType relationships
      * @param userId user identity
      * @param mapFromElementType relationships
      * @return  MapFromElementType relationships
      */
      public MapFromElementType updateMapFromElementTypeRelationship(String userId,MapFromElementType mapFromElementType)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateMapFromElementTypeRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = MapFromElementTypeMapper.mapMapFromElementTypeToOmrsRelationship(mapFromElementType);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        MapFromElementType updatedMapFromElementType = MapFromElementTypeMapper.mapOmrsRelationshipToMapFromElementType(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedMapFromElementType;
    }
    /**
      * Create SchemaTypeDefinition relationships
      * @param userId user identity
      * @param relationships SchemaTypeDefinition relationships to create
      * @return created SchemaTypeDefinition relationships
      */
    public SchemaTypeDefinition createSchemaTypeDefinitionRelationship(String userId,SchemaTypeDefinition relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createSchemaTypeDefinitionRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = SchemaTypeDefinitionMapper.mapSchemaTypeDefinitionToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        SchemaTypeDefinition returnedSchemaTypeDefinition =  SchemaTypeDefinitionMapper.mapOmrsRelationshipToSchemaTypeDefinition(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedSchemaTypeDefinition;
    }
    /**
      * Get SchemaTypeDefinition relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return SchemaTypeDefinition relationships
      */
    public SchemaTypeDefinition getSchemaTypeDefinitionRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getSchemaTypeDefinitionRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            SchemaTypeDefinition gotSchemaTypeDefinition = SchemaTypeDefinitionMapper.mapOmrsRelationshipToSchemaTypeDefinition(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotSchemaTypeDefinition;
      }
    /**
      * Update SchemaTypeDefinition relationships
      * @param userId user identity
      * @param schemaTypeDefinition relationships
      * @return  SchemaTypeDefinition relationships
      */
      public SchemaTypeDefinition updateSchemaTypeDefinitionRelationship(String userId,SchemaTypeDefinition schemaTypeDefinition)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateSchemaTypeDefinitionRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = SchemaTypeDefinitionMapper.mapSchemaTypeDefinitionToOmrsRelationship(schemaTypeDefinition);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        SchemaTypeDefinition updatedSchemaTypeDefinition = SchemaTypeDefinitionMapper.mapOmrsRelationshipToSchemaTypeDefinition(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedSchemaTypeDefinition;
    }
    /**
      * Create AssetWire relationships
      * @param userId user identity
      * @param relationships AssetWire relationships to create
      * @return created AssetWire relationships
      */
    public AssetWire createAssetWireRelationship(String userId,AssetWire relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createAssetWireRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = AssetWireMapper.mapAssetWireToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        AssetWire returnedAssetWire =  AssetWireMapper.mapOmrsRelationshipToAssetWire(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedAssetWire;
    }
    /**
      * Get AssetWire relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return AssetWire relationships
      */
    public AssetWire getAssetWireRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getAssetWireRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            AssetWire gotAssetWire = AssetWireMapper.mapOmrsRelationshipToAssetWire(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotAssetWire;
      }
    /**
      * Update AssetWire relationships
      * @param userId user identity
      * @param assetWire relationships
      * @return  AssetWire relationships
      */
      public AssetWire updateAssetWireRelationship(String userId,AssetWire assetWire)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateAssetWireRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = AssetWireMapper.mapAssetWireToOmrsRelationship(assetWire);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        AssetWire updatedAssetWire = AssetWireMapper.mapOmrsRelationshipToAssetWire(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedAssetWire;
    }
    /**
      * Create Certification relationships
      * @param userId user identity
      * @param relationships Certification relationships to create
      * @return created Certification relationships
      */
    public Certification createCertificationRelationship(String userId,Certification relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createCertificationRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = CertificationMapper.mapCertificationToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        Certification returnedCertification =  CertificationMapper.mapOmrsRelationshipToCertification(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedCertification;
    }
    /**
      * Get Certification relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return Certification relationships
      */
    public Certification getCertificationRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getCertificationRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            Certification gotCertification = CertificationMapper.mapOmrsRelationshipToCertification(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotCertification;
      }
    /**
      * Update Certification relationships
      * @param userId user identity
      * @param certification relationships
      * @return  Certification relationships
      */
      public Certification updateCertificationRelationship(String userId,Certification certification)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateCertificationRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = CertificationMapper.mapCertificationToOmrsRelationship(certification);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        Certification updatedCertification = CertificationMapper.mapOmrsRelationshipToCertification(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedCertification;
    }
    /**
      * Create GovernancePost relationships
      * @param userId user identity
      * @param relationships GovernancePost relationships to create
      * @return created GovernancePost relationships
      */
    public GovernancePost createGovernancePostRelationship(String userId,GovernancePost relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createGovernancePostRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = GovernancePostMapper.mapGovernancePostToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        GovernancePost returnedGovernancePost =  GovernancePostMapper.mapOmrsRelationshipToGovernancePost(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedGovernancePost;
    }
    /**
      * Get GovernancePost relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return GovernancePost relationships
      */
    public GovernancePost getGovernancePostRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getGovernancePostRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            GovernancePost gotGovernancePost = GovernancePostMapper.mapOmrsRelationshipToGovernancePost(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotGovernancePost;
      }
    /**
      * Update GovernancePost relationships
      * @param userId user identity
      * @param governancePost relationships
      * @return  GovernancePost relationships
      */
      public GovernancePost updateGovernancePostRelationship(String userId,GovernancePost governancePost)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateGovernancePostRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = GovernancePostMapper.mapGovernancePostToOmrsRelationship(governancePost);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        GovernancePost updatedGovernancePost = GovernancePostMapper.mapOmrsRelationshipToGovernancePost(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedGovernancePost;
    }
    /**
      * Create NetworkGatewayLink relationships
      * @param userId user identity
      * @param relationships NetworkGatewayLink relationships to create
      * @return created NetworkGatewayLink relationships
      */
    public NetworkGatewayLink createNetworkGatewayLinkRelationship(String userId,NetworkGatewayLink relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createNetworkGatewayLinkRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = NetworkGatewayLinkMapper.mapNetworkGatewayLinkToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        NetworkGatewayLink returnedNetworkGatewayLink =  NetworkGatewayLinkMapper.mapOmrsRelationshipToNetworkGatewayLink(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedNetworkGatewayLink;
    }
    /**
      * Get NetworkGatewayLink relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return NetworkGatewayLink relationships
      */
    public NetworkGatewayLink getNetworkGatewayLinkRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getNetworkGatewayLinkRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            NetworkGatewayLink gotNetworkGatewayLink = NetworkGatewayLinkMapper.mapOmrsRelationshipToNetworkGatewayLink(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotNetworkGatewayLink;
      }
    /**
      * Update NetworkGatewayLink relationships
      * @param userId user identity
      * @param networkGatewayLink relationships
      * @return  NetworkGatewayLink relationships
      */
      public NetworkGatewayLink updateNetworkGatewayLinkRelationship(String userId,NetworkGatewayLink networkGatewayLink)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateNetworkGatewayLinkRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = NetworkGatewayLinkMapper.mapNetworkGatewayLinkToOmrsRelationship(networkGatewayLink);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        NetworkGatewayLink updatedNetworkGatewayLink = NetworkGatewayLinkMapper.mapOmrsRelationshipToNetworkGatewayLink(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedNetworkGatewayLink;
    }
    /**
      * Create GovernanceResponsibilityAssignment relationships
      * @param userId user identity
      * @param relationships GovernanceResponsibilityAssignment relationships to create
      * @return created GovernanceResponsibilityAssignment relationships
      */
    public GovernanceResponsibilityAssignment createGovernanceResponsibilityAssignmentRelationship(String userId,GovernanceResponsibilityAssignment relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createGovernanceResponsibilityAssignmentRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = GovernanceResponsibilityAssignmentMapper.mapGovernanceResponsibilityAssignmentToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        GovernanceResponsibilityAssignment returnedGovernanceResponsibilityAssignment =  GovernanceResponsibilityAssignmentMapper.mapOmrsRelationshipToGovernanceResponsibilityAssignment(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedGovernanceResponsibilityAssignment;
    }
    /**
      * Get GovernanceResponsibilityAssignment relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return GovernanceResponsibilityAssignment relationships
      */
    public GovernanceResponsibilityAssignment getGovernanceResponsibilityAssignmentRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getGovernanceResponsibilityAssignmentRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            GovernanceResponsibilityAssignment gotGovernanceResponsibilityAssignment = GovernanceResponsibilityAssignmentMapper.mapOmrsRelationshipToGovernanceResponsibilityAssignment(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotGovernanceResponsibilityAssignment;
      }
    /**
      * Update GovernanceResponsibilityAssignment relationships
      * @param userId user identity
      * @param governanceResponsibilityAssignment relationships
      * @return  GovernanceResponsibilityAssignment relationships
      */
      public GovernanceResponsibilityAssignment updateGovernanceResponsibilityAssignmentRelationship(String userId,GovernanceResponsibilityAssignment governanceResponsibilityAssignment)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateGovernanceResponsibilityAssignmentRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = GovernanceResponsibilityAssignmentMapper.mapGovernanceResponsibilityAssignmentToOmrsRelationship(governanceResponsibilityAssignment);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        GovernanceResponsibilityAssignment updatedGovernanceResponsibilityAssignment = GovernanceResponsibilityAssignmentMapper.mapOmrsRelationshipToGovernanceResponsibilityAssignment(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedGovernanceResponsibilityAssignment;
    }
    /**
      * Create ConnectionConnectorType relationships
      * @param userId user identity
      * @param relationships ConnectionConnectorType relationships to create
      * @return created ConnectionConnectorType relationships
      */
    public ConnectionConnectorType createConnectionConnectorTypeRelationship(String userId,ConnectionConnectorType relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createConnectionConnectorTypeRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = ConnectionConnectorTypeMapper.mapConnectionConnectorTypeToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        ConnectionConnectorType returnedConnectionConnectorType =  ConnectionConnectorTypeMapper.mapOmrsRelationshipToConnectionConnectorType(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedConnectionConnectorType;
    }
    /**
      * Get ConnectionConnectorType relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return ConnectionConnectorType relationships
      */
    public ConnectionConnectorType getConnectionConnectorTypeRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getConnectionConnectorTypeRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            ConnectionConnectorType gotConnectionConnectorType = ConnectionConnectorTypeMapper.mapOmrsRelationshipToConnectionConnectorType(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotConnectionConnectorType;
      }
    /**
      * Update ConnectionConnectorType relationships
      * @param userId user identity
      * @param connectionConnectorType relationships
      * @return  ConnectionConnectorType relationships
      */
      public ConnectionConnectorType updateConnectionConnectorTypeRelationship(String userId,ConnectionConnectorType connectionConnectorType)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateConnectionConnectorTypeRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = ConnectionConnectorTypeMapper.mapConnectionConnectorTypeToOmrsRelationship(connectionConnectorType);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        ConnectionConnectorType updatedConnectionConnectorType = ConnectionConnectorTypeMapper.mapOmrsRelationshipToConnectionConnectorType(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedConnectionConnectorType;
    }
    /**
      * Create Synonym relationships
      * @param userId user identity
      * @param relationships Synonym relationships to create
      * @return created Synonym relationships
      */
    public Synonym createSynonymRelationship(String userId,Synonym relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createSynonymRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = SynonymMapper.mapSynonymToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        Synonym returnedSynonym =  SynonymMapper.mapOmrsRelationshipToSynonym(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedSynonym;
    }
    /**
      * Get Synonym relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return Synonym relationships
      */
    public Synonym getSynonymRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getSynonymRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            Synonym gotSynonym = SynonymMapper.mapOmrsRelationshipToSynonym(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotSynonym;
      }
    /**
      * Update Synonym relationships
      * @param userId user identity
      * @param synonym relationships
      * @return  Synonym relationships
      */
      public Synonym updateSynonymRelationship(String userId,Synonym synonym)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateSynonymRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = SynonymMapper.mapSynonymToOmrsRelationship(synonym);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        Synonym updatedSynonym = SynonymMapper.mapOmrsRelationshipToSynonym(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedSynonym;
    }
    /**
      * Create Antonym relationships
      * @param userId user identity
      * @param relationships Antonym relationships to create
      * @return created Antonym relationships
      */
    public Antonym createAntonymRelationship(String userId,Antonym relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createAntonymRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = AntonymMapper.mapAntonymToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        Antonym returnedAntonym =  AntonymMapper.mapOmrsRelationshipToAntonym(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedAntonym;
    }
    /**
      * Get Antonym relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return Antonym relationships
      */
    public Antonym getAntonymRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getAntonymRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            Antonym gotAntonym = AntonymMapper.mapOmrsRelationshipToAntonym(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotAntonym;
      }
    /**
      * Update Antonym relationships
      * @param userId user identity
      * @param antonym relationships
      * @return  Antonym relationships
      */
      public Antonym updateAntonymRelationship(String userId,Antonym antonym)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateAntonymRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = AntonymMapper.mapAntonymToOmrsRelationship(antonym);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        Antonym updatedAntonym = AntonymMapper.mapOmrsRelationshipToAntonym(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedAntonym;
    }
    /**
      * Create GraphEdgeLink relationships
      * @param userId user identity
      * @param relationships GraphEdgeLink relationships to create
      * @return created GraphEdgeLink relationships
      */
    public GraphEdgeLink createGraphEdgeLinkRelationship(String userId,GraphEdgeLink relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createGraphEdgeLinkRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = GraphEdgeLinkMapper.mapGraphEdgeLinkToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        GraphEdgeLink returnedGraphEdgeLink =  GraphEdgeLinkMapper.mapOmrsRelationshipToGraphEdgeLink(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedGraphEdgeLink;
    }
    /**
      * Get GraphEdgeLink relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return GraphEdgeLink relationships
      */
    public GraphEdgeLink getGraphEdgeLinkRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getGraphEdgeLinkRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            GraphEdgeLink gotGraphEdgeLink = GraphEdgeLinkMapper.mapOmrsRelationshipToGraphEdgeLink(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotGraphEdgeLink;
      }
    /**
      * Update GraphEdgeLink relationships
      * @param userId user identity
      * @param graphEdgeLink relationships
      * @return  GraphEdgeLink relationships
      */
      public GraphEdgeLink updateGraphEdgeLinkRelationship(String userId,GraphEdgeLink graphEdgeLink)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateGraphEdgeLinkRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = GraphEdgeLinkMapper.mapGraphEdgeLinkToOmrsRelationship(graphEdgeLink);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        GraphEdgeLink updatedGraphEdgeLink = GraphEdgeLinkMapper.mapOmrsRelationshipToGraphEdgeLink(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedGraphEdgeLink;
    }
    /**
      * Create ProjectScope relationships
      * @param userId user identity
      * @param relationships ProjectScope relationships to create
      * @return created ProjectScope relationships
      */
    public ProjectScope createProjectScopeRelationship(String userId,ProjectScope relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createProjectScopeRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = ProjectScopeMapper.mapProjectScopeToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        ProjectScope returnedProjectScope =  ProjectScopeMapper.mapOmrsRelationshipToProjectScope(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedProjectScope;
    }
    /**
      * Get ProjectScope relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return ProjectScope relationships
      */
    public ProjectScope getProjectScopeRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getProjectScopeRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            ProjectScope gotProjectScope = ProjectScopeMapper.mapOmrsRelationshipToProjectScope(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotProjectScope;
      }
    /**
      * Update ProjectScope relationships
      * @param userId user identity
      * @param projectScope relationships
      * @return  ProjectScope relationships
      */
      public ProjectScope updateProjectScopeRelationship(String userId,ProjectScope projectScope)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateProjectScopeRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = ProjectScopeMapper.mapProjectScopeToOmrsRelationship(projectScope);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        ProjectScope updatedProjectScope = ProjectScopeMapper.mapOmrsRelationshipToProjectScope(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedProjectScope;
    }
    /**
      * Create ISARelationship relationships
      * @param userId user identity
      * @param relationships ISARelationship relationships to create
      * @return created ISARelationship relationships
      */
    public ISARelationship createISARelationshipRelationship(String userId,ISARelationship relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createISARelationshipRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = ISARelationshipMapper.mapISARelationshipToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        ISARelationship returnedISARelationship =  ISARelationshipMapper.mapOmrsRelationshipToISARelationship(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedISARelationship;
    }
    /**
      * Get ISARelationship relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return ISARelationship relationships
      */
    public ISARelationship getISARelationshipRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getISARelationshipRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            ISARelationship gotISARelationship = ISARelationshipMapper.mapOmrsRelationshipToISARelationship(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotISARelationship;
      }
    /**
      * Update ISARelationship relationships
      * @param userId user identity
      * @param iSARelationship relationships
      * @return  ISARelationship relationships
      */
      public ISARelationship updateISARelationshipRelationship(String userId,ISARelationship iSARelationship)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateISARelationshipRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = ISARelationshipMapper.mapISARelationshipToOmrsRelationship(iSARelationship);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        ISARelationship updatedISARelationship = ISARelationshipMapper.mapOmrsRelationshipToISARelationship(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedISARelationship;
    }
    /**
      * Create TermISATypeOFRelationship relationships
      * @param userId user identity
      * @param relationships TermISATypeOFRelationship relationships to create
      * @return created TermISATypeOFRelationship relationships
      */
    public TermISATypeOFRelationship createTermISATypeOFRelationshipRelationship(String userId,TermISATypeOFRelationship relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createTermISATypeOFRelationshipRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = TermISATypeOFRelationshipMapper.mapTermISATypeOFRelationshipToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        TermISATypeOFRelationship returnedTermISATypeOFRelationship =  TermISATypeOFRelationshipMapper.mapOmrsRelationshipToTermISATypeOFRelationship(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedTermISATypeOFRelationship;
    }
    /**
      * Get TermISATypeOFRelationship relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return TermISATypeOFRelationship relationships
      */
    public TermISATypeOFRelationship getTermISATypeOFRelationshipRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getTermISATypeOFRelationshipRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            TermISATypeOFRelationship gotTermISATypeOFRelationship = TermISATypeOFRelationshipMapper.mapOmrsRelationshipToTermISATypeOFRelationship(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotTermISATypeOFRelationship;
      }
    /**
      * Update TermISATypeOFRelationship relationships
      * @param userId user identity
      * @param termISATypeOFRelationship relationships
      * @return  TermISATypeOFRelationship relationships
      */
      public TermISATypeOFRelationship updateTermISATypeOFRelationshipRelationship(String userId,TermISATypeOFRelationship termISATypeOFRelationship)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateTermISATypeOFRelationshipRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = TermISATypeOFRelationshipMapper.mapTermISATypeOFRelationshipToOmrsRelationship(termISATypeOFRelationship);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        TermISATypeOFRelationship updatedTermISATypeOFRelationship = TermISATypeOFRelationshipMapper.mapOmrsRelationshipToTermISATypeOFRelationship(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedTermISATypeOFRelationship;
    }
    /**
      * Create Meetings relationships
      * @param userId user identity
      * @param relationships Meetings relationships to create
      * @return created Meetings relationships
      */
    public Meetings createMeetingsRelationship(String userId,Meetings relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createMeetingsRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = MeetingsMapper.mapMeetingsToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        Meetings returnedMeetings =  MeetingsMapper.mapOmrsRelationshipToMeetings(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedMeetings;
    }
    /**
      * Get Meetings relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return Meetings relationships
      */
    public Meetings getMeetingsRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getMeetingsRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            Meetings gotMeetings = MeetingsMapper.mapOmrsRelationshipToMeetings(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotMeetings;
      }
    /**
      * Update Meetings relationships
      * @param userId user identity
      * @param meetings relationships
      * @return  Meetings relationships
      */
      public Meetings updateMeetingsRelationship(String userId,Meetings meetings)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateMeetingsRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = MeetingsMapper.mapMeetingsToOmrsRelationship(meetings);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        Meetings updatedMeetings = MeetingsMapper.mapOmrsRelationshipToMeetings(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedMeetings;
    }
    /**
      * Create EmbeddedConnection relationships
      * @param userId user identity
      * @param relationships EmbeddedConnection relationships to create
      * @return created EmbeddedConnection relationships
      */
    public EmbeddedConnection createEmbeddedConnectionRelationship(String userId,EmbeddedConnection relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createEmbeddedConnectionRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = EmbeddedConnectionMapper.mapEmbeddedConnectionToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        EmbeddedConnection returnedEmbeddedConnection =  EmbeddedConnectionMapper.mapOmrsRelationshipToEmbeddedConnection(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedEmbeddedConnection;
    }
    /**
      * Get EmbeddedConnection relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return EmbeddedConnection relationships
      */
    public EmbeddedConnection getEmbeddedConnectionRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getEmbeddedConnectionRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            EmbeddedConnection gotEmbeddedConnection = EmbeddedConnectionMapper.mapOmrsRelationshipToEmbeddedConnection(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotEmbeddedConnection;
      }
    /**
      * Update EmbeddedConnection relationships
      * @param userId user identity
      * @param embeddedConnection relationships
      * @return  EmbeddedConnection relationships
      */
      public EmbeddedConnection updateEmbeddedConnectionRelationship(String userId,EmbeddedConnection embeddedConnection)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateEmbeddedConnectionRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = EmbeddedConnectionMapper.mapEmbeddedConnectionToOmrsRelationship(embeddedConnection);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        EmbeddedConnection updatedEmbeddedConnection = EmbeddedConnectionMapper.mapOmrsRelationshipToEmbeddedConnection(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedEmbeddedConnection;
    }
    /**
      * Create GovernanceControlLink relationships
      * @param userId user identity
      * @param relationships GovernanceControlLink relationships to create
      * @return created GovernanceControlLink relationships
      */
    public GovernanceControlLink createGovernanceControlLinkRelationship(String userId,GovernanceControlLink relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createGovernanceControlLinkRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = GovernanceControlLinkMapper.mapGovernanceControlLinkToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        GovernanceControlLink returnedGovernanceControlLink =  GovernanceControlLinkMapper.mapOmrsRelationshipToGovernanceControlLink(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedGovernanceControlLink;
    }
    /**
      * Get GovernanceControlLink relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return GovernanceControlLink relationships
      */
    public GovernanceControlLink getGovernanceControlLinkRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getGovernanceControlLinkRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            GovernanceControlLink gotGovernanceControlLink = GovernanceControlLinkMapper.mapOmrsRelationshipToGovernanceControlLink(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotGovernanceControlLink;
      }
    /**
      * Update GovernanceControlLink relationships
      * @param userId user identity
      * @param governanceControlLink relationships
      * @return  GovernanceControlLink relationships
      */
      public GovernanceControlLink updateGovernanceControlLinkRelationship(String userId,GovernanceControlLink governanceControlLink)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateGovernanceControlLinkRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = GovernanceControlLinkMapper.mapGovernanceControlLinkToOmrsRelationship(governanceControlLink);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        GovernanceControlLink updatedGovernanceControlLink = GovernanceControlLinkMapper.mapOmrsRelationshipToGovernanceControlLink(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedGovernanceControlLink;
    }
    /**
      * Create AttachedRating relationships
      * @param userId user identity
      * @param relationships AttachedRating relationships to create
      * @return created AttachedRating relationships
      */
    public AttachedRating createAttachedRatingRelationship(String userId,AttachedRating relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createAttachedRatingRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = AttachedRatingMapper.mapAttachedRatingToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        AttachedRating returnedAttachedRating =  AttachedRatingMapper.mapOmrsRelationshipToAttachedRating(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedAttachedRating;
    }
    /**
      * Get AttachedRating relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return AttachedRating relationships
      */
    public AttachedRating getAttachedRatingRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getAttachedRatingRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            AttachedRating gotAttachedRating = AttachedRatingMapper.mapOmrsRelationshipToAttachedRating(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotAttachedRating;
      }
    /**
      * Update AttachedRating relationships
      * @param userId user identity
      * @param attachedRating relationships
      * @return  AttachedRating relationships
      */
      public AttachedRating updateAttachedRatingRelationship(String userId,AttachedRating attachedRating)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateAttachedRatingRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = AttachedRatingMapper.mapAttachedRatingToOmrsRelationship(attachedRating);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        AttachedRating updatedAttachedRating = AttachedRatingMapper.mapOmrsRelationshipToAttachedRating(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedAttachedRating;
    }
    /**
      * Create DataClassAssignment relationships
      * @param userId user identity
      * @param relationships DataClassAssignment relationships to create
      * @return created DataClassAssignment relationships
      */
    public DataClassAssignment createDataClassAssignmentRelationship(String userId,DataClassAssignment relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createDataClassAssignmentRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = DataClassAssignmentMapper.mapDataClassAssignmentToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        DataClassAssignment returnedDataClassAssignment =  DataClassAssignmentMapper.mapOmrsRelationshipToDataClassAssignment(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedDataClassAssignment;
    }
    /**
      * Get DataClassAssignment relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return DataClassAssignment relationships
      */
    public DataClassAssignment getDataClassAssignmentRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getDataClassAssignmentRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            DataClassAssignment gotDataClassAssignment = DataClassAssignmentMapper.mapOmrsRelationshipToDataClassAssignment(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotDataClassAssignment;
      }
    /**
      * Update DataClassAssignment relationships
      * @param userId user identity
      * @param dataClassAssignment relationships
      * @return  DataClassAssignment relationships
      */
      public DataClassAssignment updateDataClassAssignmentRelationship(String userId,DataClassAssignment dataClassAssignment)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateDataClassAssignmentRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = DataClassAssignmentMapper.mapDataClassAssignmentToOmrsRelationship(dataClassAssignment);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        DataClassAssignment updatedDataClassAssignment = DataClassAssignmentMapper.mapOmrsRelationshipToDataClassAssignment(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedDataClassAssignment;
    }
    /**
      * Create AttachedNoteLog relationships
      * @param userId user identity
      * @param relationships AttachedNoteLog relationships to create
      * @return created AttachedNoteLog relationships
      */
    public AttachedNoteLog createAttachedNoteLogRelationship(String userId,AttachedNoteLog relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createAttachedNoteLogRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = AttachedNoteLogMapper.mapAttachedNoteLogToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        AttachedNoteLog returnedAttachedNoteLog =  AttachedNoteLogMapper.mapOmrsRelationshipToAttachedNoteLog(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedAttachedNoteLog;
    }
    /**
      * Get AttachedNoteLog relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return AttachedNoteLog relationships
      */
    public AttachedNoteLog getAttachedNoteLogRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getAttachedNoteLogRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            AttachedNoteLog gotAttachedNoteLog = AttachedNoteLogMapper.mapOmrsRelationshipToAttachedNoteLog(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotAttachedNoteLog;
      }
    /**
      * Update AttachedNoteLog relationships
      * @param userId user identity
      * @param attachedNoteLog relationships
      * @return  AttachedNoteLog relationships
      */
      public AttachedNoteLog updateAttachedNoteLogRelationship(String userId,AttachedNoteLog attachedNoteLog)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateAttachedNoteLogRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = AttachedNoteLogMapper.mapAttachedNoteLogToOmrsRelationship(attachedNoteLog);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        AttachedNoteLog updatedAttachedNoteLog = AttachedNoteLogMapper.mapOmrsRelationshipToAttachedNoteLog(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedAttachedNoteLog;
    }
    /**
      * Create ConnectionToAsset relationships
      * @param userId user identity
      * @param relationships ConnectionToAsset relationships to create
      * @return created ConnectionToAsset relationships
      */
    public ConnectionToAsset createConnectionToAssetRelationship(String userId,ConnectionToAsset relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createConnectionToAssetRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = ConnectionToAssetMapper.mapConnectionToAssetToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        ConnectionToAsset returnedConnectionToAsset =  ConnectionToAssetMapper.mapOmrsRelationshipToConnectionToAsset(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedConnectionToAsset;
    }
    /**
      * Get ConnectionToAsset relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return ConnectionToAsset relationships
      */
    public ConnectionToAsset getConnectionToAssetRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getConnectionToAssetRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            ConnectionToAsset gotConnectionToAsset = ConnectionToAssetMapper.mapOmrsRelationshipToConnectionToAsset(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotConnectionToAsset;
      }
    /**
      * Update ConnectionToAsset relationships
      * @param userId user identity
      * @param connectionToAsset relationships
      * @return  ConnectionToAsset relationships
      */
      public ConnectionToAsset updateConnectionToAssetRelationship(String userId,ConnectionToAsset connectionToAsset)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateConnectionToAssetRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = ConnectionToAssetMapper.mapConnectionToAssetToOmrsRelationship(connectionToAsset);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        ConnectionToAsset updatedConnectionToAsset = ConnectionToAssetMapper.mapOmrsRelationshipToConnectionToAsset(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedConnectionToAsset;
    }
    /**
      * Create RegulationCertificationType relationships
      * @param userId user identity
      * @param relationships RegulationCertificationType relationships to create
      * @return created RegulationCertificationType relationships
      */
    public RegulationCertificationType createRegulationCertificationTypeRelationship(String userId,RegulationCertificationType relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createRegulationCertificationTypeRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = RegulationCertificationTypeMapper.mapRegulationCertificationTypeToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        RegulationCertificationType returnedRegulationCertificationType =  RegulationCertificationTypeMapper.mapOmrsRelationshipToRegulationCertificationType(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedRegulationCertificationType;
    }
    /**
      * Get RegulationCertificationType relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return RegulationCertificationType relationships
      */
    public RegulationCertificationType getRegulationCertificationTypeRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getRegulationCertificationTypeRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            RegulationCertificationType gotRegulationCertificationType = RegulationCertificationTypeMapper.mapOmrsRelationshipToRegulationCertificationType(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotRegulationCertificationType;
      }
    /**
      * Update RegulationCertificationType relationships
      * @param userId user identity
      * @param regulationCertificationType relationships
      * @return  RegulationCertificationType relationships
      */
      public RegulationCertificationType updateRegulationCertificationTypeRelationship(String userId,RegulationCertificationType regulationCertificationType)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateRegulationCertificationTypeRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = RegulationCertificationTypeMapper.mapRegulationCertificationTypeToOmrsRelationship(regulationCertificationType);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        RegulationCertificationType updatedRegulationCertificationType = RegulationCertificationTypeMapper.mapOmrsRelationshipToRegulationCertificationType(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedRegulationCertificationType;
    }
    /**
      * Create LinkedType relationships
      * @param userId user identity
      * @param relationships LinkedType relationships to create
      * @return created LinkedType relationships
      */
    public LinkedType createLinkedTypeRelationship(String userId,LinkedType relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createLinkedTypeRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = LinkedTypeMapper.mapLinkedTypeToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        LinkedType returnedLinkedType =  LinkedTypeMapper.mapOmrsRelationshipToLinkedType(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedLinkedType;
    }
    /**
      * Get LinkedType relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return LinkedType relationships
      */
    public LinkedType getLinkedTypeRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getLinkedTypeRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            LinkedType gotLinkedType = LinkedTypeMapper.mapOmrsRelationshipToLinkedType(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotLinkedType;
      }
    /**
      * Update LinkedType relationships
      * @param userId user identity
      * @param linkedType relationships
      * @return  LinkedType relationships
      */
      public LinkedType updateLinkedTypeRelationship(String userId,LinkedType linkedType)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateLinkedTypeRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = LinkedTypeMapper.mapLinkedTypeToOmrsRelationship(linkedType);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        LinkedType updatedLinkedType = LinkedTypeMapper.mapOmrsRelationshipToLinkedType(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedLinkedType;
    }
    /**
      * Create CrowdSourcingContribution relationships
      * @param userId user identity
      * @param relationships CrowdSourcingContribution relationships to create
      * @return created CrowdSourcingContribution relationships
      */
    public CrowdSourcingContribution createCrowdSourcingContributionRelationship(String userId,CrowdSourcingContribution relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createCrowdSourcingContributionRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = CrowdSourcingContributionMapper.mapCrowdSourcingContributionToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        CrowdSourcingContribution returnedCrowdSourcingContribution =  CrowdSourcingContributionMapper.mapOmrsRelationshipToCrowdSourcingContribution(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedCrowdSourcingContribution;
    }
    /**
      * Get CrowdSourcingContribution relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return CrowdSourcingContribution relationships
      */
    public CrowdSourcingContribution getCrowdSourcingContributionRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getCrowdSourcingContributionRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            CrowdSourcingContribution gotCrowdSourcingContribution = CrowdSourcingContributionMapper.mapOmrsRelationshipToCrowdSourcingContribution(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotCrowdSourcingContribution;
      }
    /**
      * Update CrowdSourcingContribution relationships
      * @param userId user identity
      * @param crowdSourcingContribution relationships
      * @return  CrowdSourcingContribution relationships
      */
      public CrowdSourcingContribution updateCrowdSourcingContributionRelationship(String userId,CrowdSourcingContribution crowdSourcingContribution)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateCrowdSourcingContributionRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = CrowdSourcingContributionMapper.mapCrowdSourcingContributionToOmrsRelationship(crowdSourcingContribution);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        CrowdSourcingContribution updatedCrowdSourcingContribution = CrowdSourcingContributionMapper.mapOmrsRelationshipToCrowdSourcingContribution(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedCrowdSourcingContribution;
    }
    /**
      * Create ProcessHierarchy relationships
      * @param userId user identity
      * @param relationships ProcessHierarchy relationships to create
      * @return created ProcessHierarchy relationships
      */
    public ProcessHierarchy createProcessHierarchyRelationship(String userId,ProcessHierarchy relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createProcessHierarchyRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = ProcessHierarchyMapper.mapProcessHierarchyToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        ProcessHierarchy returnedProcessHierarchy =  ProcessHierarchyMapper.mapOmrsRelationshipToProcessHierarchy(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedProcessHierarchy;
    }
    /**
      * Get ProcessHierarchy relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return ProcessHierarchy relationships
      */
    public ProcessHierarchy getProcessHierarchyRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getProcessHierarchyRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            ProcessHierarchy gotProcessHierarchy = ProcessHierarchyMapper.mapOmrsRelationshipToProcessHierarchy(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotProcessHierarchy;
      }
    /**
      * Update ProcessHierarchy relationships
      * @param userId user identity
      * @param processHierarchy relationships
      * @return  ProcessHierarchy relationships
      */
      public ProcessHierarchy updateProcessHierarchyRelationship(String userId,ProcessHierarchy processHierarchy)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateProcessHierarchyRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = ProcessHierarchyMapper.mapProcessHierarchyToOmrsRelationship(processHierarchy);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        ProcessHierarchy updatedProcessHierarchy = ProcessHierarchyMapper.mapOmrsRelationshipToProcessHierarchy(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedProcessHierarchy;
    }
    /**
      * Create GovernanceRuleImplementation relationships
      * @param userId user identity
      * @param relationships GovernanceRuleImplementation relationships to create
      * @return created GovernanceRuleImplementation relationships
      */
    public GovernanceRuleImplementation createGovernanceRuleImplementationRelationship(String userId,GovernanceRuleImplementation relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createGovernanceRuleImplementationRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = GovernanceRuleImplementationMapper.mapGovernanceRuleImplementationToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        GovernanceRuleImplementation returnedGovernanceRuleImplementation =  GovernanceRuleImplementationMapper.mapOmrsRelationshipToGovernanceRuleImplementation(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedGovernanceRuleImplementation;
    }
    /**
      * Get GovernanceRuleImplementation relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return GovernanceRuleImplementation relationships
      */
    public GovernanceRuleImplementation getGovernanceRuleImplementationRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getGovernanceRuleImplementationRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            GovernanceRuleImplementation gotGovernanceRuleImplementation = GovernanceRuleImplementationMapper.mapOmrsRelationshipToGovernanceRuleImplementation(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotGovernanceRuleImplementation;
      }
    /**
      * Update GovernanceRuleImplementation relationships
      * @param userId user identity
      * @param governanceRuleImplementation relationships
      * @return  GovernanceRuleImplementation relationships
      */
      public GovernanceRuleImplementation updateGovernanceRuleImplementationRelationship(String userId,GovernanceRuleImplementation governanceRuleImplementation)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateGovernanceRuleImplementationRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = GovernanceRuleImplementationMapper.mapGovernanceRuleImplementationToOmrsRelationship(governanceRuleImplementation);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        GovernanceRuleImplementation updatedGovernanceRuleImplementation = GovernanceRuleImplementationMapper.mapOmrsRelationshipToGovernanceRuleImplementation(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedGovernanceRuleImplementation;
    }
    /**
      * Create AdjacentLocation relationships
      * @param userId user identity
      * @param relationships AdjacentLocation relationships to create
      * @return created AdjacentLocation relationships
      */
    public AdjacentLocation createAdjacentLocationRelationship(String userId,AdjacentLocation relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createAdjacentLocationRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = AdjacentLocationMapper.mapAdjacentLocationToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        AdjacentLocation returnedAdjacentLocation =  AdjacentLocationMapper.mapOmrsRelationshipToAdjacentLocation(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedAdjacentLocation;
    }
    /**
      * Get AdjacentLocation relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return AdjacentLocation relationships
      */
    public AdjacentLocation getAdjacentLocationRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getAdjacentLocationRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            AdjacentLocation gotAdjacentLocation = AdjacentLocationMapper.mapOmrsRelationshipToAdjacentLocation(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotAdjacentLocation;
      }
    /**
      * Update AdjacentLocation relationships
      * @param userId user identity
      * @param adjacentLocation relationships
      * @return  AdjacentLocation relationships
      */
      public AdjacentLocation updateAdjacentLocationRelationship(String userId,AdjacentLocation adjacentLocation)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateAdjacentLocationRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = AdjacentLocationMapper.mapAdjacentLocationToOmrsRelationship(adjacentLocation);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        AdjacentLocation updatedAdjacentLocation = AdjacentLocationMapper.mapOmrsRelationshipToAdjacentLocation(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedAdjacentLocation;
    }
    /**
      * Create SemanticAssignment relationships
      * @param userId user identity
      * @param relationships SemanticAssignment relationships to create
      * @return created SemanticAssignment relationships
      */
    public SemanticAssignment createSemanticAssignmentRelationship(String userId,SemanticAssignment relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createSemanticAssignmentRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = SemanticAssignmentMapper.mapSemanticAssignmentToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        SemanticAssignment returnedSemanticAssignment =  SemanticAssignmentMapper.mapOmrsRelationshipToSemanticAssignment(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedSemanticAssignment;
    }
    /**
      * Get SemanticAssignment relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return SemanticAssignment relationships
      */
    public SemanticAssignment getSemanticAssignmentRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getSemanticAssignmentRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            SemanticAssignment gotSemanticAssignment = SemanticAssignmentMapper.mapOmrsRelationshipToSemanticAssignment(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotSemanticAssignment;
      }
    /**
      * Update SemanticAssignment relationships
      * @param userId user identity
      * @param semanticAssignment relationships
      * @return  SemanticAssignment relationships
      */
      public SemanticAssignment updateSemanticAssignmentRelationship(String userId,SemanticAssignment semanticAssignment)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateSemanticAssignmentRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = SemanticAssignmentMapper.mapSemanticAssignmentToOmrsRelationship(semanticAssignment);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        SemanticAssignment updatedSemanticAssignment = SemanticAssignmentMapper.mapOmrsRelationshipToSemanticAssignment(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedSemanticAssignment;
    }
    /**
      * Create HostLocation relationships
      * @param userId user identity
      * @param relationships HostLocation relationships to create
      * @return created HostLocation relationships
      */
    public HostLocation createHostLocationRelationship(String userId,HostLocation relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createHostLocationRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = HostLocationMapper.mapHostLocationToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        HostLocation returnedHostLocation =  HostLocationMapper.mapOmrsRelationshipToHostLocation(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedHostLocation;
    }
    /**
      * Get HostLocation relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return HostLocation relationships
      */
    public HostLocation getHostLocationRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getHostLocationRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            HostLocation gotHostLocation = HostLocationMapper.mapOmrsRelationshipToHostLocation(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotHostLocation;
      }
    /**
      * Update HostLocation relationships
      * @param userId user identity
      * @param hostLocation relationships
      * @return  HostLocation relationships
      */
      public HostLocation updateHostLocationRelationship(String userId,HostLocation hostLocation)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateHostLocationRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = HostLocationMapper.mapHostLocationToOmrsRelationship(hostLocation);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        HostLocation updatedHostLocation = HostLocationMapper.mapOmrsRelationshipToHostLocation(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedHostLocation;
    }
    /**
      * Create RelatedTerm relationships
      * @param userId user identity
      * @param relationships RelatedTerm relationships to create
      * @return created RelatedTerm relationships
      */
    public RelatedTerm createRelatedTermRelationship(String userId,RelatedTerm relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createRelatedTermRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = RelatedTermMapper.mapRelatedTermToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        RelatedTerm returnedRelatedTerm =  RelatedTermMapper.mapOmrsRelationshipToRelatedTerm(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedRelatedTerm;
    }
    /**
      * Get RelatedTerm relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return RelatedTerm relationships
      */
    public RelatedTerm getRelatedTermRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getRelatedTermRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            RelatedTerm gotRelatedTerm = RelatedTermMapper.mapOmrsRelationshipToRelatedTerm(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotRelatedTerm;
      }
    /**
      * Update RelatedTerm relationships
      * @param userId user identity
      * @param relatedTerm relationships
      * @return  RelatedTerm relationships
      */
      public RelatedTerm updateRelatedTermRelationship(String userId,RelatedTerm relatedTerm)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateRelatedTermRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = RelatedTermMapper.mapRelatedTermToOmrsRelationship(relatedTerm);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        RelatedTerm updatedRelatedTerm = RelatedTermMapper.mapOmrsRelationshipToRelatedTerm(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedRelatedTerm;
    }
    /**
      * Create SchemaTypeImplementation relationships
      * @param userId user identity
      * @param relationships SchemaTypeImplementation relationships to create
      * @return created SchemaTypeImplementation relationships
      */
    public SchemaTypeImplementation createSchemaTypeImplementationRelationship(String userId,SchemaTypeImplementation relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createSchemaTypeImplementationRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = SchemaTypeImplementationMapper.mapSchemaTypeImplementationToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        SchemaTypeImplementation returnedSchemaTypeImplementation =  SchemaTypeImplementationMapper.mapOmrsRelationshipToSchemaTypeImplementation(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedSchemaTypeImplementation;
    }
    /**
      * Get SchemaTypeImplementation relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return SchemaTypeImplementation relationships
      */
    public SchemaTypeImplementation getSchemaTypeImplementationRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getSchemaTypeImplementationRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            SchemaTypeImplementation gotSchemaTypeImplementation = SchemaTypeImplementationMapper.mapOmrsRelationshipToSchemaTypeImplementation(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotSchemaTypeImplementation;
      }
    /**
      * Update SchemaTypeImplementation relationships
      * @param userId user identity
      * @param schemaTypeImplementation relationships
      * @return  SchemaTypeImplementation relationships
      */
      public SchemaTypeImplementation updateSchemaTypeImplementationRelationship(String userId,SchemaTypeImplementation schemaTypeImplementation)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateSchemaTypeImplementationRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = SchemaTypeImplementationMapper.mapSchemaTypeImplementationToOmrsRelationship(schemaTypeImplementation);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        SchemaTypeImplementation updatedSchemaTypeImplementation = SchemaTypeImplementationMapper.mapOmrsRelationshipToSchemaTypeImplementation(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedSchemaTypeImplementation;
    }
    /**
      * Create APIHeader relationships
      * @param userId user identity
      * @param relationships APIHeader relationships to create
      * @return created APIHeader relationships
      */
    public APIHeader createAPIHeaderRelationship(String userId,APIHeader relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createAPIHeaderRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = APIHeaderMapper.mapAPIHeaderToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        APIHeader returnedAPIHeader =  APIHeaderMapper.mapOmrsRelationshipToAPIHeader(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedAPIHeader;
    }
    /**
      * Get APIHeader relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return APIHeader relationships
      */
    public APIHeader getAPIHeaderRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getAPIHeaderRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            APIHeader gotAPIHeader = APIHeaderMapper.mapOmrsRelationshipToAPIHeader(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotAPIHeader;
      }
    /**
      * Update APIHeader relationships
      * @param userId user identity
      * @param aPIHeader relationships
      * @return  APIHeader relationships
      */
      public APIHeader updateAPIHeaderRelationship(String userId,APIHeader aPIHeader)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateAPIHeaderRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = APIHeaderMapper.mapAPIHeaderToOmrsRelationship(aPIHeader);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        APIHeader updatedAPIHeader = APIHeaderMapper.mapOmrsRelationshipToAPIHeader(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedAPIHeader;
    }
    /**
      * Create LibraryTermReference relationships
      * @param userId user identity
      * @param relationships LibraryTermReference relationships to create
      * @return created LibraryTermReference relationships
      */
    public LibraryTermReference createLibraryTermReferenceRelationship(String userId,LibraryTermReference relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createLibraryTermReferenceRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = LibraryTermReferenceMapper.mapLibraryTermReferenceToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        LibraryTermReference returnedLibraryTermReference =  LibraryTermReferenceMapper.mapOmrsRelationshipToLibraryTermReference(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedLibraryTermReference;
    }
    /**
      * Get LibraryTermReference relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return LibraryTermReference relationships
      */
    public LibraryTermReference getLibraryTermReferenceRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getLibraryTermReferenceRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            LibraryTermReference gotLibraryTermReference = LibraryTermReferenceMapper.mapOmrsRelationshipToLibraryTermReference(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotLibraryTermReference;
      }
    /**
      * Update LibraryTermReference relationships
      * @param userId user identity
      * @param libraryTermReference relationships
      * @return  LibraryTermReference relationships
      */
      public LibraryTermReference updateLibraryTermReferenceRelationship(String userId,LibraryTermReference libraryTermReference)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateLibraryTermReferenceRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = LibraryTermReferenceMapper.mapLibraryTermReferenceToOmrsRelationship(libraryTermReference);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        LibraryTermReference updatedLibraryTermReference = LibraryTermReferenceMapper.mapOmrsRelationshipToLibraryTermReference(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedLibraryTermReference;
    }
    /**
      * Create AttachedTag relationships
      * @param userId user identity
      * @param relationships AttachedTag relationships to create
      * @return created AttachedTag relationships
      */
    public AttachedTag createAttachedTagRelationship(String userId,AttachedTag relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createAttachedTagRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = AttachedTagMapper.mapAttachedTagToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        AttachedTag returnedAttachedTag =  AttachedTagMapper.mapOmrsRelationshipToAttachedTag(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedAttachedTag;
    }
    /**
      * Get AttachedTag relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return AttachedTag relationships
      */
    public AttachedTag getAttachedTagRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getAttachedTagRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            AttachedTag gotAttachedTag = AttachedTagMapper.mapOmrsRelationshipToAttachedTag(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotAttachedTag;
      }
    /**
      * Update AttachedTag relationships
      * @param userId user identity
      * @param attachedTag relationships
      * @return  AttachedTag relationships
      */
      public AttachedTag updateAttachedTagRelationship(String userId,AttachedTag attachedTag)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateAttachedTagRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = AttachedTagMapper.mapAttachedTagToOmrsRelationship(attachedTag);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        AttachedTag updatedAttachedTag = AttachedTagMapper.mapOmrsRelationshipToAttachedTag(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedAttachedTag;
    }
    /**
      * Create TermHASARelationship relationships
      * @param userId user identity
      * @param relationships TermHASARelationship relationships to create
      * @return created TermHASARelationship relationships
      */
    public TermHASARelationship createTermHASARelationshipRelationship(String userId,TermHASARelationship relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createTermHASARelationshipRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = TermHASARelationshipMapper.mapTermHASARelationshipToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        TermHASARelationship returnedTermHASARelationship =  TermHASARelationshipMapper.mapOmrsRelationshipToTermHASARelationship(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedTermHASARelationship;
    }
    /**
      * Get TermHASARelationship relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return TermHASARelationship relationships
      */
    public TermHASARelationship getTermHASARelationshipRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getTermHASARelationshipRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            TermHASARelationship gotTermHASARelationship = TermHASARelationshipMapper.mapOmrsRelationshipToTermHASARelationship(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotTermHASARelationship;
      }
    /**
      * Update TermHASARelationship relationships
      * @param userId user identity
      * @param termHASARelationship relationships
      * @return  TermHASARelationship relationships
      */
      public TermHASARelationship updateTermHASARelationshipRelationship(String userId,TermHASARelationship termHASARelationship)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateTermHASARelationshipRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = TermHASARelationshipMapper.mapTermHASARelationshipToOmrsRelationship(termHASARelationship);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        TermHASARelationship updatedTermHASARelationship = TermHASARelationshipMapper.mapOmrsRelationshipToTermHASARelationship(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedTermHASARelationship;
    }
    /**
      * Create GovernanceProcessImplementation relationships
      * @param userId user identity
      * @param relationships GovernanceProcessImplementation relationships to create
      * @return created GovernanceProcessImplementation relationships
      */
    public GovernanceProcessImplementation createGovernanceProcessImplementationRelationship(String userId,GovernanceProcessImplementation relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createGovernanceProcessImplementationRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = GovernanceProcessImplementationMapper.mapGovernanceProcessImplementationToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        GovernanceProcessImplementation returnedGovernanceProcessImplementation =  GovernanceProcessImplementationMapper.mapOmrsRelationshipToGovernanceProcessImplementation(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedGovernanceProcessImplementation;
    }
    /**
      * Get GovernanceProcessImplementation relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return GovernanceProcessImplementation relationships
      */
    public GovernanceProcessImplementation getGovernanceProcessImplementationRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getGovernanceProcessImplementationRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            GovernanceProcessImplementation gotGovernanceProcessImplementation = GovernanceProcessImplementationMapper.mapOmrsRelationshipToGovernanceProcessImplementation(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotGovernanceProcessImplementation;
      }
    /**
      * Update GovernanceProcessImplementation relationships
      * @param userId user identity
      * @param governanceProcessImplementation relationships
      * @return  GovernanceProcessImplementation relationships
      */
      public GovernanceProcessImplementation updateGovernanceProcessImplementationRelationship(String userId,GovernanceProcessImplementation governanceProcessImplementation)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateGovernanceProcessImplementationRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = GovernanceProcessImplementationMapper.mapGovernanceProcessImplementationToOmrsRelationship(governanceProcessImplementation);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        GovernanceProcessImplementation updatedGovernanceProcessImplementation = GovernanceProcessImplementationMapper.mapOmrsRelationshipToGovernanceProcessImplementation(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedGovernanceProcessImplementation;
    }
    /**
      * Create GroupedMedia relationships
      * @param userId user identity
      * @param relationships GroupedMedia relationships to create
      * @return created GroupedMedia relationships
      */
    public GroupedMedia createGroupedMediaRelationship(String userId,GroupedMedia relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createGroupedMediaRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = GroupedMediaMapper.mapGroupedMediaToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        GroupedMedia returnedGroupedMedia =  GroupedMediaMapper.mapOmrsRelationshipToGroupedMedia(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedGroupedMedia;
    }
    /**
      * Get GroupedMedia relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return GroupedMedia relationships
      */
    public GroupedMedia getGroupedMediaRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getGroupedMediaRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            GroupedMedia gotGroupedMedia = GroupedMediaMapper.mapOmrsRelationshipToGroupedMedia(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotGroupedMedia;
      }
    /**
      * Update GroupedMedia relationships
      * @param userId user identity
      * @param groupedMedia relationships
      * @return  GroupedMedia relationships
      */
      public GroupedMedia updateGroupedMediaRelationship(String userId,GroupedMedia groupedMedia)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateGroupedMediaRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = GroupedMediaMapper.mapGroupedMediaToOmrsRelationship(groupedMedia);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        GroupedMedia updatedGroupedMedia = GroupedMediaMapper.mapOmrsRelationshipToGroupedMedia(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedGroupedMedia;
    }
    /**
      * Create GovernanceResponse relationships
      * @param userId user identity
      * @param relationships GovernanceResponse relationships to create
      * @return created GovernanceResponse relationships
      */
    public GovernanceResponse createGovernanceResponseRelationship(String userId,GovernanceResponse relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createGovernanceResponseRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = GovernanceResponseMapper.mapGovernanceResponseToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        GovernanceResponse returnedGovernanceResponse =  GovernanceResponseMapper.mapOmrsRelationshipToGovernanceResponse(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedGovernanceResponse;
    }
    /**
      * Get GovernanceResponse relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return GovernanceResponse relationships
      */
    public GovernanceResponse getGovernanceResponseRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getGovernanceResponseRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            GovernanceResponse gotGovernanceResponse = GovernanceResponseMapper.mapOmrsRelationshipToGovernanceResponse(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotGovernanceResponse;
      }
    /**
      * Update GovernanceResponse relationships
      * @param userId user identity
      * @param governanceResponse relationships
      * @return  GovernanceResponse relationships
      */
      public GovernanceResponse updateGovernanceResponseRelationship(String userId,GovernanceResponse governanceResponse)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateGovernanceResponseRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = GovernanceResponseMapper.mapGovernanceResponseToOmrsRelationship(governanceResponse);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        GovernanceResponse updatedGovernanceResponse = GovernanceResponseMapper.mapOmrsRelationshipToGovernanceResponse(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedGovernanceResponse;
    }
    /**
      * Create NestedFile relationships
      * @param userId user identity
      * @param relationships NestedFile relationships to create
      * @return created NestedFile relationships
      */
    public NestedFile createNestedFileRelationship(String userId,NestedFile relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createNestedFileRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = NestedFileMapper.mapNestedFileToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        NestedFile returnedNestedFile =  NestedFileMapper.mapOmrsRelationshipToNestedFile(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedNestedFile;
    }
    /**
      * Get NestedFile relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return NestedFile relationships
      */
    public NestedFile getNestedFileRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getNestedFileRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            NestedFile gotNestedFile = NestedFileMapper.mapOmrsRelationshipToNestedFile(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotNestedFile;
      }
    /**
      * Update NestedFile relationships
      * @param userId user identity
      * @param nestedFile relationships
      * @return  NestedFile relationships
      */
      public NestedFile updateNestedFileRelationship(String userId,NestedFile nestedFile)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateNestedFileRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = NestedFileMapper.mapNestedFileToOmrsRelationship(nestedFile);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        NestedFile updatedNestedFile = NestedFileMapper.mapOmrsRelationshipToNestedFile(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedNestedFile;
    }
    /**
      * Create PortInterface relationships
      * @param userId user identity
      * @param relationships PortInterface relationships to create
      * @return created PortInterface relationships
      */
    public PortInterface createPortInterfaceRelationship(String userId,PortInterface relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createPortInterfaceRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = PortInterfaceMapper.mapPortInterfaceToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        PortInterface returnedPortInterface =  PortInterfaceMapper.mapOmrsRelationshipToPortInterface(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedPortInterface;
    }
    /**
      * Get PortInterface relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return PortInterface relationships
      */
    public PortInterface getPortInterfaceRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getPortInterfaceRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            PortInterface gotPortInterface = PortInterfaceMapper.mapOmrsRelationshipToPortInterface(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotPortInterface;
      }
    /**
      * Update PortInterface relationships
      * @param userId user identity
      * @param portInterface relationships
      * @return  PortInterface relationships
      */
      public PortInterface updatePortInterfaceRelationship(String userId,PortInterface portInterface)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updatePortInterfaceRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = PortInterfaceMapper.mapPortInterfaceToOmrsRelationship(portInterface);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        PortInterface updatedPortInterface = PortInterfaceMapper.mapOmrsRelationshipToPortInterface(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedPortInterface;
    }
    /**
      * Create HostOperatingPlatform relationships
      * @param userId user identity
      * @param relationships HostOperatingPlatform relationships to create
      * @return created HostOperatingPlatform relationships
      */
    public HostOperatingPlatform createHostOperatingPlatformRelationship(String userId,HostOperatingPlatform relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createHostOperatingPlatformRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = HostOperatingPlatformMapper.mapHostOperatingPlatformToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        HostOperatingPlatform returnedHostOperatingPlatform =  HostOperatingPlatformMapper.mapOmrsRelationshipToHostOperatingPlatform(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedHostOperatingPlatform;
    }
    /**
      * Get HostOperatingPlatform relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return HostOperatingPlatform relationships
      */
    public HostOperatingPlatform getHostOperatingPlatformRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getHostOperatingPlatformRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            HostOperatingPlatform gotHostOperatingPlatform = HostOperatingPlatformMapper.mapOmrsRelationshipToHostOperatingPlatform(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotHostOperatingPlatform;
      }
    /**
      * Update HostOperatingPlatform relationships
      * @param userId user identity
      * @param hostOperatingPlatform relationships
      * @return  HostOperatingPlatform relationships
      */
      public HostOperatingPlatform updateHostOperatingPlatformRelationship(String userId,HostOperatingPlatform hostOperatingPlatform)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateHostOperatingPlatformRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = HostOperatingPlatformMapper.mapHostOperatingPlatformToOmrsRelationship(hostOperatingPlatform);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        HostOperatingPlatform updatedHostOperatingPlatform = HostOperatingPlatformMapper.mapOmrsRelationshipToHostOperatingPlatform(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedHostOperatingPlatform;
    }
    /**
      * Create TermAnchor relationships
      * @param userId user identity
      * @param relationships TermAnchor relationships to create
      * @return created TermAnchor relationships
      */
    public TermAnchor createTermAnchorRelationship(String userId,TermAnchor relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createTermAnchorRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = TermAnchorMapper.mapTermAnchorToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        TermAnchor returnedTermAnchor =  TermAnchorMapper.mapOmrsRelationshipToTermAnchor(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedTermAnchor;
    }
    /**
      * Get TermAnchor relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return TermAnchor relationships
      */
    public TermAnchor getTermAnchorRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getTermAnchorRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            TermAnchor gotTermAnchor = TermAnchorMapper.mapOmrsRelationshipToTermAnchor(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotTermAnchor;
      }
    /**
      * Update TermAnchor relationships
      * @param userId user identity
      * @param termAnchor relationships
      * @return  TermAnchor relationships
      */
      public TermAnchor updateTermAnchorRelationship(String userId,TermAnchor termAnchor)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateTermAnchorRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = TermAnchorMapper.mapTermAnchorToOmrsRelationship(termAnchor);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        TermAnchor updatedTermAnchor = TermAnchorMapper.mapOmrsRelationshipToTermAnchor(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedTermAnchor;
    }
    /**
      * Create ForeignKey relationships
      * @param userId user identity
      * @param relationships ForeignKey relationships to create
      * @return created ForeignKey relationships
      */
    public ForeignKey createForeignKeyRelationship(String userId,ForeignKey relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createForeignKeyRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = ForeignKeyMapper.mapForeignKeyToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        ForeignKey returnedForeignKey =  ForeignKeyMapper.mapOmrsRelationshipToForeignKey(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedForeignKey;
    }
    /**
      * Get ForeignKey relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return ForeignKey relationships
      */
    public ForeignKey getForeignKeyRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getForeignKeyRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            ForeignKey gotForeignKey = ForeignKeyMapper.mapOmrsRelationshipToForeignKey(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotForeignKey;
      }
    /**
      * Update ForeignKey relationships
      * @param userId user identity
      * @param foreignKey relationships
      * @return  ForeignKey relationships
      */
      public ForeignKey updateForeignKeyRelationship(String userId,ForeignKey foreignKey)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateForeignKeyRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = ForeignKeyMapper.mapForeignKeyToOmrsRelationship(foreignKey);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        ForeignKey updatedForeignKey = ForeignKeyMapper.mapOmrsRelationshipToForeignKey(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedForeignKey;
    }
    /**
      * Create DataProfileLogFile relationships
      * @param userId user identity
      * @param relationships DataProfileLogFile relationships to create
      * @return created DataProfileLogFile relationships
      */
    public DataProfileLogFile createDataProfileLogFileRelationship(String userId,DataProfileLogFile relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createDataProfileLogFileRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = DataProfileLogFileMapper.mapDataProfileLogFileToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        DataProfileLogFile returnedDataProfileLogFile =  DataProfileLogFileMapper.mapOmrsRelationshipToDataProfileLogFile(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedDataProfileLogFile;
    }
    /**
      * Get DataProfileLogFile relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return DataProfileLogFile relationships
      */
    public DataProfileLogFile getDataProfileLogFileRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getDataProfileLogFileRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            DataProfileLogFile gotDataProfileLogFile = DataProfileLogFileMapper.mapOmrsRelationshipToDataProfileLogFile(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotDataProfileLogFile;
      }
    /**
      * Update DataProfileLogFile relationships
      * @param userId user identity
      * @param dataProfileLogFile relationships
      * @return  DataProfileLogFile relationships
      */
      public DataProfileLogFile updateDataProfileLogFileRelationship(String userId,DataProfileLogFile dataProfileLogFile)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateDataProfileLogFileRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = DataProfileLogFileMapper.mapDataProfileLogFileToOmrsRelationship(dataProfileLogFile);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        DataProfileLogFile updatedDataProfileLogFile = DataProfileLogFileMapper.mapOmrsRelationshipToDataProfileLogFile(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedDataProfileLogFile;
    }
    /**
      * Create DiscoveryEngineReport relationships
      * @param userId user identity
      * @param relationships DiscoveryEngineReport relationships to create
      * @return created DiscoveryEngineReport relationships
      */
    public DiscoveryEngineReport createDiscoveryEngineReportRelationship(String userId,DiscoveryEngineReport relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createDiscoveryEngineReportRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = DiscoveryEngineReportMapper.mapDiscoveryEngineReportToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        DiscoveryEngineReport returnedDiscoveryEngineReport =  DiscoveryEngineReportMapper.mapOmrsRelationshipToDiscoveryEngineReport(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedDiscoveryEngineReport;
    }
    /**
      * Get DiscoveryEngineReport relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return DiscoveryEngineReport relationships
      */
    public DiscoveryEngineReport getDiscoveryEngineReportRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getDiscoveryEngineReportRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            DiscoveryEngineReport gotDiscoveryEngineReport = DiscoveryEngineReportMapper.mapOmrsRelationshipToDiscoveryEngineReport(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotDiscoveryEngineReport;
      }
    /**
      * Update DiscoveryEngineReport relationships
      * @param userId user identity
      * @param discoveryEngineReport relationships
      * @return  DiscoveryEngineReport relationships
      */
      public DiscoveryEngineReport updateDiscoveryEngineReportRelationship(String userId,DiscoveryEngineReport discoveryEngineReport)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateDiscoveryEngineReportRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = DiscoveryEngineReportMapper.mapDiscoveryEngineReportToOmrsRelationship(discoveryEngineReport);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        DiscoveryEngineReport updatedDiscoveryEngineReport = DiscoveryEngineReportMapper.mapOmrsRelationshipToDiscoveryEngineReport(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedDiscoveryEngineReport;
    }
    /**
      * Create APIRequest relationships
      * @param userId user identity
      * @param relationships APIRequest relationships to create
      * @return created APIRequest relationships
      */
    public APIRequest createAPIRequestRelationship(String userId,APIRequest relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createAPIRequestRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = APIRequestMapper.mapAPIRequestToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        APIRequest returnedAPIRequest =  APIRequestMapper.mapOmrsRelationshipToAPIRequest(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedAPIRequest;
    }
    /**
      * Get APIRequest relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return APIRequest relationships
      */
    public APIRequest getAPIRequestRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getAPIRequestRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            APIRequest gotAPIRequest = APIRequestMapper.mapOmrsRelationshipToAPIRequest(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotAPIRequest;
      }
    /**
      * Update APIRequest relationships
      * @param userId user identity
      * @param aPIRequest relationships
      * @return  APIRequest relationships
      */
      public APIRequest updateAPIRequestRelationship(String userId,APIRequest aPIRequest)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateAPIRequestRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = APIRequestMapper.mapAPIRequestToOmrsRelationship(aPIRequest);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        APIRequest updatedAPIRequest = APIRequestMapper.mapOmrsRelationshipToAPIRequest(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedAPIRequest;
    }
    /**
      * Create SoftwareServerDeployment relationships
      * @param userId user identity
      * @param relationships SoftwareServerDeployment relationships to create
      * @return created SoftwareServerDeployment relationships
      */
    public SoftwareServerDeployment createSoftwareServerDeploymentRelationship(String userId,SoftwareServerDeployment relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createSoftwareServerDeploymentRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = SoftwareServerDeploymentMapper.mapSoftwareServerDeploymentToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        SoftwareServerDeployment returnedSoftwareServerDeployment =  SoftwareServerDeploymentMapper.mapOmrsRelationshipToSoftwareServerDeployment(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedSoftwareServerDeployment;
    }
    /**
      * Get SoftwareServerDeployment relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return SoftwareServerDeployment relationships
      */
    public SoftwareServerDeployment getSoftwareServerDeploymentRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getSoftwareServerDeploymentRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            SoftwareServerDeployment gotSoftwareServerDeployment = SoftwareServerDeploymentMapper.mapOmrsRelationshipToSoftwareServerDeployment(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotSoftwareServerDeployment;
      }
    /**
      * Update SoftwareServerDeployment relationships
      * @param userId user identity
      * @param softwareServerDeployment relationships
      * @return  SoftwareServerDeployment relationships
      */
      public SoftwareServerDeployment updateSoftwareServerDeploymentRelationship(String userId,SoftwareServerDeployment softwareServerDeployment)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateSoftwareServerDeploymentRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = SoftwareServerDeploymentMapper.mapSoftwareServerDeploymentToOmrsRelationship(softwareServerDeployment);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        SoftwareServerDeployment updatedSoftwareServerDeployment = SoftwareServerDeploymentMapper.mapOmrsRelationshipToSoftwareServerDeployment(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedSoftwareServerDeployment;
    }
    /**
      * Create GovernanceRoleAssignment relationships
      * @param userId user identity
      * @param relationships GovernanceRoleAssignment relationships to create
      * @return created GovernanceRoleAssignment relationships
      */
    public GovernanceRoleAssignment createGovernanceRoleAssignmentRelationship(String userId,GovernanceRoleAssignment relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createGovernanceRoleAssignmentRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = GovernanceRoleAssignmentMapper.mapGovernanceRoleAssignmentToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        GovernanceRoleAssignment returnedGovernanceRoleAssignment =  GovernanceRoleAssignmentMapper.mapOmrsRelationshipToGovernanceRoleAssignment(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedGovernanceRoleAssignment;
    }
    /**
      * Get GovernanceRoleAssignment relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return GovernanceRoleAssignment relationships
      */
    public GovernanceRoleAssignment getGovernanceRoleAssignmentRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getGovernanceRoleAssignmentRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            GovernanceRoleAssignment gotGovernanceRoleAssignment = GovernanceRoleAssignmentMapper.mapOmrsRelationshipToGovernanceRoleAssignment(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotGovernanceRoleAssignment;
      }
    /**
      * Update GovernanceRoleAssignment relationships
      * @param userId user identity
      * @param governanceRoleAssignment relationships
      * @return  GovernanceRoleAssignment relationships
      */
      public GovernanceRoleAssignment updateGovernanceRoleAssignmentRelationship(String userId,GovernanceRoleAssignment governanceRoleAssignment)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateGovernanceRoleAssignmentRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = GovernanceRoleAssignmentMapper.mapGovernanceRoleAssignmentToOmrsRelationship(governanceRoleAssignment);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        GovernanceRoleAssignment updatedGovernanceRoleAssignment = GovernanceRoleAssignmentMapper.mapOmrsRelationshipToGovernanceRoleAssignment(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedGovernanceRoleAssignment;
    }
    /**
      * Create CohortMemberMetadataCollection relationships
      * @param userId user identity
      * @param relationships CohortMemberMetadataCollection relationships to create
      * @return created CohortMemberMetadataCollection relationships
      */
    public CohortMemberMetadataCollection createCohortMemberMetadataCollectionRelationship(String userId,CohortMemberMetadataCollection relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createCohortMemberMetadataCollectionRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = CohortMemberMetadataCollectionMapper.mapCohortMemberMetadataCollectionToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        CohortMemberMetadataCollection returnedCohortMemberMetadataCollection =  CohortMemberMetadataCollectionMapper.mapOmrsRelationshipToCohortMemberMetadataCollection(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedCohortMemberMetadataCollection;
    }
    /**
      * Get CohortMemberMetadataCollection relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return CohortMemberMetadataCollection relationships
      */
    public CohortMemberMetadataCollection getCohortMemberMetadataCollectionRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getCohortMemberMetadataCollectionRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            CohortMemberMetadataCollection gotCohortMemberMetadataCollection = CohortMemberMetadataCollectionMapper.mapOmrsRelationshipToCohortMemberMetadataCollection(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotCohortMemberMetadataCollection;
      }
    /**
      * Update CohortMemberMetadataCollection relationships
      * @param userId user identity
      * @param cohortMemberMetadataCollection relationships
      * @return  CohortMemberMetadataCollection relationships
      */
      public CohortMemberMetadataCollection updateCohortMemberMetadataCollectionRelationship(String userId,CohortMemberMetadataCollection cohortMemberMetadataCollection)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateCohortMemberMetadataCollectionRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = CohortMemberMetadataCollectionMapper.mapCohortMemberMetadataCollectionToOmrsRelationship(cohortMemberMetadataCollection);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        CohortMemberMetadataCollection updatedCohortMemberMetadataCollection = CohortMemberMetadataCollectionMapper.mapOmrsRelationshipToCohortMemberMetadataCollection(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedCohortMemberMetadataCollection;
    }
    /**
      * Create ReferenceableFacet relationships
      * @param userId user identity
      * @param relationships ReferenceableFacet relationships to create
      * @return created ReferenceableFacet relationships
      */
    public ReferenceableFacet createReferenceableFacetRelationship(String userId,ReferenceableFacet relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createReferenceableFacetRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = ReferenceableFacetMapper.mapReferenceableFacetToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        ReferenceableFacet returnedReferenceableFacet =  ReferenceableFacetMapper.mapOmrsRelationshipToReferenceableFacet(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedReferenceableFacet;
    }
    /**
      * Get ReferenceableFacet relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return ReferenceableFacet relationships
      */
    public ReferenceableFacet getReferenceableFacetRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getReferenceableFacetRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            ReferenceableFacet gotReferenceableFacet = ReferenceableFacetMapper.mapOmrsRelationshipToReferenceableFacet(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotReferenceableFacet;
      }
    /**
      * Update ReferenceableFacet relationships
      * @param userId user identity
      * @param referenceableFacet relationships
      * @return  ReferenceableFacet relationships
      */
      public ReferenceableFacet updateReferenceableFacetRelationship(String userId,ReferenceableFacet referenceableFacet)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateReferenceableFacetRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = ReferenceableFacetMapper.mapReferenceableFacetToOmrsRelationship(referenceableFacet);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        ReferenceableFacet updatedReferenceableFacet = ReferenceableFacetMapper.mapOmrsRelationshipToReferenceableFacet(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedReferenceableFacet;
    }
    /**
      * Create AssetDiscoveryReport relationships
      * @param userId user identity
      * @param relationships AssetDiscoveryReport relationships to create
      * @return created AssetDiscoveryReport relationships
      */
    public AssetDiscoveryReport createAssetDiscoveryReportRelationship(String userId,AssetDiscoveryReport relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createAssetDiscoveryReportRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = AssetDiscoveryReportMapper.mapAssetDiscoveryReportToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        AssetDiscoveryReport returnedAssetDiscoveryReport =  AssetDiscoveryReportMapper.mapOmrsRelationshipToAssetDiscoveryReport(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedAssetDiscoveryReport;
    }
    /**
      * Get AssetDiscoveryReport relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return AssetDiscoveryReport relationships
      */
    public AssetDiscoveryReport getAssetDiscoveryReportRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getAssetDiscoveryReportRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            AssetDiscoveryReport gotAssetDiscoveryReport = AssetDiscoveryReportMapper.mapOmrsRelationshipToAssetDiscoveryReport(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotAssetDiscoveryReport;
      }
    /**
      * Update AssetDiscoveryReport relationships
      * @param userId user identity
      * @param assetDiscoveryReport relationships
      * @return  AssetDiscoveryReport relationships
      */
      public AssetDiscoveryReport updateAssetDiscoveryReportRelationship(String userId,AssetDiscoveryReport assetDiscoveryReport)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateAssetDiscoveryReportRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = AssetDiscoveryReportMapper.mapAssetDiscoveryReportToOmrsRelationship(assetDiscoveryReport);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        AssetDiscoveryReport updatedAssetDiscoveryReport = AssetDiscoveryReportMapper.mapOmrsRelationshipToAssetDiscoveryReport(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedAssetDiscoveryReport;
    }
    /**
      * Create AttachedLike relationships
      * @param userId user identity
      * @param relationships AttachedLike relationships to create
      * @return created AttachedLike relationships
      */
    public AttachedLike createAttachedLikeRelationship(String userId,AttachedLike relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createAttachedLikeRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = AttachedLikeMapper.mapAttachedLikeToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        AttachedLike returnedAttachedLike =  AttachedLikeMapper.mapOmrsRelationshipToAttachedLike(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedAttachedLike;
    }
    /**
      * Get AttachedLike relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return AttachedLike relationships
      */
    public AttachedLike getAttachedLikeRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getAttachedLikeRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            AttachedLike gotAttachedLike = AttachedLikeMapper.mapOmrsRelationshipToAttachedLike(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotAttachedLike;
      }
    /**
      * Update AttachedLike relationships
      * @param userId user identity
      * @param attachedLike relationships
      * @return  AttachedLike relationships
      */
      public AttachedLike updateAttachedLikeRelationship(String userId,AttachedLike attachedLike)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateAttachedLikeRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = AttachedLikeMapper.mapAttachedLikeToOmrsRelationship(attachedLike);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        AttachedLike updatedAttachedLike = AttachedLikeMapper.mapOmrsRelationshipToAttachedLike(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedAttachedLike;
    }
    /**
      * Create NoteLogAuthorship relationships
      * @param userId user identity
      * @param relationships NoteLogAuthorship relationships to create
      * @return created NoteLogAuthorship relationships
      */
    public NoteLogAuthorship createNoteLogAuthorshipRelationship(String userId,NoteLogAuthorship relationships)
       throws StatusNotSupportedException, UserNotAuthorizedException, EntityNotKnownException,
            FunctionNotSupportedException, InvalidParameterException, RepositoryErrorException, PropertyErrorException, TypeErrorException
    {
        final String methodName = "createNoteLogAuthorshipRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);

        Relationship omrsRelationship = NoteLogAuthorshipMapper.mapNoteLogAuthorshipToOmrsRelationship(relationships);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSAddRelationship(userId,omrsRelationship);
        NoteLogAuthorship returnedNoteLogAuthorship =  NoteLogAuthorshipMapper.mapOmrsRelationshipToNoteLogAuthorship(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationships="+relationships);
        }
        return returnedNoteLogAuthorship;
    }
    /**
      * Get NoteLogAuthorship relationships
      * @param userId user identity
      * @param relationshipGuid relationships guid
      * @return NoteLogAuthorship relationships
      */
    public NoteLogAuthorship getNoteLogAuthorshipRelationship( String userId, String relationshipGuid)
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, RelationshipNotKnownException
      {
            final String methodName = "getNoteLogAuthorshipRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            Relationship returnedRelationship = oMRSAPIHelper.callOMRSGetRelationshipByGuid(userId,relationshipGuid);
            NoteLogAuthorship gotNoteLogAuthorship = NoteLogAuthorshipMapper.mapOmrsRelationshipToNoteLogAuthorship(returnedRelationship);
            if (log.isDebugEnabled()) {
                log.debug("<== successful Method: " + methodName + ",userId="+userId+",relationshipGuid="+relationshipGuid);
            }
            return gotNoteLogAuthorship;
      }
    /**
      * Update NoteLogAuthorship relationships
      * @param userId user identity
      * @param noteLogAuthorship relationships
      * @return  NoteLogAuthorship relationships
      */
      public NoteLogAuthorship updateNoteLogAuthorshipRelationship(String userId,NoteLogAuthorship noteLogAuthorship)
         throws StatusNotSupportedException, UserNotAuthorizedException, FunctionNotSupportedException,
            InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException, PropertyErrorException
        {
        final String methodName = "updateNoteLogAuthorshipRelationship";
        if (log.isDebugEnabled()) {
           log.debug("==> Method: " + methodName + ",userId="+userId);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);


        Relationship omrsRelationship = NoteLogAuthorshipMapper.mapNoteLogAuthorshipToOmrsRelationship(noteLogAuthorship);
        Relationship returnedRelationship = oMRSAPIHelper.callOMRSUpdateRelationship(userId,omrsRelationship);
        NoteLogAuthorship updatedNoteLogAuthorship = NoteLogAuthorshipMapper.mapOmrsRelationshipToNoteLogAuthorship(returnedRelationship);
        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId);
        }
        return updatedNoteLogAuthorship;
    }

    /**
      * Delete relationships. Any checking that the relationships is of a particular type should be done by the caller.
      * @param userId user identity
      * @param relationshipGuid relationshipGuid
      * @param typeName name of the type. This needs match the type associated with the relationships identified with the supplied GUID
      * @return deleted relationships
      */
     public Relationship deleteRelationship(String userId,String relationshipGuid, String typeName )
      throws UserNotAuthorizedException, RepositoryErrorException, InvalidParameterException, FunctionNotSupportedException, RelationshipNotKnownException
     {
            final String methodName = "deleteRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+relationshipGuid);
            }
            //InputValidator.validateUserIdNotNull(className,methodName,userId);
            //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");
             // get the appropriate type name and guid
             OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
             RelationshipDef relationshipDef = archiveAccessor.getRelationshipDefByName(typeName);
             String typeGuid = relationshipDef.getGUID();
             Relationship  deletedRelationship =oMRSAPIHelper.callOMRSDeleteRelationship(userId, typeGuid, typeName, relationshipGuid);
             if (log.isDebugEnabled()) {
                 log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+relationshipGuid);
             }

             return deletedRelationship;
     }
    /**
      * Purge relationships
      * @param userId user identity
      * @param relationshipGuid relationshipGuid
      * @param typeName name of the type. This needs match the type associated with the relationships identified with the supplied GUID
      */
     public void purgeRelationship(String userId,String relationshipGuid,String typeName)
      throws RelationshipNotDeletedException, UserNotAuthorizedException, FunctionNotSupportedException,
                  InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException
     {      final String methodName = "purgeRelationship";
            if (log.isDebugEnabled()) {
                log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+relationshipGuid);
            }
           //InputValidator.validateUserIdNotNull(className,methodName,userId);
           //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"relationshipGuid");

            // get the appropriate type name and guid
            OMRSArchiveAccessor archiveAccessor = OMRSArchiveAccessor.getInstance();
            RelationshipDef relationshipDef = archiveAccessor.getRelationshipDefByName(typeName);
            String typeGuid = relationshipDef.getGUID();

            oMRSAPIHelper.callOMRSPurgeRelationship(userId, typeGuid, typeName, relationshipGuid);
            if (log.isDebugEnabled()) {
                 log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+relationshipGuid);
            }
     }
    /**
     * Restore an relationships identified by its GUID. Restore resurrects a soft deleted relationships. When a relationships is incorrectly deleted, the delete can be undone by using this restore.
     * @param userId user identity
     * @param relationshipGuid GUID for the relationships
     * @return Relationship the restored relationships
     */
    public Relationship restoreRelationship(String userId,final String relationshipGuid)
          throws RelationshipNotDeletedException, UserNotAuthorizedException, FunctionNotSupportedException,
              InvalidParameterException, RepositoryErrorException, RelationshipNotKnownException
    {
        final String methodName = "restoreRelationship";
        if (log.isDebugEnabled()) {
            log.debug("==> Method: " + methodName + ",userId="+userId+",guid="+relationshipGuid);
        }
       //InputValidator.validateUserIdNotNull(className,methodName,userId);
       //InputValidator.validateGUIDNotNull(className,methodName,relationshipGuid,"entityGuid");
        Relationship restoredRelationship  =  oMRSAPIHelper.callOMRSRestoreRelationship(userId,relationshipGuid);

        if (log.isDebugEnabled()) {
            log.debug("<== successful Method: " + methodName + ",userId="+userId+",guid="+relationshipGuid);
        }
        return restoredRelationship;
    }
}
